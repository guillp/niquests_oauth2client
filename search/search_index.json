{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"requests_oauth2client is a Python OAuth 2.x client, able to obtain, refresh and revoke tokens from any OAuth2.x/OIDC compliant Authorization Server. It sits upon and extends the famous requests HTTP client module. It can act as an OAuth 2.0 / 2.1 client, to automatically get and renew access tokens, based on the Client Credentials , Authorization Code , Refresh token , Token Exchange , Device Authorization , or CIBA grants. It also supports OpenID Connect 1.0 , PKCE , Client Assertions , Token Revocation , and Introspection , Resource Indicators , JWT-secured Authorization Requests , Pushed Authorization Requests , as well as using custom params to any endpoint, and other important features that are often overlooked in other client libraries. And it also includes a wrapper around requests.Session that makes it super easy to use REST-style APIs, with or without OAuth 2.x. Please note that despite the name, this library has no relationship with Google oauth2client library. Documentation \u00b6 Full module documentation is available at https://guillp.github.io/requests_oauth2client/ Installation \u00b6 As easy as: 1 pip install requests_oauth2client Usage \u00b6 Import it like this: 1 from requests_oauth2client import * Note that this automatically imports requests , so no need to import it yourself. Calling APIs with Access Tokens \u00b6 If you already managed to obtain an access token, you can simply use the BearerAuth Auth Handler for requests : 1 2 token = \"an_access_token\" resp = requests . get ( \"https://my.protected.api/endpoint\" , auth = BearerAuth ( token )) This authentication handler will add a properly formatted Authorization header in the request, with your access token according to RFC6750 . Using an OAuth2Client \u00b6 OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints. To initialize an OAuth2Client , you only need a Token Endpoint URI, and the credentials for your application, which are often a client_id and a client_secret : 1 2 3 4 oauth2client = OAuth2Client ( token_endpoint = \"https://myas.local/token_endpoint\" , auth = ( \"client_id\" , \"client_secret\" ), ) The Token Endpoint is the only Endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by OAuth2Client is Client Secret Post , but other standardised methods such as Client Secret Basic , Client Secret JWT or Private Key JWT are supported as well. See more about client authentication methods below . Obtaining tokens \u00b6 OAuth2Client has methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the token endpoint and authentication method are already declared for the client at init time, the only required parameters are those that will be sent in the request to the Token Endpoint. Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken will manage the token expiration, will contain the eventual refresh token that matches the access token, and will keep track of other associated metadata as well. You can create such a BearerToken yourself if you need: 1 2 3 4 5 6 7 8 9 10 from requests_oauth2client import BearerToken bearer_token = BearerToken ( access_token = \"an_access_token\" , expires_in = 60 ) print ( bearer_token ) # {'access_token': 'an_access_token', # 'expires_in': 55, # 'token_type': 'Bearer'} print ( bearer_token . expires_at ) # datetime.datetime(2021, 8, 20, 9, 56, 59, 498793) assert not bearer_token . is_expired () Note that the expires_in indicator here is not static. It keeps track of the token lifetime and is calculated as the time flies. The actual static expiration date is accessible with the expires_at property. You can check if a token is expired with bearer_token.is_expired() . You can use a BearerToken instance anywhere you can supply an access_token as string. Using OAuth2Client as a requests Auth Handler \u00b6 While using OAuth2Client directly is great for testing or debugging OAuth2.x flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. requests_oauth2client contains several requests compatible Auth Handlers (as subclasses of requests.auth.AuthBase ), that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a requests.Session , or an ApiClient , which is a wrapper around Session with a few enhancements as described below. Client Credentials grant \u00b6 To send a request using the Client Credentials grant, use the aptly named .client_credentials() method, with the parameters to send in the token request as keyword parameters: 1 token = oauth2client . client_credentials ( scope = \"myscope\" , resource = \"https://myapi.local\" ) Parameters such as scope , resource or audience that may be required by the AS can be passed as keyword parameters. Those will be included in the token request that is sent to the AS. As Auth Handler \u00b6 You can use the OAuth2ClientCredentialsAuth auth handler. It takes an OAuth2Client as parameter, and the additional kwargs to pass to the token endpoint: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import requests auth = OAuth2ClientCredentialsAuth ( oauth2client , scope = \"myscope\" , resource = \"https://myapi.local\" ) # use it like this: requests . get ( \"https://myapi.local/resource\" , auth = auth ) # or session = requests . Session () session . auth = auth resp = session . get ( \"https://myapi.local/resource\" ) Once again, extra parameters such as scope , resource or audience are allowed if required. When you send your first request, OAuth2ClientCredentialsAuth will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in the request. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved once the previous one is expired. Authorization Code Grant \u00b6 Obtaining tokens with the Authorization code grant is made in 3 steps: your application must open specific url called the Authentication Request in a browser. your application must obtain and validate the Authorization Response , which is a redirection back to your application that contains an Authorization Code as parameter. your application must then exchange this Authorization Code for an Access Token , with a request to the Token Endpoint. OAuth2Client doesn't implement anything that is related to the Authorization Request or Response. It is only able to exchange the Authorization Code for a Token in step 3. But requests_oauth2client has other classes to help you with steps 1 and 2, as described below: Generating Authorization Requests \u00b6 You can generate valid authorization requests with the AuthorizationRequest class: 1 2 3 4 5 6 7 8 auth_request = AuthorizationRequest ( authorization_endpoint , client_id , redirect_uri = redirect_uri , scope = scope , resource = resource , # extra parameters can be included as well if required by your AS ) print ( auth_request ) # redirect the user to that URL to get a code This request will look like this (with line breaks for display purposes only): 1 2 3 4 5 6 7 8 9 10 https://myas.local/authorize ?client_id=my_client_id &redirect_uri=http%3A%2F%2Flocalhost%2Fcallback &response_type=code &state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc &nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc &scope=openid+email+profile &code_challenge=Dk11ttaDb_Hyq1dObMqQcTIlfYYRVblFMC9lFM3UWW8 &code_challenge_method=S256 &resource=https%3A%2F%2Fmy.resource.local%2Fapi AuthorizationRequest supports PKCE and uses it by default. You can avoid it by passing code_challenge_method=None to AuthorizationRequest . You can obtain the generated code_verifier from auth_request.code_verifier . Redirecting or otherwise sending the user to this url is your application responsibility, as well as obtaining the Authorization Response url. Validating the Authorization Response \u00b6 Once the user is successfully authenticated and authorized, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response . It contains several parameters that must be retrieved by your client. The authorization code is one of those parameters, but you must also validate that the state matches your request. You can do this with: 1 2 3 4 response_uri = input ( \"Please enter the full url and/or params obtained on the redirect_uri: \" ) auth_response = auth_request . validate_callback ( response_uri ) Exchanging code for tokens \u00b6 To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method. If you have obtained an AuthorizationResponse as described above, you can simply do: 1 token = oauth2client . authorization_code ( auth_response ) This will automatically include the code , redirect_uri and code_verifier parameters in the Token Request, as expected by the AS. If you managed another way to obtain an Authorization Code, you can manually pass those parameters like this: 1 2 3 4 5 6 token = oauth2client . authorization_code ( code = code , code_verifier = code_verifier , redirect_uri = redirect_uri , custom_param = custom_value , ) As Auth Handler \u00b6 The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server: 1 2 3 4 5 6 7 8 9 10 11 12 13 api_client = ApiClient ( \"https://your.protected.api/endpoint\" , auth = OAuth2AuthorizationCodeAuth ( client , code , code_verifier = auth_request . code_verifier , redirect_uri = redirect_uri , ), ) resp = api_client . post ( data = { ... } ) # first call will exchange the code for an initial access/refresh tokens OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available. Device Authorization Grant \u00b6 Helpers for the Device Authorization Grant are also included. To get device and user codes: 1 2 3 4 5 6 7 client = OAuth2Client ( token_endpoint = \"https://myas.local/token\" , device_authorization_endpoint = \"https://myas.local/device\" , auth = ( client_id , client_secret ), ) da_resp = client . authorize_device () da_resp contains the Device Code, User Code, Verification URI and other info returned by the AS: 1 2 3 4 5 6 da_resp . device_code da_resp . user_code da_resp . verification_uri da_resp . verification_uri_complete da_resp . expires_at # just like for BearerToken, expiration is tracked by requests_oauth2client da_resp . interval Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and input the User Code. You can then request the Token endpoint to check if the user successfully authorized you using an OAuth2Client : 1 token = client . device_code ( da_resp . device_code ) This will raise an exception, either AuthorizationPending , SlowDown , ExpiredToken , or AccessDenied if the user did not yet finish authorizing your device, if you should increase your pooling period, or if the device code is no longer valid, or the user finally denied your access, respectively. Other exceptions may be raised depending on the error code that the AS responds with. If the user did finish authorizing successfully, token will contain your access token. To make pooling easier, you can use a DeviceAuthorizationPoolingJob like this: 1 2 3 4 5 6 7 8 9 pool_job = DeviceAuthorizationPoolingJob ( client , device_auth_resp . device_code , interval = device_auth_resp . interval ) resp = None while resp is None : resp = pool_job () assert isinstance ( resp , BearerToken ) DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call pool_job(), it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests. As Auth Handler \u00b6 Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token: 1 2 3 4 5 6 7 8 9 10 11 12 13 api_client = ApiClient ( \"https://your.protected.api/endpoint\" , auth = OAuth2DeviceCodeAuth ( client , device_auth_resp . device_code , interval = device_auth_resp . interval , expires_in = device_auth_resp . expires_in , ), ) resp = api_client . post ( data = { ... } ) # first call will hang until the user authorizes your app and the token endpoint returns a token. Client-Initiated BackChannel Authentication (CIBA) \u00b6 To initiate a BackChannel Authentication against the dedicated endpoint: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client ( token_endpoint = \"https://myas.local/token\" , backchannel_authentication_endpoint = \"https://myas.local/backchannel_authorize\" , auth = ( client_id , client_secret ), ) ba_resp = client . backchannel_authentication_request ( scope = \"openid email profile\" , login_hint = \"user@example.net\" , ) ba_resp will contain the response attributes as returned by the AS, including an auth_req_id : 1 2 3 4 5 ba_resp . auth_req_id ba_resp . expires_in # decreases as times fly ba_resp . expires_at # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS ba_resp . interval # the pooling interval indicated by the AS ba_resp . custom # if the AS respond with additional attributes, they are also accessible To pool the Token Endpoint until the end-user successfully authenticates: 1 2 3 4 5 6 7 8 9 10 11 pool_job = BackChannelAuthenticationPoolingJob ( client = client , auth_req_id = ba_resp . auth_req_id , interval = bca_resp . interval , ) resp = None while resp is None : resp = pool_job () assert isinstance ( resp , BearerToken ) Hints by the AS to slow down pooling will automatically be obeyed. Token Exchange \u00b6 To send a token exchange request, use the OAuth2Client.token_exchange() method: 1 2 3 4 5 client = OAuth2Client ( token_endpoint , auth =... ) token = client . token_exchange ( subject_token = \"your_token_value\" , subject_token_type = \"urn:ietf:params:oauth:token-type:access_token\" , ) As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like actor_token or actor_token_type , or any custom parameter. There are short names for token types, that will be automatically translated to standardised types: 1 2 3 4 5 6 token = client . token_exchange ( subject_token = \"your_token_value\" , subject_token_type = \"access_token\" , # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\" actor_token = \"your_actor_token\" , actor_token_type = \"id_token\" , # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\" ) Or to make it even easier, types can be guessed based on the supplied subject or actor token: 1 2 3 4 5 6 7 8 token = client . token_exchange ( subject_token = BearerToken ( \"your_token_value\" ), # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\" actor_token = IdToken ( \"your_actor_token\" ), # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\" ) Supported Client Authentication Methods \u00b6 requests_oauth2client supports several client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client , with the auth parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards. client_secret_basic : client_id and client_secret are included in clear-text in the Authorization header. To use it, just pass a ClientSecretBasic(client_id, client_secret) as auth parameter: 1 client = OAuth2Client ( token_endpoint , auth = ClientSecretBasic ( client_id , client_secret )) client_secret_post : client_id and client_secret are included as part of the body form data. To use it, pass a ClientSecretPost(client_id, client_secret) as auth parameter. This also what is being used as default when you pass a tuple (client_id, client_secret) as auth : 1 2 3 client = OAuth2Client ( token_endpoint , auth = ClientSecretPost ( client_id , client_secret )) # or client = OAuth2Client ( token_endpoint , auth = ( client_id , client_secret )) client_secret_jwt : client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and expiration date. To use it, pass a ClientSecretJwt(client_id, client_secret) as auth parameter. Assertion generation is entirely automatic, you don't have anything to do: 1 client = OAuth2Client ( token_endpoint , auth = ClientSecretJwt ( client_id , client_secret )) private_key_jwt : client uses a JWT assertion like client_secret_jwt , but it is signed with an asymmetric key. To use it, you need a private signing key, in a dict that matches the JWK format. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is simple with the PrivateKeyJwt(client_id, private_jwk) auth handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private_jwk = { \"kid\" : \"mykid\" , \"kty\" : \"RSA\" , \"e\" : \"AQAB\" , \"n\" : \"...\" , \"d\" : \"...\" , \"p\" : \"...\" , \"q\" : \"...\" , \"dp\" : \"...\" , \"dq\" : \"...\" , \"qi\" : \"...\" , } client = OAuth2Client ( \"https://myas.local/token\" , auth = PrivateKeyJwt ( client_id , private_jwk ) ) Note that you can also directly pass a (client_id, jwk) tuple, with the same effect: 1 client = OAuth2Client ( token_endpoint , auth = ( client_id , private_jwk )) none : client only includes its client_id in body form data, without any authentication credentials. Use PublicApp(client_id) : 1 client = OAuth2Client ( token_endpoint , auth = PublicApp ( client_id , client_secret )) Token Revocation \u00b6 OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the OAuth2Client : 1 2 3 4 5 oauth2client = OAuth2Client ( token_endpoint , revocation_endpoint = revocation_endpoint , auth = ClientSecretJwt ( \"client_id\" , \"client_secret\" ), ) The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available: 1 2 3 4 5 6 7 oauth2client . revoke_token ( \"mytoken\" , token_type_hint = \"access_token\" ) oauth2client . revoke_access_token ( \"mytoken\" ) # will automatically add token_type_hint=access_token oauth2client . revoke_refresh_token ( \"mytoken\" ) # will automatically add token_type_hint=refresh_token Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server actually returns a standardised error, an exception will be raised instead. Token Introspection \u00b6 OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the OAuth2Client : 1 2 3 4 5 oauth2client = OAuth2Client ( token_endpoint , introspection_endpoint = introspection_endpoint , auth = ClientSecretJwt ( \"client_id\" , \"client_secret\" ), ) The OAuth2Client.introspect_token() method is then available: 1 resp = oauth2client . introspect_token ( \"mytoken\" , token_type_hint = \"access_token\" ) It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded). UserInfo Requests \u00b6 OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the OAuth2Client : 1 2 3 4 5 oauth2client = OAuth2Client ( token_endpoint , userinfo_endpoint = userinfo_endpoint , auth = ClientSecretJwt ( \"client_id\" , \"client_secret\" ), ) The OAuth2Client.userinfo() ) method is then available: 1 resp = oauth2client . userinfo ( \"mytoken\" ) It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded). Initializing an OAuth2Client from a discovery document \u00b6 You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method: 1 2 3 oauth2client = OAuth2Client . from_discovery_endpoint ( \"https://myas.local/.well-known/openid-configuration\" ) This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs. Specialized API Client \u00b6 Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, requests_oauth2client includes a requests.Session wrapper called ApiClient , which takes the root API url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an auth parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests -compatible Authentication Handler . Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant: 1 2 3 4 5 6 7 oauth2client = OAuth2Client ( \"https://myas.local/token\" , ( client_id , client_secret )) api = ApiClient ( \"https://myapi.local/root\" , auth = OAuth2ClientCredentialsAuth ( oauth2client ) ) # will actually send a GET to https://myapi.local/root/resource/foo resp = api . get ( \"/resource/foo\" ) Note that ApiClient will never send requests \"outside\" its configured root url, unless you specifically give it a full url at request time. The leading / in /resource above is optional. A leading / will not \"reset\" the url path to root, which means that you can also write the relative path without the / and it will automatically be included: 1 api . get ( \"resource/foo\" ) # will also send a GET to https://myapi.local/root/resource/foo You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a / and appended to the url path: 1 2 3 4 # will send a GET to https://myapi.local/root/resource/foo api . get ([ \"resource\" , \"foo\" ]) # will send a GET to https://myapi.local/root/users/1234/details api . get ([ \"users\" , 1234 , \"details\" ]) You can also use a syntax based on __getattr__ or __getitem__ : 1 2 api . resource . get () # will send a GET to https://myapi.local/root/resource api [ \"my-resource\" ] . get () # will send a GET to https://myapi.local/root/my-resource Both __getattr__ and __getitem__ return a new ApiClient initialised on the new base_url. So you can easily call multiple sub-resources on the same API this way: 1 2 3 4 5 6 api = ApiClient ( \"https://myapi.local\" ) users_api = api . users user = users_api . get ( \"userid\" ) # GET https://myapi.local/users/userid other_user = users_api . get ( \"other_userid\" ) # GET https://myapi.local/users/other_userid resources_api = api . resources resources = resources_api . get () # GET https://myapi.local/resources ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing raise_for_status=False when initializing your ApiClient : 1 2 3 4 5 6 api = ApiClient ( \"http://httpstat.us\" , raise_for_status = False ) # raise_for_status defaults to True resp = api . get ( \"500\" ) assert resp is not None # without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead You may override this at request time: 1 2 # raise_for_status at request-time overrides the value defined at init-time resp = api . get ( \"500\" , raise_for_status = True ) You can access the underlying requests.Session with the session attribute, and you can provide an already existing and configured Session instance at init time: 1 2 3 4 5 6 import requests session = requests . Session () session . proxies = { \"https\" : \"http://localhost:3128\" } api = ApiClient ( \"https://myapi.local/resource\" , session = session ) assert api . session == session Vendor-Specific clients \u00b6 requests_oauth2client being flexible enough to handle most use cases, you should be able to use any AS by any vendor as long as it supports OAuth 2.0. You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. The sub-module requests_oauth2client.vendor_specific includes such classes for Auth0 : 1 2 3 4 5 6 7 8 9 10 from requests_oauth2client.vendor_specific import Auth0Client a0client = Auth0Client ( \"mytenant.eu\" , ( client_id , client_secret )) # this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token # and other endpoints accordingly token = a0client . client_credentials ( audience = \"audience\" ) # this is a wrapper around Auth0 Management API a0mgmt = Auth0ManagementApiClient ( \"mytenant.eu\" , ( client_id , client_secret )) myusers = a0mgmt . get ( \"users\" )","title":"Home"},{"location":"#documentation","text":"Full module documentation is available at https://guillp.github.io/requests_oauth2client/","title":"Documentation"},{"location":"#installation","text":"As easy as: 1 pip install requests_oauth2client","title":"Installation"},{"location":"#usage","text":"Import it like this: 1 from requests_oauth2client import * Note that this automatically imports requests , so no need to import it yourself.","title":"Usage"},{"location":"#calling-apis-with-access-tokens","text":"If you already managed to obtain an access token, you can simply use the BearerAuth Auth Handler for requests : 1 2 token = \"an_access_token\" resp = requests . get ( \"https://my.protected.api/endpoint\" , auth = BearerAuth ( token )) This authentication handler will add a properly formatted Authorization header in the request, with your access token according to RFC6750 .","title":"Calling APIs with Access Tokens"},{"location":"#using-an-oauth2client","text":"OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints. To initialize an OAuth2Client , you only need a Token Endpoint URI, and the credentials for your application, which are often a client_id and a client_secret : 1 2 3 4 oauth2client = OAuth2Client ( token_endpoint = \"https://myas.local/token_endpoint\" , auth = ( \"client_id\" , \"client_secret\" ), ) The Token Endpoint is the only Endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by OAuth2Client is Client Secret Post , but other standardised methods such as Client Secret Basic , Client Secret JWT or Private Key JWT are supported as well. See more about client authentication methods below .","title":"Using an OAuth2Client"},{"location":"#obtaining-tokens","text":"OAuth2Client has methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the token endpoint and authentication method are already declared for the client at init time, the only required parameters are those that will be sent in the request to the Token Endpoint. Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken will manage the token expiration, will contain the eventual refresh token that matches the access token, and will keep track of other associated metadata as well. You can create such a BearerToken yourself if you need: 1 2 3 4 5 6 7 8 9 10 from requests_oauth2client import BearerToken bearer_token = BearerToken ( access_token = \"an_access_token\" , expires_in = 60 ) print ( bearer_token ) # {'access_token': 'an_access_token', # 'expires_in': 55, # 'token_type': 'Bearer'} print ( bearer_token . expires_at ) # datetime.datetime(2021, 8, 20, 9, 56, 59, 498793) assert not bearer_token . is_expired () Note that the expires_in indicator here is not static. It keeps track of the token lifetime and is calculated as the time flies. The actual static expiration date is accessible with the expires_at property. You can check if a token is expired with bearer_token.is_expired() . You can use a BearerToken instance anywhere you can supply an access_token as string.","title":"Obtaining tokens"},{"location":"#using-oauth2client-as-a-requests-auth-handler","text":"While using OAuth2Client directly is great for testing or debugging OAuth2.x flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. requests_oauth2client contains several requests compatible Auth Handlers (as subclasses of requests.auth.AuthBase ), that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a requests.Session , or an ApiClient , which is a wrapper around Session with a few enhancements as described below.","title":"Using OAuth2Client as a requests Auth Handler"},{"location":"#client-credentials-grant","text":"To send a request using the Client Credentials grant, use the aptly named .client_credentials() method, with the parameters to send in the token request as keyword parameters: 1 token = oauth2client . client_credentials ( scope = \"myscope\" , resource = \"https://myapi.local\" ) Parameters such as scope , resource or audience that may be required by the AS can be passed as keyword parameters. Those will be included in the token request that is sent to the AS.","title":"Client Credentials grant"},{"location":"#as-auth-handler","text":"You can use the OAuth2ClientCredentialsAuth auth handler. It takes an OAuth2Client as parameter, and the additional kwargs to pass to the token endpoint: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import requests auth = OAuth2ClientCredentialsAuth ( oauth2client , scope = \"myscope\" , resource = \"https://myapi.local\" ) # use it like this: requests . get ( \"https://myapi.local/resource\" , auth = auth ) # or session = requests . Session () session . auth = auth resp = session . get ( \"https://myapi.local/resource\" ) Once again, extra parameters such as scope , resource or audience are allowed if required. When you send your first request, OAuth2ClientCredentialsAuth will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in the request. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved once the previous one is expired.","title":"As Auth Handler"},{"location":"#authorization-code-grant","text":"Obtaining tokens with the Authorization code grant is made in 3 steps: your application must open specific url called the Authentication Request in a browser. your application must obtain and validate the Authorization Response , which is a redirection back to your application that contains an Authorization Code as parameter. your application must then exchange this Authorization Code for an Access Token , with a request to the Token Endpoint. OAuth2Client doesn't implement anything that is related to the Authorization Request or Response. It is only able to exchange the Authorization Code for a Token in step 3. But requests_oauth2client has other classes to help you with steps 1 and 2, as described below:","title":"Authorization Code Grant"},{"location":"#generating-authorization-requests","text":"You can generate valid authorization requests with the AuthorizationRequest class: 1 2 3 4 5 6 7 8 auth_request = AuthorizationRequest ( authorization_endpoint , client_id , redirect_uri = redirect_uri , scope = scope , resource = resource , # extra parameters can be included as well if required by your AS ) print ( auth_request ) # redirect the user to that URL to get a code This request will look like this (with line breaks for display purposes only): 1 2 3 4 5 6 7 8 9 10 https://myas.local/authorize ?client_id=my_client_id &redirect_uri=http%3A%2F%2Flocalhost%2Fcallback &response_type=code &state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc &nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc &scope=openid+email+profile &code_challenge=Dk11ttaDb_Hyq1dObMqQcTIlfYYRVblFMC9lFM3UWW8 &code_challenge_method=S256 &resource=https%3A%2F%2Fmy.resource.local%2Fapi AuthorizationRequest supports PKCE and uses it by default. You can avoid it by passing code_challenge_method=None to AuthorizationRequest . You can obtain the generated code_verifier from auth_request.code_verifier . Redirecting or otherwise sending the user to this url is your application responsibility, as well as obtaining the Authorization Response url.","title":"Generating Authorization Requests"},{"location":"#validating-the-authorization-response","text":"Once the user is successfully authenticated and authorized, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response . It contains several parameters that must be retrieved by your client. The authorization code is one of those parameters, but you must also validate that the state matches your request. You can do this with: 1 2 3 4 response_uri = input ( \"Please enter the full url and/or params obtained on the redirect_uri: \" ) auth_response = auth_request . validate_callback ( response_uri )","title":"Validating the Authorization Response"},{"location":"#exchanging-code-for-tokens","text":"To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method. If you have obtained an AuthorizationResponse as described above, you can simply do: 1 token = oauth2client . authorization_code ( auth_response ) This will automatically include the code , redirect_uri and code_verifier parameters in the Token Request, as expected by the AS. If you managed another way to obtain an Authorization Code, you can manually pass those parameters like this: 1 2 3 4 5 6 token = oauth2client . authorization_code ( code = code , code_verifier = code_verifier , redirect_uri = redirect_uri , custom_param = custom_value , )","title":"Exchanging code for tokens"},{"location":"#as-auth-handler_1","text":"The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server: 1 2 3 4 5 6 7 8 9 10 11 12 13 api_client = ApiClient ( \"https://your.protected.api/endpoint\" , auth = OAuth2AuthorizationCodeAuth ( client , code , code_verifier = auth_request . code_verifier , redirect_uri = redirect_uri , ), ) resp = api_client . post ( data = { ... } ) # first call will exchange the code for an initial access/refresh tokens OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available.","title":"As Auth Handler"},{"location":"#device-authorization-grant","text":"Helpers for the Device Authorization Grant are also included. To get device and user codes: 1 2 3 4 5 6 7 client = OAuth2Client ( token_endpoint = \"https://myas.local/token\" , device_authorization_endpoint = \"https://myas.local/device\" , auth = ( client_id , client_secret ), ) da_resp = client . authorize_device () da_resp contains the Device Code, User Code, Verification URI and other info returned by the AS: 1 2 3 4 5 6 da_resp . device_code da_resp . user_code da_resp . verification_uri da_resp . verification_uri_complete da_resp . expires_at # just like for BearerToken, expiration is tracked by requests_oauth2client da_resp . interval Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and input the User Code. You can then request the Token endpoint to check if the user successfully authorized you using an OAuth2Client : 1 token = client . device_code ( da_resp . device_code ) This will raise an exception, either AuthorizationPending , SlowDown , ExpiredToken , or AccessDenied if the user did not yet finish authorizing your device, if you should increase your pooling period, or if the device code is no longer valid, or the user finally denied your access, respectively. Other exceptions may be raised depending on the error code that the AS responds with. If the user did finish authorizing successfully, token will contain your access token. To make pooling easier, you can use a DeviceAuthorizationPoolingJob like this: 1 2 3 4 5 6 7 8 9 pool_job = DeviceAuthorizationPoolingJob ( client , device_auth_resp . device_code , interval = device_auth_resp . interval ) resp = None while resp is None : resp = pool_job () assert isinstance ( resp , BearerToken ) DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call pool_job(), it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests.","title":"Device Authorization Grant"},{"location":"#as-auth-handler_2","text":"Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token: 1 2 3 4 5 6 7 8 9 10 11 12 13 api_client = ApiClient ( \"https://your.protected.api/endpoint\" , auth = OAuth2DeviceCodeAuth ( client , device_auth_resp . device_code , interval = device_auth_resp . interval , expires_in = device_auth_resp . expires_in , ), ) resp = api_client . post ( data = { ... } ) # first call will hang until the user authorizes your app and the token endpoint returns a token.","title":"As Auth Handler"},{"location":"#client-initiated-backchannel-authentication-ciba","text":"To initiate a BackChannel Authentication against the dedicated endpoint: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client ( token_endpoint = \"https://myas.local/token\" , backchannel_authentication_endpoint = \"https://myas.local/backchannel_authorize\" , auth = ( client_id , client_secret ), ) ba_resp = client . backchannel_authentication_request ( scope = \"openid email profile\" , login_hint = \"user@example.net\" , ) ba_resp will contain the response attributes as returned by the AS, including an auth_req_id : 1 2 3 4 5 ba_resp . auth_req_id ba_resp . expires_in # decreases as times fly ba_resp . expires_at # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS ba_resp . interval # the pooling interval indicated by the AS ba_resp . custom # if the AS respond with additional attributes, they are also accessible To pool the Token Endpoint until the end-user successfully authenticates: 1 2 3 4 5 6 7 8 9 10 11 pool_job = BackChannelAuthenticationPoolingJob ( client = client , auth_req_id = ba_resp . auth_req_id , interval = bca_resp . interval , ) resp = None while resp is None : resp = pool_job () assert isinstance ( resp , BearerToken ) Hints by the AS to slow down pooling will automatically be obeyed.","title":"Client-Initiated BackChannel Authentication (CIBA)"},{"location":"#token-exchange","text":"To send a token exchange request, use the OAuth2Client.token_exchange() method: 1 2 3 4 5 client = OAuth2Client ( token_endpoint , auth =... ) token = client . token_exchange ( subject_token = \"your_token_value\" , subject_token_type = \"urn:ietf:params:oauth:token-type:access_token\" , ) As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like actor_token or actor_token_type , or any custom parameter. There are short names for token types, that will be automatically translated to standardised types: 1 2 3 4 5 6 token = client . token_exchange ( subject_token = \"your_token_value\" , subject_token_type = \"access_token\" , # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\" actor_token = \"your_actor_token\" , actor_token_type = \"id_token\" , # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\" ) Or to make it even easier, types can be guessed based on the supplied subject or actor token: 1 2 3 4 5 6 7 8 token = client . token_exchange ( subject_token = BearerToken ( \"your_token_value\" ), # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\" actor_token = IdToken ( \"your_actor_token\" ), # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\" )","title":"Token Exchange"},{"location":"#supported-client-authentication-methods","text":"requests_oauth2client supports several client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client , with the auth parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards. client_secret_basic : client_id and client_secret are included in clear-text in the Authorization header. To use it, just pass a ClientSecretBasic(client_id, client_secret) as auth parameter: 1 client = OAuth2Client ( token_endpoint , auth = ClientSecretBasic ( client_id , client_secret )) client_secret_post : client_id and client_secret are included as part of the body form data. To use it, pass a ClientSecretPost(client_id, client_secret) as auth parameter. This also what is being used as default when you pass a tuple (client_id, client_secret) as auth : 1 2 3 client = OAuth2Client ( token_endpoint , auth = ClientSecretPost ( client_id , client_secret )) # or client = OAuth2Client ( token_endpoint , auth = ( client_id , client_secret )) client_secret_jwt : client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and expiration date. To use it, pass a ClientSecretJwt(client_id, client_secret) as auth parameter. Assertion generation is entirely automatic, you don't have anything to do: 1 client = OAuth2Client ( token_endpoint , auth = ClientSecretJwt ( client_id , client_secret )) private_key_jwt : client uses a JWT assertion like client_secret_jwt , but it is signed with an asymmetric key. To use it, you need a private signing key, in a dict that matches the JWK format. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is simple with the PrivateKeyJwt(client_id, private_jwk) auth handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private_jwk = { \"kid\" : \"mykid\" , \"kty\" : \"RSA\" , \"e\" : \"AQAB\" , \"n\" : \"...\" , \"d\" : \"...\" , \"p\" : \"...\" , \"q\" : \"...\" , \"dp\" : \"...\" , \"dq\" : \"...\" , \"qi\" : \"...\" , } client = OAuth2Client ( \"https://myas.local/token\" , auth = PrivateKeyJwt ( client_id , private_jwk ) ) Note that you can also directly pass a (client_id, jwk) tuple, with the same effect: 1 client = OAuth2Client ( token_endpoint , auth = ( client_id , private_jwk )) none : client only includes its client_id in body form data, without any authentication credentials. Use PublicApp(client_id) : 1 client = OAuth2Client ( token_endpoint , auth = PublicApp ( client_id , client_secret ))","title":"Supported Client Authentication Methods"},{"location":"#token-revocation","text":"OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the OAuth2Client : 1 2 3 4 5 oauth2client = OAuth2Client ( token_endpoint , revocation_endpoint = revocation_endpoint , auth = ClientSecretJwt ( \"client_id\" , \"client_secret\" ), ) The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available: 1 2 3 4 5 6 7 oauth2client . revoke_token ( \"mytoken\" , token_type_hint = \"access_token\" ) oauth2client . revoke_access_token ( \"mytoken\" ) # will automatically add token_type_hint=access_token oauth2client . revoke_refresh_token ( \"mytoken\" ) # will automatically add token_type_hint=refresh_token Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server actually returns a standardised error, an exception will be raised instead.","title":"Token Revocation"},{"location":"#token-introspection","text":"OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the OAuth2Client : 1 2 3 4 5 oauth2client = OAuth2Client ( token_endpoint , introspection_endpoint = introspection_endpoint , auth = ClientSecretJwt ( \"client_id\" , \"client_secret\" ), ) The OAuth2Client.introspect_token() method is then available: 1 resp = oauth2client . introspect_token ( \"mytoken\" , token_type_hint = \"access_token\" ) It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded).","title":"Token Introspection"},{"location":"#userinfo-requests","text":"OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the OAuth2Client : 1 2 3 4 5 oauth2client = OAuth2Client ( token_endpoint , userinfo_endpoint = userinfo_endpoint , auth = ClientSecretJwt ( \"client_id\" , \"client_secret\" ), ) The OAuth2Client.userinfo() ) method is then available: 1 resp = oauth2client . userinfo ( \"mytoken\" ) It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded).","title":"UserInfo Requests"},{"location":"#initializing-an-oauth2client-from-a-discovery-document","text":"You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method: 1 2 3 oauth2client = OAuth2Client . from_discovery_endpoint ( \"https://myas.local/.well-known/openid-configuration\" ) This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs.","title":"Initializing an OAuth2Client from a discovery document"},{"location":"#specialized-api-client","text":"Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, requests_oauth2client includes a requests.Session wrapper called ApiClient , which takes the root API url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an auth parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests -compatible Authentication Handler . Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant: 1 2 3 4 5 6 7 oauth2client = OAuth2Client ( \"https://myas.local/token\" , ( client_id , client_secret )) api = ApiClient ( \"https://myapi.local/root\" , auth = OAuth2ClientCredentialsAuth ( oauth2client ) ) # will actually send a GET to https://myapi.local/root/resource/foo resp = api . get ( \"/resource/foo\" ) Note that ApiClient will never send requests \"outside\" its configured root url, unless you specifically give it a full url at request time. The leading / in /resource above is optional. A leading / will not \"reset\" the url path to root, which means that you can also write the relative path without the / and it will automatically be included: 1 api . get ( \"resource/foo\" ) # will also send a GET to https://myapi.local/root/resource/foo You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a / and appended to the url path: 1 2 3 4 # will send a GET to https://myapi.local/root/resource/foo api . get ([ \"resource\" , \"foo\" ]) # will send a GET to https://myapi.local/root/users/1234/details api . get ([ \"users\" , 1234 , \"details\" ]) You can also use a syntax based on __getattr__ or __getitem__ : 1 2 api . resource . get () # will send a GET to https://myapi.local/root/resource api [ \"my-resource\" ] . get () # will send a GET to https://myapi.local/root/my-resource Both __getattr__ and __getitem__ return a new ApiClient initialised on the new base_url. So you can easily call multiple sub-resources on the same API this way: 1 2 3 4 5 6 api = ApiClient ( \"https://myapi.local\" ) users_api = api . users user = users_api . get ( \"userid\" ) # GET https://myapi.local/users/userid other_user = users_api . get ( \"other_userid\" ) # GET https://myapi.local/users/other_userid resources_api = api . resources resources = resources_api . get () # GET https://myapi.local/resources ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing raise_for_status=False when initializing your ApiClient : 1 2 3 4 5 6 api = ApiClient ( \"http://httpstat.us\" , raise_for_status = False ) # raise_for_status defaults to True resp = api . get ( \"500\" ) assert resp is not None # without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead You may override this at request time: 1 2 # raise_for_status at request-time overrides the value defined at init-time resp = api . get ( \"500\" , raise_for_status = True ) You can access the underlying requests.Session with the session attribute, and you can provide an already existing and configured Session instance at init time: 1 2 3 4 5 6 import requests session = requests . Session () session . proxies = { \"https\" : \"http://localhost:3128\" } api = ApiClient ( \"https://myapi.local/resource\" , session = session ) assert api . session == session","title":"Specialized API Client"},{"location":"#vendor-specific-clients","text":"requests_oauth2client being flexible enough to handle most use cases, you should be able to use any AS by any vendor as long as it supports OAuth 2.0. You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. The sub-module requests_oauth2client.vendor_specific includes such classes for Auth0 : 1 2 3 4 5 6 7 8 9 10 from requests_oauth2client.vendor_specific import Auth0Client a0client = Auth0Client ( \"mytenant.eu\" , ( client_id , client_secret )) # this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token # and other endpoints accordingly token = a0client . client_credentials ( audience = \"audience\" ) # this is a wrapper around Auth0 Management API a0mgmt = Auth0ManagementApiClient ( \"mytenant.eu\" , ( client_id , client_secret )) myusers = a0mgmt . get ( \"users\" )","title":"Vendor-Specific clients"},{"location":"api/","text":"Main module for requests_oauth2client . You can import any class from any submodule directly from this main module. api_client \u00b6 ApiClient main module. ApiClient \u00b6 A Wrapper around requests.Session to simplify Rest API calls. This allows setting a root url at creation time, then passing relative urls at request time. It may also raise exceptions instead of returning error responses. You can also pass additional kwargs at init time, which will be used to configure the Session , instead of setting them later. Basic usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from requests_oauth2client import ApiClient api = ApiClient ( \"https://myapi.local/resource\" , timeout = 10 ) resp = api . get ( \"/myid\" ) # this will send a GET request # to https://myapi.local/resource/myid # you can pass an underlying requests.Session at init time session = requests . Session () session . proxies = { \"https\" : \"https://localhost:3128\" } api = ApiClient ( \"https://myapi.local/resource\" , session = session ) # or you can let ApiClient init it's own session and provide additional configuration parameters: api = ApiClient ( \"https://myapi.local/resource\" , proxies = { \"https\" : \"https://localhost:3128\" } ) Source code in requests_oauth2client/api_client.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 class ApiClient : \"\"\" A Wrapper around [requests.Session][] to simplify Rest API calls. This allows setting a root url at creation time, then passing relative urls at request time. It may also raise exceptions instead of returning error responses. You can also pass additional kwargs at init time, which will be used to configure the [Session][requests.Session], instead of setting them later. Basic usage: ```python from requests_oauth2client import ApiClient api = ApiClient(\"https://myapi.local/resource\", timeout=10) resp = api.get(\"/myid\") # this will send a GET request # to https://myapi.local/resource/myid # you can pass an underlying requests.Session at init time session = requests.Session() session.proxies = {\"https\": \"https://localhost:3128\"} api = ApiClient(\"https://myapi.local/resource\", session=session) # or you can let ApiClient init it's own session and provide additional configuration parameters: api = ApiClient( \"https://myapi.local/resource\", proxies={\"https\": \"https://localhost:3128\"} ) ``` \"\"\" def __init__ ( self , base_url : Optional [ str ] = None , auth : Optional [ requests . auth . AuthBase ] = None , timeout : Optional [ int ] = 60 , raise_for_status : bool = True , none_fields : Literal [ \"include\" , \"exclude\" , \"empty\" ] = \"exclude\" , bool_fields : Optional [ Tuple [ Any , Any ]] = ( \"true\" , \"false\" ), session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an `ApiClient`, with an optional root url. `base_url` will serve as root for relative urls passed to [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request], [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc. An `HTTPError` will be raised everytime an API call returns an error code (>= 400), unless you set `raise_for_status` to `False`. Additional parameters passed at init time, including `auth` will be used to configure the [Session][requests.Session]. :param base_url: the base api url, that should be root for all the target API endpoints. :param auth: the [requests.auth.AuthBase][] to use as authentication handler. :param timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to `None` to disable timeout. :param raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (>= 400). :param none_fields: if `\"exclude\"` (default), data or json fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with a boolean value (`True` or `False`) will be serialized to the corresponding value. This can be useful since some APIs expect a `'true'` or `'false'` value as boolean, and requests serialises `True` to `'True'` and `False` to `'False'`. Set it to `None` to restore default requests behaviour. :param kwargs: additional kwargs to configure this session. This parameter may be overridden at request time. \"\"\" super ( ApiClient , self ) . __init__ () self . base_url = base_url self . raise_for_status = raise_for_status self . none_fields = none_fields self . bool_fields = bool_fields if bool_fields is not None else ( True , False ) self . timeout = timeout self . session = session or requests . Session () self . session . auth = auth for key , val in kwargs . items (): setattr ( self . session , key , val ) def request ( # noqa: C901 self , method : str , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , params : Union [ None , bytes , MutableMapping [ str , str ]] = None , data : Union [ None , str , bytes , Mapping [ str , Any ], Iterable [ Tuple [ str , Optional [ str ]]], IO [ Any ], ] = None , headers : Optional [ MutableMapping [ str , str ]] = None , cookies : Union [ None , RequestsCookieJar , MutableMapping [ str , str ]] = None , files : Optional [ MutableMapping [ str , IO [ Any ]]] = None , auth : Union [ None , Tuple [ str , str ], requests . auth . AuthBase , Callable [[ requests . PreparedRequest ], requests . PreparedRequest ], ] = None , timeout : Union [ None , float , Tuple [ float , float ], Tuple [ float , None ]] = None , allow_redirects : Optional [ bool ] = True , proxies : Optional [ MutableMapping [ str , str ]] = None , hooks : Optional [ MutableMapping [ str , Union [ Iterable [ Callable [[ requests . Response ], Any ]], Callable [[ requests . Response ], Any ], ], ] ] = None , stream : Optional [ bool ] = None , verify : Optional [ Union [ str , bool ]] = None , cert : Optional [ Union [ str , Tuple [ str , str ]]] = None , json : Optional [ Mapping [ str , Any ]] = None , raise_for_status : Optional [ bool ] = None , none_fields : Optional [ Literal [ \"include\" , \"exclude\" , \"empty\" ]] = None , bool_fields : Optional [ Tuple [ Any , Any ]] = None , ) -> requests . Response : \"\"\" Overridden `request` method that can handle a relative path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url. :param raise_for_status: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param none_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param bool_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :return: a [requests.Response][] as returned by requests \"\"\" url = self . to_absolute_url ( url ) if none_fields is None : none_fields = self . none_fields if none_fields == \"exclude\" : if isinstance ( data , Mapping ): data = { key : val for key , val in data . items () if val is not None } if isinstance ( json , Mapping ): json = { key : val for key , val in json . items () if val is not None } elif none_fields == \"empty\" : if isinstance ( data , Mapping ): data = { key : val if val is not None else \"\" for key , val in data . items () } if isinstance ( json , Mapping ): json = { key : val if val is not None else \"\" for key , val in json . items () } if bool_fields is None : bool_fields = self . bool_fields if bool_fields : try : true_value , false_value = bool_fields except ValueError : raise ValueError ( \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\" ) if isinstance ( data , MutableMapping ): for key , val in data . items (): if val is True : data [ key ] = true_value elif val is False : data [ key ] = false_value if isinstance ( params , MutableMapping ): for key , val in params . items (): if val is True : params [ key ] = true_value elif val is False : params [ key ] = false_value timeout = timeout or self . timeout response = self . session . request ( method , url , params = params , data = data , headers = headers , cookies = cookies , files = files , auth = auth , timeout = timeout , allow_redirects = allow_redirects , proxies = proxies , hooks = hooks , stream = stream , verify = verify , cert = cert , json = json , ) if raise_for_status is None : raise_for_status = self . raise_for_status if raise_for_status : response . raise_for_status () return response def to_absolute_url ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None ) -> str : \"\"\"Given an 'url', that can be relative or absolute, return the matching absolute url, based on the base url. :param url: a (possibly relative) url :return: the matching absolute url \"\"\" if self . base_url : if url is not None : if not isinstance ( url , ( str , bytes )): try : url = \"/\" . join ( [ part . decode () if isinstance ( part , bytes ) else str ( part ) for part in url if part ] ) except TypeError : raise TypeError ( \"Unexpected url type, please pass a relative path as string or bytes, \" \"or an iterable of string-able objects\" , type ( url ), ) if isinstance ( url , bytes ): url = url . decode () url = urljoin ( self . base_url + \"/\" , url . lstrip ( \"/\" )) else : url = self . base_url if url is None or not isinstance ( url , str ): raise ValueError ( \"Unable to determine an absolute url.\" ) return url def get ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a GET request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param none_data_fields: if `\"exclude\"` (default), data fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param kwargs: Optional arguments that [request()][requests.request] takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. and an error response is returned. \"\"\" return self . request ( \"GET\" , url , raise_for_status = raise_for_status , ** kwargs ) def post ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a POST request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"POST\" , url , raise_for_status = raise_for_status , ** kwargs ) def patch ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PATCH request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PATCH\" , url , raise_for_status = raise_for_status , ** kwargs ) def put ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PUT request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PUT\" , url , raise_for_status = raise_for_status , ** kwargs ) def delete ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a DELETE request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"DELETE\" , url , raise_for_status = raise_for_status , ** kwargs ) def __getattr__ ( self , item : str ) -> ApiClient : \"\"\"Allow access sub resources with an attribute-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api.resource1.get() # GET https://myapi.local/resource1 resource2 = api.resource2.get() # GET https://myapi.local/resource2 ``` :param item: a subpath :return: a new ApiClient initialised on the new base url \"\"\" return self [ item ] def __getitem__ ( self , item : str ) -> ApiClient : \"\"\"Allow access to sub resources with a subscription-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api['resource1'].get() # GET https://myapi.local/resource1 resource2 = api['resource2'].get() # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the the new base url \"\"\" new_base_uri = self . to_absolute_url ( item ) return self . __class__ ( new_base_uri , session = self . session , none_fields = self . none_fields , bool_fields = self . bool_fields , timeout = self . timeout , raise_for_status = self . raise_for_status , ) def __enter__ ( self ) -> ApiClient : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" return self def __exit__ ( self , * args : Any ) -> None : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" self . session . close () __enter__ () \u00b6 Allow ApiClient to act as a context manager, the same way as requests.Session . Source code in requests_oauth2client/api_client.py 395 396 397 def __enter__ ( self ) -> ApiClient : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" return self __exit__ ( * args ) \u00b6 Allow ApiClient to act as a context manager, the same way as requests.Session . Source code in requests_oauth2client/api_client.py 399 400 401 def __exit__ ( self , * args : Any ) -> None : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" self . session . close () __getattr__ ( item ) \u00b6 Allow access sub resources with an attribute-based syntax. 1 2 3 api = ApiClient ( \"https://myapi.local\" ) resource1 = api . resource1 . get () # GET https://myapi.local/resource1 resource2 = api . resource2 . get () # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the new base url Source code in requests_oauth2client/api_client.py 360 361 362 363 364 365 366 367 368 369 370 371 372 def __getattr__ ( self , item : str ) -> ApiClient : \"\"\"Allow access sub resources with an attribute-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api.resource1.get() # GET https://myapi.local/resource1 resource2 = api.resource2.get() # GET https://myapi.local/resource2 ``` :param item: a subpath :return: a new ApiClient initialised on the new base url \"\"\" return self [ item ] __getitem__ ( item ) \u00b6 Allow access to sub resources with a subscription-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api['resource1'].get() # GET https://myapi.local/resource1 resource2 = api['resource2'].get() # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the the new base url Source code in requests_oauth2client/api_client.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def __getitem__ ( self , item : str ) -> ApiClient : \"\"\"Allow access to sub resources with a subscription-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api['resource1'].get() # GET https://myapi.local/resource1 resource2 = api['resource2'].get() # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the the new base url \"\"\" new_base_uri = self . to_absolute_url ( item ) return self . __class__ ( new_base_uri , session = self . session , none_fields = self . none_fields , bool_fields = self . bool_fields , timeout = self . timeout , raise_for_status = self . raise_for_status , ) __init__ ( base_url = None , auth = None , timeout = 60 , raise_for_status = True , none_fields = 'exclude' , bool_fields = ( 'true' , 'false' ), session = None , ** kwargs ) \u00b6 Initialize an ApiClient , with an optional root url. base_url will serve as root for relative urls passed to ApiClient.request() , ApiClient.get() , etc. An HTTPError will be raised everytime an API call returns an error code (>= 400), unless you set raise_for_status to False . Additional parameters passed at init time, including auth will be used to configure the Session . :param base_url: the base api url, that should be root for all the target API endpoints. :param auth: the requests.auth.AuthBase to use as authentication handler. :param timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to None to disable timeout. :param raise_for_status: if True , exceptions will be raised everytime a request returns an error code (>= 400). :param none_fields: if \"exclude\" (default), data or json fields whose values are None are not included in the request. If \"include\", they are included with string value None (this is the default behavior of requests ). If \"empty\", they are included with an empty value (as an empty string). :param bool_fields: a tuple of (true_value, false_value). Fields from data or params with a boolean value ( True or False ) will be serialized to the corresponding value. This can be useful since some APIs expect a 'true' or 'false' value as boolean, and requests serialises True to 'True' and False to 'False' . Set it to None to restore default requests behaviour. :param kwargs: additional kwargs to configure this session. This parameter may be overridden at request time. Source code in requests_oauth2client/api_client.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , base_url : Optional [ str ] = None , auth : Optional [ requests . auth . AuthBase ] = None , timeout : Optional [ int ] = 60 , raise_for_status : bool = True , none_fields : Literal [ \"include\" , \"exclude\" , \"empty\" ] = \"exclude\" , bool_fields : Optional [ Tuple [ Any , Any ]] = ( \"true\" , \"false\" ), session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an `ApiClient`, with an optional root url. `base_url` will serve as root for relative urls passed to [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request], [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc. An `HTTPError` will be raised everytime an API call returns an error code (>= 400), unless you set `raise_for_status` to `False`. Additional parameters passed at init time, including `auth` will be used to configure the [Session][requests.Session]. :param base_url: the base api url, that should be root for all the target API endpoints. :param auth: the [requests.auth.AuthBase][] to use as authentication handler. :param timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to `None` to disable timeout. :param raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (>= 400). :param none_fields: if `\"exclude\"` (default), data or json fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with a boolean value (`True` or `False`) will be serialized to the corresponding value. This can be useful since some APIs expect a `'true'` or `'false'` value as boolean, and requests serialises `True` to `'True'` and `False` to `'False'`. Set it to `None` to restore default requests behaviour. :param kwargs: additional kwargs to configure this session. This parameter may be overridden at request time. \"\"\" super ( ApiClient , self ) . __init__ () self . base_url = base_url self . raise_for_status = raise_for_status self . none_fields = none_fields self . bool_fields = bool_fields if bool_fields is not None else ( True , False ) self . timeout = timeout self . session = session or requests . Session () self . session . auth = auth for key , val in kwargs . items (): setattr ( self . session , key , val ) delete ( url = None , raise_for_status = None , ** kwargs ) \u00b6 Send a DELETE request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def delete ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a DELETE request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"DELETE\" , url , raise_for_status = raise_for_status , ** kwargs ) get ( url = None , raise_for_status = None , ** kwargs ) \u00b6 Send a GET request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param none_data_fields: if \"exclude\" (default), data fields whose values are None are not included in the request. If \"include\", they are included with string value None (this is the default behavior of requests ). If \"empty\", they are included with an empty value (as an empty string). :param kwargs: Optional arguments that request() takes. :return: a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. and an error response is returned. Source code in requests_oauth2client/api_client.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def get ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a GET request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param none_data_fields: if `\"exclude\"` (default), data fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param kwargs: Optional arguments that [request()][requests.request] takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. and an error response is returned. \"\"\" return self . request ( \"GET\" , url , raise_for_status = raise_for_status , ** kwargs ) patch ( url = None , raise_for_status = None , ** kwargs ) \u00b6 Send a PATCH request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def patch ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PATCH request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PATCH\" , url , raise_for_status = raise_for_status , ** kwargs ) post ( url = None , raise_for_status = None , ** kwargs ) \u00b6 Send a POST request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def post ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a POST request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"POST\" , url , raise_for_status = raise_for_status , ** kwargs ) put ( url = None , raise_for_status = None , ** kwargs ) \u00b6 Send a PUT request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def put ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PUT request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PUT\" , url , raise_for_status = raise_for_status , ** kwargs ) request ( method , url = None , params = None , data = None , headers = None , cookies = None , files = None , auth = None , timeout = None , allow_redirects = True , proxies = None , hooks = None , stream = None , verify = None , cert = None , json = None , raise_for_status = None , none_fields = None , bool_fields = None ) \u00b6 Overridden request method that can handle a relative path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url. :param raise_for_status: like the parameter of the same name from ApiClient.__init__ , but this will be applied for this request only. :param none_fields: like the parameter of the same name from ApiClient.__init__ , but this will be applied for this request only. :param bool_fields: like the parameter of the same name from ApiClient.__init__ , but this will be applied for this request only. :return: a requests.Response as returned by requests Source code in requests_oauth2client/api_client.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def request ( # noqa: C901 self , method : str , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , params : Union [ None , bytes , MutableMapping [ str , str ]] = None , data : Union [ None , str , bytes , Mapping [ str , Any ], Iterable [ Tuple [ str , Optional [ str ]]], IO [ Any ], ] = None , headers : Optional [ MutableMapping [ str , str ]] = None , cookies : Union [ None , RequestsCookieJar , MutableMapping [ str , str ]] = None , files : Optional [ MutableMapping [ str , IO [ Any ]]] = None , auth : Union [ None , Tuple [ str , str ], requests . auth . AuthBase , Callable [[ requests . PreparedRequest ], requests . PreparedRequest ], ] = None , timeout : Union [ None , float , Tuple [ float , float ], Tuple [ float , None ]] = None , allow_redirects : Optional [ bool ] = True , proxies : Optional [ MutableMapping [ str , str ]] = None , hooks : Optional [ MutableMapping [ str , Union [ Iterable [ Callable [[ requests . Response ], Any ]], Callable [[ requests . Response ], Any ], ], ] ] = None , stream : Optional [ bool ] = None , verify : Optional [ Union [ str , bool ]] = None , cert : Optional [ Union [ str , Tuple [ str , str ]]] = None , json : Optional [ Mapping [ str , Any ]] = None , raise_for_status : Optional [ bool ] = None , none_fields : Optional [ Literal [ \"include\" , \"exclude\" , \"empty\" ]] = None , bool_fields : Optional [ Tuple [ Any , Any ]] = None , ) -> requests . Response : \"\"\" Overridden `request` method that can handle a relative path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url. :param raise_for_status: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param none_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param bool_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :return: a [requests.Response][] as returned by requests \"\"\" url = self . to_absolute_url ( url ) if none_fields is None : none_fields = self . none_fields if none_fields == \"exclude\" : if isinstance ( data , Mapping ): data = { key : val for key , val in data . items () if val is not None } if isinstance ( json , Mapping ): json = { key : val for key , val in json . items () if val is not None } elif none_fields == \"empty\" : if isinstance ( data , Mapping ): data = { key : val if val is not None else \"\" for key , val in data . items () } if isinstance ( json , Mapping ): json = { key : val if val is not None else \"\" for key , val in json . items () } if bool_fields is None : bool_fields = self . bool_fields if bool_fields : try : true_value , false_value = bool_fields except ValueError : raise ValueError ( \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\" ) if isinstance ( data , MutableMapping ): for key , val in data . items (): if val is True : data [ key ] = true_value elif val is False : data [ key ] = false_value if isinstance ( params , MutableMapping ): for key , val in params . items (): if val is True : params [ key ] = true_value elif val is False : params [ key ] = false_value timeout = timeout or self . timeout response = self . session . request ( method , url , params = params , data = data , headers = headers , cookies = cookies , files = files , auth = auth , timeout = timeout , allow_redirects = allow_redirects , proxies = proxies , hooks = hooks , stream = stream , verify = verify , cert = cert , json = json , ) if raise_for_status is None : raise_for_status = self . raise_for_status if raise_for_status : response . raise_for_status () return response to_absolute_url ( url = None ) \u00b6 Given an 'url', that can be relative or absolute, return the matching absolute url, based on the base url. :param url: a (possibly relative) url :return: the matching absolute url Source code in requests_oauth2client/api_client.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def to_absolute_url ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None ) -> str : \"\"\"Given an 'url', that can be relative or absolute, return the matching absolute url, based on the base url. :param url: a (possibly relative) url :return: the matching absolute url \"\"\" if self . base_url : if url is not None : if not isinstance ( url , ( str , bytes )): try : url = \"/\" . join ( [ part . decode () if isinstance ( part , bytes ) else str ( part ) for part in url if part ] ) except TypeError : raise TypeError ( \"Unexpected url type, please pass a relative path as string or bytes, \" \"or an iterable of string-able objects\" , type ( url ), ) if isinstance ( url , bytes ): url = url . decode () url = urljoin ( self . base_url + \"/\" , url . lstrip ( \"/\" )) else : url = self . base_url if url is None or not isinstance ( url , str ): raise ValueError ( \"Unable to determine an absolute url.\" ) return url auth \u00b6 This module contains requests Auth Handlers that implement OAuth 2.0. BearerAuth \u00b6 Bases: requests . auth . AuthBase A requests AuthBase that includes a Bearer Access Token in API calls, as defined in RFC6750$2.1 . As a prerequisite to using this AuthBase, you have to obtain an access token manually. If you want to abstract that, see others Auth Handlers in this module that will automatically obtain access tokens from an OAuth 2.x server. Usage: 1 2 auth = BearerAuth ( \"my_access_token\" ) resp = requests . get ( \"https://my.api.local/resource\" , auth = auth ) The HTTP request will look like: 1 2 3 GET /resource HTTP/1.1 Host: my.api.local Authorization: Bearer my_access_token Source code in requests_oauth2client/auth.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class BearerAuth ( requests . auth . AuthBase ): \"\"\" A [requests AuthBase][requests.auth.AuthBase] that includes a Bearer Access Token in API calls, as defined in [RFC6750$2.1](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1). As a prerequisite to using this AuthBase, you have to obtain an access token manually. If you want to abstract that, see others Auth Handlers in this module that will automatically obtain access tokens from an OAuth 2.x server. Usage: ```python auth = BearerAuth(\"my_access_token\") resp = requests.get(\"https://my.api.local/resource\", auth=auth) ``` The HTTP request will look like: ``` GET /resource HTTP/1.1 Host: my.api.local Authorization: Bearer my_access_token ``` \"\"\" def __init__ ( self , token : Optional [ Union [ str , BearerToken ]] = None ) -> None : \"\"\" Initialize a BearerAuth with an existing Access Token. :param token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string to use as token for this Auth Handler. If `None`, this Auth Handler is a no op. \"\"\" self . token = token # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed @property def token ( self ) -> Optional [ BearerToken ]: \"\"\" Return the token that is used for authorization against the API. :return: the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this AuthHandler. \"\"\" return self . _token @token . setter def token ( self , token : Union [ str , BearerToken ]) -> None : \"\"\" Change the access token used with this AuthHandler. Accepts a [BearerToken][requests_oauth2client.tokens.BearerToken] or an access token as `str`. :param token: an access token to use for this Auth Handler \"\"\" if token is not None and not isinstance ( token , BearerToken ): token = BearerToken ( token ) self . _token = token def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding the `Authorization: Bearer <token>` header in the request. If the configuerd token is a instance of BearerToken with an expires_at attribute, raises [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access token is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" if self . token is None : return request if self . token . is_expired (): raise ExpiredAccessToken ( self . token ) request . headers [ \"Authorization\" ] = self . token . authorization_header () return request __call__ ( request ) \u00b6 Implement the logic of adding the Authorization: Bearer <token> header in the request. If the configuerd token is a instance of BearerToken with an expires_at attribute, raises ExpiredAccessToken once the access token is expired. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding the `Authorization: Bearer <token>` header in the request. If the configuerd token is a instance of BearerToken with an expires_at attribute, raises [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access token is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" if self . token is None : return request if self . token . is_expired (): raise ExpiredAccessToken ( self . token ) request . headers [ \"Authorization\" ] = self . token . authorization_header () return request __init__ ( token = None ) \u00b6 Initialize a BearerAuth with an existing Access Token. :param token: a BearerToken or a string to use as token for this Auth Handler. If None , this Auth Handler is a no op. Source code in requests_oauth2client/auth.py 35 36 37 38 39 40 41 def __init__ ( self , token : Optional [ Union [ str , BearerToken ]] = None ) -> None : \"\"\" Initialize a BearerAuth with an existing Access Token. :param token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string to use as token for this Auth Handler. If `None`, this Auth Handler is a no op. \"\"\" self . token = token # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed token () writable property \u00b6 Return the token that is used for authorization against the API. :return: the configured BearerToken used with this AuthHandler. Source code in requests_oauth2client/auth.py 43 44 45 46 47 48 49 50 @property def token ( self ) -> Optional [ BearerToken ]: \"\"\" Return the token that is used for authorization against the API. :return: the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this AuthHandler. \"\"\" return self . _token OAuth2AccessTokenAuth \u00b6 Bases: BearerAuth A Requests Authentication handler using a Bearer access token, and can automatically refreshes it when expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken( access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\") # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ```` Source code in requests_oauth2client/auth.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class OAuth2AccessTokenAuth ( BearerAuth ): \"\"\" A Requests Authentication handler using a Bearer access token, and can automatically refreshes it when expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken( access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\") # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ```` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , token : Optional [ Union [ str , BearerToken ]] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2AccessTokenAuth`, with an initial token. Token can be a simple `str` containing a raw access token value, or a [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens. :param token: a access token that has been previously obtained :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( token ) self . client = client self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding access token in requests, and refreshing that token once it is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if ( token is not None and token . is_expired () and token . refresh_token and self . client is not None ): self . token = self . client . refresh_token ( refresh_token = token . refresh_token , ** self . token_kwargs ) return super () . __call__ ( request ) __call__ ( request ) \u00b6 Implement the logic of adding access token in requests, and refreshing that token once it is expired. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding access token in requests, and refreshing that token once it is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if ( token is not None and token . is_expired () and token . refresh_token and self . client is not None ): self . token = self . client . refresh_token ( refresh_token = token . refresh_token , ** self . token_kwargs ) return super () . __call__ ( request ) __init__ ( client , token = None , ** token_kwargs ) \u00b6 Initialize an OAuth2AccessTokenAuth , with an initial token. Token can be a simple str containing a raw access token value, or a BearerToken that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired. :param client: the OAuth2Client to use to refresh tokens. :param token: a access token that has been previously obtained :param token_kwargs: additional kwargs to pass to the token endpoint Source code in requests_oauth2client/auth.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def __init__ ( self , client : \"OAuth2Client\" , token : Optional [ Union [ str , BearerToken ]] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2AccessTokenAuth`, with an initial token. Token can be a simple `str` containing a raw access token value, or a [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens. :param token: a access token that has been previously obtained :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( token ) self . client = client self . token_kwargs = token_kwargs OAuth2AuthorizationCodeAuth \u00b6 Bases: OAuth2AccessTokenAuth A Requests Auth handler that exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\" oauth2ac_auth = OAuth2AuthorizationCodeAuth(client, code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` Source code in requests_oauth2client/auth.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class OAuth2AuthorizationCodeAuth ( OAuth2AccessTokenAuth ): \"\"\" A [Requests Auth handler][requests.auth.AuthBase] that exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\" oauth2ac_auth = OAuth2AuthorizationCodeAuth(client, code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , code : str , ** token_kwargs : Any ) -> None : \"\"\" Initialize an `OAuth2AuthorizationCodeAuth` with a given Authorization Code. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param code: an Authorization Code that has been manually obtained from the AS. :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . code : Optional [ str ] = code self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Authorization Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): if self . code : # pragma: no branch self . token = self . client . authorization_code ( code = self . code , ** self . token_kwargs ) self . code = None return super () . __call__ ( request ) __call__ ( request ) \u00b6 Implement the logic of exchanging the Authorization Code for an access token and adding it in the request. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Authorization Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): if self . code : # pragma: no branch self . token = self . client . authorization_code ( code = self . code , ** self . token_kwargs ) self . code = None return super () . __call__ ( request ) __init__ ( client , code , ** token_kwargs ) \u00b6 Initialize an OAuth2AuthorizationCodeAuth with a given Authorization Code. :param client: the OAuth2Client to use to obtain Access Tokens. :param code: an Authorization Code that has been manually obtained from the AS. :param token_kwargs: additional kwargs to pass to the token endpoint Source code in requests_oauth2client/auth.py 191 192 193 194 195 196 197 198 199 200 201 def __init__ ( self , client : \"OAuth2Client\" , code : str , ** token_kwargs : Any ) -> None : \"\"\" Initialize an `OAuth2AuthorizationCodeAuth` with a given Authorization Code. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param code: an Authorization Code that has been manually obtained from the AS. :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . code : Optional [ str ] = code self . token_kwargs = token_kwargs OAuth2ClientCredentialsAuth \u00b6 Bases: BearerAuth A requests AuthBase that automatically gets access tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, then will get a new one once the current one is expired. Usage: 1 2 3 4 5 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , auth = ( \"client_id\" , \"client_secret\" ) ) oauth2cc = OAuth2ClientCredentialsAuth ( client , scope = \"my_scope\" ) resp = requests . post ( \"https://my.api.local/resource\" , auth = oauth2cc ) Source code in requests_oauth2client/auth.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class OAuth2ClientCredentialsAuth ( BearerAuth ): \"\"\" A [requests AuthBase][requests.auth.AuthBase] that automatically gets access tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, then will get a new one once the current one is expired. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\") ) oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc) ``` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , ** token_kwargs : Any ): \"\"\" Initialize an `OAuth2ClientCredentialsAuth`. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc. \"\"\" super () . __init__ ( None ) self . client = client self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of obtaining a token using the Client Credentials Grant, and including that token in requests. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): self . token = self . client . client_credentials ( ** self . token_kwargs ) return super () . __call__ ( request ) __call__ ( request ) \u00b6 Implement the logic of obtaining a token using the Client Credentials Grant, and including that token in requests. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 108 109 110 111 112 113 114 115 116 117 118 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of obtaining a token using the Client Credentials Grant, and including that token in requests. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): self . token = self . client . client_credentials ( ** self . token_kwargs ) return super () . __call__ ( request ) __init__ ( client , ** token_kwargs ) \u00b6 Initialize an OAuth2ClientCredentialsAuth . :param client: the OAuth2Client to use to obtain Access Tokens. :param token_kwargs: extra kw parameters to pass to the Token Endpoint. May include scope , resource , etc. Source code in requests_oauth2client/auth.py 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , client : \"OAuth2Client\" , ** token_kwargs : Any ): \"\"\" Initialize an `OAuth2ClientCredentialsAuth`. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc. \"\"\" super () . __init__ ( None ) self . client = client self . token_kwargs = token_kwargs OAuth2DeviceCodeAuth \u00b6 Bases: OAuth2AccessTokenAuth A Requests Auth handler that exchange a Device Code for an access token, then automatically refresh it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = \"my_device_code\" oauth2ac_auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` Source code in requests_oauth2client/auth.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class OAuth2DeviceCodeAuth ( OAuth2AccessTokenAuth ): \"\"\" A [Requests Auth handler][requests.auth.AuthBase] that exchange a Device Code for an access token, then automatically refresh it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = \"my_device_code\" oauth2ac_auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , device_code : str , interval : int = 5 , expires_in : int = 360 , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2DeviceCodeAuth`. It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param device_code: a Device Code obtained from the AS. :param interval: the interval to use to pool the Token Endpoint, in seconds. :param expires_in: the lifetime of the token, in seconds :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . device_code : Optional [ str ] = device_code self . interval = interval self . expires_in = expires_in self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Device Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" from .device_authorization import DeviceAuthorizationPoolingJob token = self . token if token is None or token . is_expired (): if self . device_code : # pragma: no branch pooling_job = DeviceAuthorizationPoolingJob ( client = self . client , device_code = self . device_code , interval = self . interval , ) while self . token is None : self . token = pooling_job () self . device_code = None return super () . __call__ ( request ) __call__ ( request ) \u00b6 Implement the logic of exchanging the Device Code for an access token and adding it in the request. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Device Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" from .device_authorization import DeviceAuthorizationPoolingJob token = self . token if token is None or token . is_expired (): if self . device_code : # pragma: no branch pooling_job = DeviceAuthorizationPoolingJob ( client = self . client , device_code = self . device_code , interval = self . interval , ) while self . token is None : self . token = pooling_job () self . device_code = None return super () . __call__ ( request ) __init__ ( client , device_code , interval = 5 , expires_in = 360 , ** token_kwargs ) \u00b6 Initialize an OAuth2DeviceCodeAuth . It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent. :param client: the OAuth2Client to use to obtain Access Tokens. :param device_code: a Device Code obtained from the AS. :param interval: the interval to use to pool the Token Endpoint, in seconds. :param expires_in: the lifetime of the token, in seconds :param token_kwargs: additional kwargs to pass to the token endpoint Source code in requests_oauth2client/auth.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def __init__ ( self , client : \"OAuth2Client\" , device_code : str , interval : int = 5 , expires_in : int = 360 , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2DeviceCodeAuth`. It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param device_code: a Device Code obtained from the AS. :param interval: the interval to use to pool the Token Endpoint, in seconds. :param expires_in: the lifetime of the token, in seconds :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . device_code : Optional [ str ] = device_code self . interval = interval self . expires_in = expires_in self . token_kwargs = token_kwargs authorization_request \u00b6 This module contains classes and utilities related to Authorization Requests and Responses. AuthorizationRequest \u00b6 Represents an Authorization Request. This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response. Source code in requests_oauth2client/authorization_request.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 class AuthorizationRequest : \"\"\" Represents an Authorization Request. This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response. \"\"\" exception_classes : Dict [ str , Type [ Exception ]] = { \"interaction_required\" : InteractionRequired , \"login_required\" : LoginRequired , \"session_selection_required\" : SessionSelectionRequired , \"consent_required\" : ConsentRequired , } def __init__ ( self , authorization_endpoint : str , client_id : str , redirect_uri : Optional [ str ], scope : Union [ None , str , Iterable [ str ]], response_type : str = \"code\" , state : Union [ str , bool , None ] = True , nonce : Union [ str , bool , None ] = True , code_verifier : Optional [ str ] = None , code_challenge_method : Optional [ str ] = \"S256\" , issuer : Union [ str , bool , None ] = None , ** kwargs : Any , ) -> None : \"\"\" Create an `AuthorizationRequest`. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: * `state`: if True (default), a random state parameter will be generated for you. You may pass your own state as `str`, or set it to `None` so that the state parameter will not be included in the request. You may access that state in the `state` attribute from this request. * `nonce`: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the `nonce` attribute from this request. * `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`, a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated, and the `code_challenge` will be included in the request. You may pass your own `code_verifier` as a `str` parameter, in which case the appropriate `code_challenge` will be included in the request, according to the `code_challenge_method`. :param authorization_endpoint: the uri for the authorization endpoint. :param client_id: the client_id to include in the request. :param redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization Request. :param scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`. :param response_type: the response type to include in the request. :param state: the state to include in the request, or `True` to autogenerate one (default). :param nonce: the nonce to include in the request, or `True` to autogenerate one (default). :param code_verifier: the state to include in the request, or `True` to autogenerate one (default). :param code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`. :param issuer: Issuer Identifier value from the OAuth/OIDC Server, if known. Set it to `False` if the AS doesn't support Server Issuer Identification. :param kwargs: extra parameters to include in the request, as-is. \"\"\" if state is True : state = secrets . token_urlsafe ( 32 ) elif state is False : state = None if scope is not None and isinstance ( scope , str ): scope = scope . split ( \" \" ) if nonce is True and scope is not None and \"openid\" in scope : nonce = secrets . token_urlsafe ( 32 ) elif nonce is False : nonce = None if scope is not None and not isinstance ( scope , str ): scope = \" \" . join ( str ( s ) for s in scope ) if \"code_challenge\" in kwargs : raise ValueError ( \"A code_challenge must not be passed as parameter. \" \"Pass the code_verifier instead, and the appropriate code_challenge \" \"will automatically be derived from it and included in the request, \" \"based on code_challenge_method.\" ) if not code_challenge_method : code_verifier = code_challenge = code_challenge_method = None else : if not code_verifier : code_verifier = PkceUtils . generate_code_verifier () code_challenge = PkceUtils . derive_challenge ( code_verifier , code_challenge_method ) self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . redirect_uri = redirect_uri self . response_type = response_type self . scope = scope self . state = state self . nonce = nonce self . code_verifier = code_verifier self . code_challenge = code_challenge self . code_challenge_method = code_challenge_method self . kwargs = kwargs self . issuer = issuer self . args = dict ( client_id = client_id , redirect_uri = redirect_uri , response_type = response_type , scope = scope , state = state , nonce = nonce , code_challenge = code_challenge , code_challenge_method = code_challenge_method , ** kwargs , ) def sign_request_jwt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> Jwt : \"\"\" Sign the `request` object that matches this Authorization Request parameters. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: a :class:`Jwt` that contains the signed request object. \"\"\" return Jwt . sign ( claims = { key : val for key , val in self . args . items () if val is not None }, jwk = jwk , alg = alg , ) def sign ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> \"AuthorizationRequest\" : \"\"\" Sign the current Authorization Request. This replaces all parameters with a signed `request` JWT. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: the signed Authorization Request \"\"\" request_jwt = self . sign_request_jwt ( jwk , alg ) self . args = { \"request\" : str ( request_jwt )} return self def sign_and_encrypt_request_jwt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> Jwt : \"\"\" Sign and encrypt the `request` object that matches the current Authorization Request parameters. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: the signed and encrypted request object, as a :class:`Jwt` \"\"\" return Jwt . sign_and_encrypt ( claims = { key : val for key , val in self . args . items () if val is not None }, sign_jwk = sign_jwk , sign_alg = sign_alg , enc_jwk = enc_jwk , enc_alg = enc_alg , enc = enc , ) def sign_and_encrypt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> \"AuthorizationRequest\" : \"\"\" Sign and encrypt the current Authorization Request. This replaces all parameters with a matching `request` object. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: \"\"\" request_jwt = self . sign_and_encrypt_request_jwt ( sign_jwk = sign_jwk , enc_jwk = enc_jwk , sign_alg = sign_alg , enc_alg = enc_alg , enc = enc , ) self . args = { \"request\" : str ( request_jwt )} return self def validate_callback ( self , response : str ) -> AuthorizationResponse : \"\"\" Validate a given Authorization Response URI against this Authorization Request, and return an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse]. This includes matching the `state` parameter, checking for returned errors, and extracting the returned `code` and other parameters. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: the extracted code, if the :raises MismatchingState: if the response `state` does not match the expected value. :raises OAuth2Error: if the response includes an error. :raises MissingAuthCode: if the response does not contain a `code`. \"\"\" try : response_url = furl ( response ) except ValueError : return self . on_response_error ( response ) # validate 'iss' according to https://www.ietf.org/archive/id/draft-ietf-oauth-iss-auth-resp-05.html expected_issuer = self . issuer if expected_issuer is not None : received_issuer = response_url . args . get ( \"iss\" ) if ( expected_issuer is False and received_issuer is not None ) or ( expected_issuer and received_issuer != expected_issuer ): raise MismatchingIssuer ( expected_issuer , received_issuer ) requested_state = self . state if requested_state : received_state = response_url . args . get ( \"state\" ) if requested_state != received_state : raise MismatchingState ( requested_state , received_state ) error = response_url . args . get ( \"error\" ) if error : return self . on_response_error ( response ) code : str = response_url . args . get ( \"code\" ) if code is None : raise MissingAuthCode () return AuthorizationResponse ( code_verifier = self . code_verifier , redirect_uri = self . redirect_uri , ** response_url . args , ) def on_response_error ( self , response : str ) -> AuthorizationResponse : \"\"\" Triggered by [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback] if the response uri contains an error. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: may return a default code that will be returned by `validate_callback`. But this method will most likely raise exceptions instead. \"\"\" response_url = furl ( response ) error = response_url . args . get ( \"error\" ) error_description = response_url . args . get ( \"error_description\" ) error_uri = response_url . args . get ( \"error_uri\" ) exception_class = self . exception_classes . get ( error , AuthorizationResponseError ) raise exception_class ( error , error_description , error_uri ) @property def uri ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. You may also use `repr()` or `str()` on an AuthorizationRequest to obtain the same uri. Authorization requests typically look like: ``` https://myas.local/authorize?client_id=<client_id>&response_type=code&scope=openid&redirect_uri=<redirect_uri> ``` Unless they have been signed, and optionally encrypted, into a `request` object, then they look like: ``` https://myas.local/authorize?request=<request> ``` :return: the Authorization Request URI. \"\"\" return str ( furl ( self . authorization_endpoint , args = { key : value for key , value in self . args . items () if value is not None }, ) . url ) def __repr__ ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri def __eq__ ( self , other : Any ) -> bool : \"\"\" Check if this Authorization Request is the same as another one. :param other: :return: \"\"\" if isinstance ( other , AuthorizationRequest ): return ( self . authorization_endpoint == other . authorization_endpoint and self . args == other . kwargs and self . issuer == other . issuer ) elif isinstance ( other , str ): return self . uri == other return super () . __eq__ ( other ) __eq__ ( other ) \u00b6 Check if this Authorization Request is the same as another one. :param other: :return: Source code in requests_oauth2client/authorization_request.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def __eq__ ( self , other : Any ) -> bool : \"\"\" Check if this Authorization Request is the same as another one. :param other: :return: \"\"\" if isinstance ( other , AuthorizationRequest ): return ( self . authorization_endpoint == other . authorization_endpoint and self . args == other . kwargs and self . issuer == other . issuer ) elif isinstance ( other , str ): return self . uri == other return super () . __eq__ ( other ) __init__ ( authorization_endpoint , client_id , redirect_uri , scope , response_type = 'code' , state = True , nonce = True , code_verifier = None , code_challenge_method = 'S256' , issuer = None , ** kwargs ) \u00b6 Create an AuthorizationRequest . All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: state : if True (default), a random state parameter will be generated for you. You may pass your own state as str , or set it to None so that the state parameter will not be included in the request. You may access that state in the state attribute from this request. nonce : if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the nonce attribute from this request. code_verifier : if None , and code_challenge_method is 'S256' or 'plain' , a valid code_challenge and code_verifier for PKCE will be automatically generated, and the code_challenge will be included in the request. You may pass your own code_verifier as a str parameter, in which case the appropriate code_challenge will be included in the request, according to the code_challenge_method . :param authorization_endpoint: the uri for the authorization endpoint. :param client_id: the client_id to include in the request. :param redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass None if you don't need any redirect_uri in the Authorization Request. :param scope: the scope to include in the request, as an iterable of str , or a single space-separated str . :param response_type: the response type to include in the request. :param state: the state to include in the request, or True to autogenerate one (default). :param nonce: the nonce to include in the request, or True to autogenerate one (default). :param code_verifier: the state to include in the request, or True to autogenerate one (default). :param code_challenge_method: the method to use to derive the code_challenge from the code_verifier . :param issuer: Issuer Identifier value from the OAuth/OIDC Server, if known. Set it to False if the AS doesn't support Server Issuer Identification. :param kwargs: extra parameters to include in the request, as-is. Source code in requests_oauth2client/authorization_request.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __init__ ( self , authorization_endpoint : str , client_id : str , redirect_uri : Optional [ str ], scope : Union [ None , str , Iterable [ str ]], response_type : str = \"code\" , state : Union [ str , bool , None ] = True , nonce : Union [ str , bool , None ] = True , code_verifier : Optional [ str ] = None , code_challenge_method : Optional [ str ] = \"S256\" , issuer : Union [ str , bool , None ] = None , ** kwargs : Any , ) -> None : \"\"\" Create an `AuthorizationRequest`. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: * `state`: if True (default), a random state parameter will be generated for you. You may pass your own state as `str`, or set it to `None` so that the state parameter will not be included in the request. You may access that state in the `state` attribute from this request. * `nonce`: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the `nonce` attribute from this request. * `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`, a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated, and the `code_challenge` will be included in the request. You may pass your own `code_verifier` as a `str` parameter, in which case the appropriate `code_challenge` will be included in the request, according to the `code_challenge_method`. :param authorization_endpoint: the uri for the authorization endpoint. :param client_id: the client_id to include in the request. :param redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization Request. :param scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`. :param response_type: the response type to include in the request. :param state: the state to include in the request, or `True` to autogenerate one (default). :param nonce: the nonce to include in the request, or `True` to autogenerate one (default). :param code_verifier: the state to include in the request, or `True` to autogenerate one (default). :param code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`. :param issuer: Issuer Identifier value from the OAuth/OIDC Server, if known. Set it to `False` if the AS doesn't support Server Issuer Identification. :param kwargs: extra parameters to include in the request, as-is. \"\"\" if state is True : state = secrets . token_urlsafe ( 32 ) elif state is False : state = None if scope is not None and isinstance ( scope , str ): scope = scope . split ( \" \" ) if nonce is True and scope is not None and \"openid\" in scope : nonce = secrets . token_urlsafe ( 32 ) elif nonce is False : nonce = None if scope is not None and not isinstance ( scope , str ): scope = \" \" . join ( str ( s ) for s in scope ) if \"code_challenge\" in kwargs : raise ValueError ( \"A code_challenge must not be passed as parameter. \" \"Pass the code_verifier instead, and the appropriate code_challenge \" \"will automatically be derived from it and included in the request, \" \"based on code_challenge_method.\" ) if not code_challenge_method : code_verifier = code_challenge = code_challenge_method = None else : if not code_verifier : code_verifier = PkceUtils . generate_code_verifier () code_challenge = PkceUtils . derive_challenge ( code_verifier , code_challenge_method ) self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . redirect_uri = redirect_uri self . response_type = response_type self . scope = scope self . state = state self . nonce = nonce self . code_verifier = code_verifier self . code_challenge = code_challenge self . code_challenge_method = code_challenge_method self . kwargs = kwargs self . issuer = issuer self . args = dict ( client_id = client_id , redirect_uri = redirect_uri , response_type = response_type , scope = scope , state = state , nonce = nonce , code_challenge = code_challenge , code_challenge_method = code_challenge_method , ** kwargs , ) __repr__ () \u00b6 Return the Authorization Request URI, as a str . :return: the Authorization Request URI. Source code in requests_oauth2client/authorization_request.py 457 458 459 460 461 462 463 def __repr__ ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri on_response_error ( response ) \u00b6 Triggered by validate_callback() if the response uri contains an error. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: may return a default code that will be returned by validate_callback . But this method will most likely raise exceptions instead. Source code in requests_oauth2client/authorization_request.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def on_response_error ( self , response : str ) -> AuthorizationResponse : \"\"\" Triggered by [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback] if the response uri contains an error. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: may return a default code that will be returned by `validate_callback`. But this method will most likely raise exceptions instead. \"\"\" response_url = furl ( response ) error = response_url . args . get ( \"error\" ) error_description = response_url . args . get ( \"error_description\" ) error_uri = response_url . args . get ( \"error_uri\" ) exception_class = self . exception_classes . get ( error , AuthorizationResponseError ) raise exception_class ( error , error_description , error_uri ) sign ( jwk , alg = None ) \u00b6 Sign the current Authorization Request. This replaces all parameters with a signed request JWT. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :return: the signed Authorization Request Source code in requests_oauth2client/authorization_request.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def sign ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> \"AuthorizationRequest\" : \"\"\" Sign the current Authorization Request. This replaces all parameters with a signed `request` JWT. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: the signed Authorization Request \"\"\" request_jwt = self . sign_request_jwt ( jwk , alg ) self . args = { \"request\" : str ( request_jwt )} return self sign_and_encrypt ( sign_jwk , enc_jwk , sign_alg = None , enc_alg = None , enc = None ) \u00b6 Sign and encrypt the current Authorization Request. This replaces all parameters with a matching request object. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :param enc_alg: the alg to use to encrypt the request, if the passed jwk has no alg parameter. :param enc: the encoding to use to encrypt the request, if the passed jwk has no enc parameter. :return: Source code in requests_oauth2client/authorization_request.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def sign_and_encrypt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> \"AuthorizationRequest\" : \"\"\" Sign and encrypt the current Authorization Request. This replaces all parameters with a matching `request` object. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: \"\"\" request_jwt = self . sign_and_encrypt_request_jwt ( sign_jwk = sign_jwk , enc_jwk = enc_jwk , sign_alg = sign_alg , enc_alg = enc_alg , enc = enc , ) self . args = { \"request\" : str ( request_jwt )} return self sign_and_encrypt_request_jwt ( sign_jwk , enc_jwk , sign_alg = None , enc_alg = None , enc = None ) \u00b6 Sign and encrypt the request object that matches the current Authorization Request parameters. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :param enc_alg: the alg to use to encrypt the request, if the passed jwk has no alg parameter. :param enc: the encoding to use to encrypt the request, if the passed jwk has no enc parameter. :return: the signed and encrypted request object, as a :class: Jwt Source code in requests_oauth2client/authorization_request.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def sign_and_encrypt_request_jwt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> Jwt : \"\"\" Sign and encrypt the `request` object that matches the current Authorization Request parameters. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: the signed and encrypted request object, as a :class:`Jwt` \"\"\" return Jwt . sign_and_encrypt ( claims = { key : val for key , val in self . args . items () if val is not None }, sign_jwk = sign_jwk , sign_alg = sign_alg , enc_jwk = enc_jwk , enc_alg = enc_alg , enc = enc , ) sign_request_jwt ( jwk , alg = None ) \u00b6 Sign the request object that matches this Authorization Request parameters. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :return: a :class: Jwt that contains the signed request object. Source code in requests_oauth2client/authorization_request.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def sign_request_jwt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> Jwt : \"\"\" Sign the `request` object that matches this Authorization Request parameters. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: a :class:`Jwt` that contains the signed request object. \"\"\" return Jwt . sign ( claims = { key : val for key , val in self . args . items () if val is not None }, jwk = jwk , alg = alg , ) uri () property \u00b6 Return the Authorization Request URI, as a str . You may also use repr() or str() on an AuthorizationRequest to obtain the same uri. Authorization requests typically look like: 1 https://myas.local/authorize?client_id=<client_id>&response_type=code&scope=openid&redirect_uri=<redirect_uri> Unless they have been signed, and optionally encrypted, into a request object, then they look like: 1 https://myas.local/authorize?request=<request> :return: the Authorization Request URI. Source code in requests_oauth2client/authorization_request.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 @property def uri ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. You may also use `repr()` or `str()` on an AuthorizationRequest to obtain the same uri. Authorization requests typically look like: ``` https://myas.local/authorize?client_id=<client_id>&response_type=code&scope=openid&redirect_uri=<redirect_uri> ``` Unless they have been signed, and optionally encrypted, into a `request` object, then they look like: ``` https://myas.local/authorize?request=<request> ``` :return: the Authorization Request URI. \"\"\" return str ( furl ( self . authorization_endpoint , args = { key : value for key , value in self . args . items () if value is not None }, ) . url ) validate_callback ( response ) \u00b6 Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse . This includes matching the state parameter, checking for returned errors, and extracting the returned code and other parameters. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: the extracted code, if the :raises MismatchingState: if the response state does not match the expected value. :raises OAuth2Error: if the response includes an error. :raises MissingAuthCode: if the response does not contain a code . Source code in requests_oauth2client/authorization_request.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def validate_callback ( self , response : str ) -> AuthorizationResponse : \"\"\" Validate a given Authorization Response URI against this Authorization Request, and return an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse]. This includes matching the `state` parameter, checking for returned errors, and extracting the returned `code` and other parameters. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: the extracted code, if the :raises MismatchingState: if the response `state` does not match the expected value. :raises OAuth2Error: if the response includes an error. :raises MissingAuthCode: if the response does not contain a `code`. \"\"\" try : response_url = furl ( response ) except ValueError : return self . on_response_error ( response ) # validate 'iss' according to https://www.ietf.org/archive/id/draft-ietf-oauth-iss-auth-resp-05.html expected_issuer = self . issuer if expected_issuer is not None : received_issuer = response_url . args . get ( \"iss\" ) if ( expected_issuer is False and received_issuer is not None ) or ( expected_issuer and received_issuer != expected_issuer ): raise MismatchingIssuer ( expected_issuer , received_issuer ) requested_state = self . state if requested_state : received_state = response_url . args . get ( \"state\" ) if requested_state != received_state : raise MismatchingState ( requested_state , received_state ) error = response_url . args . get ( \"error\" ) if error : return self . on_response_error ( response ) code : str = response_url . args . get ( \"code\" ) if code is None : raise MissingAuthCode () return AuthorizationResponse ( code_verifier = self . code_verifier , redirect_uri = self . redirect_uri , ** response_url . args , ) AuthorizationResponse \u00b6 Represent a successful Authorization Response. An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to AuthorizationRequest.validate_callback() once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes: - all the parameters that have been returned by the AS, most notably the code , and optional parameters such as state . - the redirect_uri that was used for the Authorization Request - the code_verifier matching the code_challenge that was used for the Authorization Request Usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 request = AuthorizationRequest ( client_id , scope = \"openid\" , redirect_uri = \"http://localhost:54121/callback\" ) webbrowser . open ( request ) # open the authorization request in a browser response_uri = ... # at this point, manage to get the response uri response = request . validate_callback ( response_uri ) # get an AuthorizationResponse at this point client = OAuth2Client ( token_endpoint , auth = ( client_id , client_secret )) client . authorization_code ( response ) # you can pass this response on a call to `OAuth2Client.authorization_code()` Source code in requests_oauth2client/authorization_request.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class AuthorizationResponse : \"\"\" Represent a successful Authorization Response. An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to `AuthorizationRequest.validate_callback()` once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes: - all the parameters that have been returned by the AS, most notably the `code`, and optional parameters such as `state`. - the redirect_uri that was used for the Authorization Request - the code_verifier matching the code_challenge that was used for the Authorization Request Usage: ```python request = AuthorizationRequest( client_id, scope=\"openid\", redirect_uri=\"http://localhost:54121/callback\" ) webbrowser.open(request) # open the authorization request in a browser response_uri = ... # at this point, manage to get the response uri response = request.validate_callback( response_uri ) # get an AuthorizationResponse at this point client = OAuth2Client(token_endpoint, auth=(client_id, client_secret)) client.authorization_code( response ) # you can pass this response on a call to `OAuth2Client.authorization_code()` ``` \"\"\" def __init__ ( self , code : Optional [ str ] = None , redirect_uri : Optional [ str ] = None , code_verifier : Optional [ str ] = None , state : Optional [ str ] = None , ** kwargs : str , ): \"\"\" Initialise an `AuthorizationResponse`. Parameters `redirect_uri` and `code_verifier` must be those from the matching `AuthorizationRequest`. All other parameters including `code` and `state` must be those extracted from the Authorization Response parameters. :param code: the authorization code returned by the AS :param redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest :param code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest :param state: the state returned by the AS :param kwargs: other parameters as returned by the AS \"\"\" self . code = code self . redirect_uri = redirect_uri self . code_verifier = code_verifier self . state = state self . others = kwargs def __getattr__ ( self , item : str ) -> Optional [ str ]: \"\"\" Allow attribute access to additional parameters from this Authorization Response. :param item: the attribute name :return: the attribute value, or None if it isn't part of the returned attributes \"\"\" return self . others . get ( item ) __getattr__ ( item ) \u00b6 Allow attribute access to additional parameters from this Authorization Response. :param item: the attribute name :return: the attribute value, or None if it isn't part of the returned attributes Source code in requests_oauth2client/authorization_request.py 154 155 156 157 158 159 160 161 def __getattr__ ( self , item : str ) -> Optional [ str ]: \"\"\" Allow attribute access to additional parameters from this Authorization Response. :param item: the attribute name :return: the attribute value, or None if it isn't part of the returned attributes \"\"\" return self . others . get ( item ) __init__ ( code = None , redirect_uri = None , code_verifier = None , state = None , ** kwargs ) \u00b6 Initialise an AuthorizationResponse . Parameters redirect_uri and code_verifier must be those from the matching AuthorizationRequest . All other parameters including code and state must be those extracted from the Authorization Response parameters. :param code: the authorization code returned by the AS :param redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest :param code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest :param state: the state returned by the AS :param kwargs: other parameters as returned by the AS Source code in requests_oauth2client/authorization_request.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , code : Optional [ str ] = None , redirect_uri : Optional [ str ] = None , code_verifier : Optional [ str ] = None , state : Optional [ str ] = None , ** kwargs : str , ): \"\"\" Initialise an `AuthorizationResponse`. Parameters `redirect_uri` and `code_verifier` must be those from the matching `AuthorizationRequest`. All other parameters including `code` and `state` must be those extracted from the Authorization Response parameters. :param code: the authorization code returned by the AS :param redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest :param code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest :param state: the state returned by the AS :param kwargs: other parameters as returned by the AS \"\"\" self . code = code self . redirect_uri = redirect_uri self . code_verifier = code_verifier self . state = state self . others = kwargs PkceUtils \u00b6 Contains helper methods for PKCE, as described in RFC7636 . Source code in requests_oauth2client/authorization_request.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class PkceUtils : \"\"\"Contains helper methods for PKCE, as described in [RFC7636](https://tools.ietf.org/html/rfc7636).\"\"\" code_verifier_re = re . compile ( r \"^[a-zA-Z0-9_\\-~.]{43,128}$\" ) \"\"\"A regex that matches valid code verifiers.\"\"\" @classmethod def generate_code_verifier ( cls ) -> str : \"\"\" Generate a valid `code_verifier`. :return: a code_verifier ready to use for PKCE \"\"\" return secrets . token_urlsafe ( 96 ) @classmethod def derive_challenge ( cls , verifier : Union [ str , bytes ], method : str = \"S256\" ) -> str : \"\"\" Derive the `code_challenge` from a given `code_verifier`. :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier \"\"\" if isinstance ( verifier , bytes ): verifier = verifier . decode () if not cls . code_verifier_re . match ( verifier ): raise ValueError ( f \"Invalid code verifier, does not match { cls . code_verifier_re } \" , verifier , ) if method == \"S256\" : return BinaPy ( verifier ) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () elif method == \"plain\" : return verifier else : raise ValueError ( \"Unsupported code_challenge_method\" , method ) @classmethod def generate_code_verifier_and_challenge ( cls , method : str = \"S256\" ) -> Tuple [ str , str ]: \"\"\" Generate a valid `code_verifier` and derive its `code_challenge`. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. \"\"\" verifier = cls . generate_code_verifier () challenge = cls . derive_challenge ( verifier , method ) return verifier , challenge @classmethod def validate_code_verifier ( cls , verifier : str , challenge : str , method : str = \"S256\" ) -> bool : \"\"\" Validate a `code_verifier` against a `code_challenge`. :param verifier: the `code_verifier`, exactly as submitted by the client on token request. :param challenge: the `code_challenge`, exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise \"\"\" return ( cls . code_verifier_re . match ( verifier ) is not None and cls . derive_challenge ( verifier , method ) == challenge ) code_verifier_re = re . compile ( '^[a-zA-Z0-9_ \\\\ -~.]{43,128}$' ) class-attribute \u00b6 A regex that matches valid code verifiers. derive_challenge ( verifier , method = 'S256' ) classmethod \u00b6 Derive the code_challenge from a given code_verifier . :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier Source code in requests_oauth2client/authorization_request.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @classmethod def derive_challenge ( cls , verifier : Union [ str , bytes ], method : str = \"S256\" ) -> str : \"\"\" Derive the `code_challenge` from a given `code_verifier`. :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier \"\"\" if isinstance ( verifier , bytes ): verifier = verifier . decode () if not cls . code_verifier_re . match ( verifier ): raise ValueError ( f \"Invalid code verifier, does not match { cls . code_verifier_re } \" , verifier , ) if method == \"S256\" : return BinaPy ( verifier ) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () elif method == \"plain\" : return verifier else : raise ValueError ( \"Unsupported code_challenge_method\" , method ) generate_code_verifier () classmethod \u00b6 Generate a valid code_verifier . :return: a code_verifier ready to use for PKCE Source code in requests_oauth2client/authorization_request.py 32 33 34 35 36 37 38 39 @classmethod def generate_code_verifier ( cls ) -> str : \"\"\" Generate a valid `code_verifier`. :return: a code_verifier ready to use for PKCE \"\"\" return secrets . token_urlsafe ( 96 ) generate_code_verifier_and_challenge ( method = 'S256' ) classmethod \u00b6 Generate a valid code_verifier and derive its code_challenge . :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. Source code in requests_oauth2client/authorization_request.py 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def generate_code_verifier_and_challenge ( cls , method : str = \"S256\" ) -> Tuple [ str , str ]: \"\"\" Generate a valid `code_verifier` and derive its `code_challenge`. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. \"\"\" verifier = cls . generate_code_verifier () challenge = cls . derive_challenge ( verifier , method ) return verifier , challenge validate_code_verifier ( verifier , challenge , method = 'S256' ) classmethod \u00b6 Validate a code_verifier against a code_challenge . :param verifier: the code_verifier , exactly as submitted by the client on token request. :param challenge: the code_challenge , exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise Source code in requests_oauth2client/authorization_request.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod def validate_code_verifier ( cls , verifier : str , challenge : str , method : str = \"S256\" ) -> bool : \"\"\" Validate a `code_verifier` against a `code_challenge`. :param verifier: the `code_verifier`, exactly as submitted by the client on token request. :param challenge: the `code_challenge`, exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise \"\"\" return ( cls . code_verifier_re . match ( verifier ) is not None and cls . derive_challenge ( verifier , method ) == challenge ) RequestUriParameterAuthorizationRequest \u00b6 Represent an Authorization Request that includes a request object. Source code in requests_oauth2client/authorization_request.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 class RequestUriParameterAuthorizationRequest : \"\"\"Represent an Authorization Request that includes a `request` object.\"\"\" @accepts_expires_in def __init__ ( self , authorization_endpoint : str , client_id : str , request_uri : str , expires_at : Optional [ datetime ] = None , ): \"\"\"Init a RequestUriParameterAuthorizationRequest. It needs an authorization endpoint, a client_id, a request_uri, and an optional expiration date. \"\"\" self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . request_uri = request_uri self . expires_at = expires_at @property def uri ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`.\"\"\" return str ( furl ( self . authorization_endpoint , args = { \"client_id\" : self . client_id , \"request_uri\" : self . request_uri }, ) . url ) def __repr__ ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri __init__ ( authorization_endpoint , client_id , request_uri , expires_at = None ) \u00b6 Init a RequestUriParameterAuthorizationRequest. It needs an authorization endpoint, a client_id, a request_uri, and an optional expiration date. Source code in requests_oauth2client/authorization_request.py 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 @accepts_expires_in def __init__ ( self , authorization_endpoint : str , client_id : str , request_uri : str , expires_at : Optional [ datetime ] = None , ): \"\"\"Init a RequestUriParameterAuthorizationRequest. It needs an authorization endpoint, a client_id, a request_uri, and an optional expiration date. \"\"\" self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . request_uri = request_uri self . expires_at = expires_at __repr__ () \u00b6 Return the Authorization Request URI, as a str . :return: the Authorization Request URI. Source code in requests_oauth2client/authorization_request.py 513 514 515 516 517 518 def __repr__ ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri uri () property \u00b6 Return the Authorization Request URI, as a str . Source code in requests_oauth2client/authorization_request.py 503 504 505 506 507 508 509 510 511 @property def uri ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`.\"\"\" return str ( furl ( self . authorization_endpoint , args = { \"client_id\" : self . client_id , \"request_uri\" : self . request_uri }, ) . url ) backchannel_authentication \u00b6 Implementation of Client Initiated BackChannel Authentication (CIBA) . BackChannelAuthenticationPoolingJob \u00b6 Bases: TokenEndpointPoolingJob A pooling job for checking if the user has finished with his authorization in a BackChannel Authentication flow. Usage: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , auth = ( \"client_id\" , \"client_secret\" ) ) pool_job = BackChannelAuthenticationPoolingJob ( client = client , auth_req_id = \"my_auth_req_id\" ) token = None while token is None : token = pool_job () Source code in requests_oauth2client/backchannel_authentication.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 class BackChannelAuthenticationPoolingJob ( TokenEndpointPoolingJob ): \"\"\" A pooling job for checking if the user has finished with his authorization in a BackChannel Authentication flow. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\") ) pool_job = BackChannelAuthenticationPoolingJob( client=client, auth_req_id=\"my_auth_req_id\" ) token = None while token is None: token = pool_job() ``` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" if ( isinstance ( auth_req_id , BackChannelAuthenticationResponse ) and interval is None ): interval = auth_req_id . interval super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . auth_req_id = auth_req_id def token_request ( self ) -> BearerToken : \"\"\" Implement the CIBA token request. This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . ciba ( self . auth_req_id , requests_kwargs = self . requests_kwargs , ** self . token_kwargs ) __init__ ( client , auth_req_id , interval = None , slow_down_interval = 5 , requests_kwargs = None , ** token_kwargs ) \u00b6 Initialize a BackChannelAuthenticationPoolingJob . :param client: an OAuth2Client that will be used to pool the token endpoint. :param auth_req_id: an auth_req_id as str or a BackChannelAuthenticationResponse . :param interval: The pooling interval to use. This overrides the one in auth_req_id if it is a BackChannelAuthenticationResponse . :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to requests.request . :param token_kwargs: Additional parameters for the token request. Source code in requests_oauth2client/backchannel_authentication.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , client : \"OAuth2Client\" , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" if ( isinstance ( auth_req_id , BackChannelAuthenticationResponse ) and interval is None ): interval = auth_req_id . interval super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . auth_req_id = auth_req_id token_request () \u00b6 Implement the CIBA token request. This actually calls [OAuth2Client.ciba(auth_req_id)] on client . :return: a BearerToken Source code in requests_oauth2client/backchannel_authentication.py 125 126 127 128 129 130 131 132 133 134 def token_request ( self ) -> BearerToken : \"\"\" Implement the CIBA token request. This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . ciba ( self . auth_req_id , requests_kwargs = self . requests_kwargs , ** self . token_kwargs ) BackChannelAuthenticationResponse \u00b6 Represent a BackChannel Authentication Response. This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as auth_req_id , expires_at , interval , and/or any custom parameters. Source code in requests_oauth2client/backchannel_authentication.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class BackChannelAuthenticationResponse : \"\"\" Represent a BackChannel Authentication Response. This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as `auth_req_id`, `expires_at`, `interval`, and/or any custom parameters. \"\"\" @accepts_expires_in def __init__ ( self , auth_req_id : str , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = 20 , ** kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationResponse`. Such a response MUST include an `auth_req_id`. :param auth_req_id: the `auth_req_id` as returned by the AS. :param expires_at: the date when the `auth_req_id` expires. Note that this request also accepts an `expires_in` parameter, in seconds. :param interval: the Token Endpoint pooling interval, in seconds, as returned by the AS. :param kwargs: any additional custom parameters as returned by the AS. \"\"\" self . auth_req_id = auth_req_id self . expires_at = expires_at self . interval = interval self . other = kwargs def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Return `True` if the auth_req_id within this response is expired at the time of the call. :return: `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this `BackChannelAuthenticationResponse`. Allows accessing response parameters with `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not present in the response \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) return self . other . get ( key ) or super () . __getattribute__ ( key ) __getattr__ ( key ) \u00b6 Return attributes from this BackChannelAuthenticationResponse . Allows accessing response parameters with token_response.expires_in or token_response.any_custom_attribute :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not present in the response Source code in requests_oauth2client/backchannel_authentication.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this `BackChannelAuthenticationResponse`. Allows accessing response parameters with `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not present in the response \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) return self . other . get ( key ) or super () . __getattribute__ ( key ) __init__ ( auth_req_id , expires_at = None , interval = 20 , ** kwargs ) \u00b6 Initialize a BackChannelAuthenticationResponse . Such a response MUST include an auth_req_id . :param auth_req_id: the auth_req_id as returned by the AS. :param expires_at: the date when the auth_req_id expires. Note that this request also accepts an expires_in parameter, in seconds. :param interval: the Token Endpoint pooling interval, in seconds, as returned by the AS. :param kwargs: any additional custom parameters as returned by the AS. Source code in requests_oauth2client/backchannel_authentication.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @accepts_expires_in def __init__ ( self , auth_req_id : str , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = 20 , ** kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationResponse`. Such a response MUST include an `auth_req_id`. :param auth_req_id: the `auth_req_id` as returned by the AS. :param expires_at: the date when the `auth_req_id` expires. Note that this request also accepts an `expires_in` parameter, in seconds. :param interval: the Token Endpoint pooling interval, in seconds, as returned by the AS. :param kwargs: any additional custom parameters as returned by the AS. \"\"\" self . auth_req_id = auth_req_id self . expires_at = expires_at self . interval = interval self . other = kwargs is_expired ( leeway = 0 ) \u00b6 Return True if the auth_req_id within this response is expired at the time of the call. :return: True if the auth_req_id is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client/backchannel_authentication.py 45 46 47 48 49 50 51 52 53 54 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Return `True` if the auth_req_id within this response is expired at the time of the call. :return: `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None client \u00b6 This module contains the OAuth2Client class, which is a central part of requests_oauth2client . OAuth2Client \u00b6 An OAuth 2.0 client, that can send requests to an OAuth 2.0 Authorization Server. OAuth2Client is able to obtain tokens from the Token Endpoint using one of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint. This class doesn't implement anything related to the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest . Usage: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , revocation_endpoint = \"https://my.as.local/revoke\" , auth = ( \"client_id\" , \"client_secret\" ), ) # once intialized, a client can send requests to its configured endpoints cc_token = client . client_credentials ( scope = \"my_scope\" ) ac_token = client . authorization_code ( code = \"my_code\" ) client . revoke_access_token ( cc_token ) Source code in requests_oauth2client/client.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 class OAuth2Client : \"\"\" An OAuth 2.0 client, that can send requests to an OAuth 2.0 Authorization Server. `OAuth2Client` is able to obtain tokens from the Token Endpoint using one of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint. This class doesn't implement anything related to the end-user authentication or any request that goes in a browser. For authentication requests, see [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", revocation_endpoint=\"https://my.as.local/revoke\", auth=(\"client_id\", \"client_secret\"), ) # once intialized, a client can send requests to its configured endpoints cc_token = client.client_credentials(scope=\"my_scope\") ac_token = client.authorization_code(code=\"my_code\") client.revoke_access_token(cc_token) ``` \"\"\" exception_classes : Dict [ str , Type [ Exception ]] = { \"server_error\" : ServerError , \"invalid_scope\" : InvalidScope , \"invalid_target\" : InvalidTarget , \"invalid_grant\" : InvalidGrant , \"access_denied\" : AccessDenied , \"unauthorized_client\" : UnauthorizedClient , \"authorization_pending\" : AuthorizationPending , \"slow_down\" : SlowDown , \"expired_token\" : ExpiredToken , \"unsupported_token_type\" : UnsupportedTokenType , } def __init__ ( self , token_endpoint : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], Tuple [ str , Jwk ], str ], revocation_endpoint : Optional [ str ] = None , introspection_endpoint : Optional [ str ] = None , userinfo_endpoint : Optional [ str ] = None , backchannel_authentication_endpoint : Optional [ str ] = None , device_authorization_endpoint : Optional [ str ] = None , pushed_authorization_request_endpoint : Optional [ str ] = None , jwks_uri : Optional [ str ] = None , session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `OAuth2Client`. :param token_endpoint: the Token Endpoint URI where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a [requests.auth.AuthBase][] instance (which will be as-is), or a tuple of `(client_id, client_secret)` which will initialize an instance of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost], a `(client_id, jwk)` to initialize a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt], or a `client_id` which will use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication. :param revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens :param introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens :param userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user :param backchannel_authentication_endpoint: the BackChannel Authentication URI :param device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices :param jwks_uri: the JWKS URI to use to obtain the AS public keys :param session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS. \"\"\" self . token_endpoint = str ( token_endpoint ) self . revocation_endpoint = ( str ( revocation_endpoint ) if revocation_endpoint else None ) self . introspection_endpoint = ( str ( introspection_endpoint ) if introspection_endpoint else None ) self . userinfo_endpoint = str ( userinfo_endpoint ) if userinfo_endpoint else None self . backchannel_authentication_endpoint = ( str ( backchannel_authentication_endpoint ) if backchannel_authentication_endpoint else None ) self . device_authorization_endpoint = ( str ( device_authorization_endpoint ) if device_authorization_endpoint else None ) self . pushed_authorization_request_endpoint = ( str ( pushed_authorization_request_endpoint ) if pushed_authorization_request_endpoint else None ) self . jwks_uri = str ( jwks_uri ) if jwks_uri else None self . session = session or requests . Session () self . auth = client_auth_factory ( auth , ClientSecretPost ) def token_request ( self , data : Dict [ str , Any ], timeout : int = 10 , ** requests_kwargs : Any ) -> BearerToken : \"\"\" Send a request to the token endpoint. Authentication will be added automatically. :param data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request. :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as [BearerToken][requests_oauth2client.tokens.BearerToken] instance. \"\"\" requests_kwargs = { key : value for key , value in requests_kwargs . items () if value is not None and value != \"\" } response = self . session . post ( self . token_endpoint , auth = self . auth , data = data , timeout = timeout , ** requests_kwargs , ) if response . ok : return self . parse_token_response ( response ) return self . on_token_error ( response ) def parse_token_response ( self , response : requests . Response ) -> BearerToken : \"\"\" Parse a Response returned by the Token Endpoint. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse responses returned by the Token Endpoint. Those response contain an `access_token` and additional attributes. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] based on the response contents. \"\"\" try : token_response = BearerToken ( ** response . json ()) return token_response except Exception as response_class_exc : try : return self . on_token_error ( response ) except Exception as token_error_exc : raise token_error_exc from response_class_exc def on_token_error ( self , response : requests . Response ) -> BearerToken : \"\"\" Error handler for [token_request][requests_oauth2client.client.OAuth2Client.token_request]. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the Token Endpoint returns an error. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: returns nothing and raises an exception instead. But a subclass may return a [BearerToken][requests_oauth2client.tokens.BearerToken] to implement a default behaviour if needed. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidTokenResponse ( \"token endpoint returned an HTTP error without error message\" , error_json , ) def client_credentials ( self , requests_kwargs : Optional [ Dict [ str , Any ]] = None , scope : Optional [ Union [ str , Iterable [ str ]]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint using the `client_credentials` grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters to pass that way include `scope`, `audience`, `resource`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc data = dict ( grant_type = \"client_credentials\" , scope = scope , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) def authorization_code ( self , code : Union [ str , AuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `authorization_code` grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" if isinstance ( code , AuthorizationResponse ): if not isinstance ( code . code , str ): raise ValueError ( \"This AuthorizationResponse doesn't contain an authorization code\" ) token_kwargs . setdefault ( \"code_verifer\" , code . code_verifier ) token_kwargs . setdefault ( \"redirect_uri\" , code . redirect_uri ) code = code . code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"authorization_code\" , code = code , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) def refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `refresh_token` grant. :param refresh_token: a refresh_token, as a string, or as a BearerToken. That BearerToken must have a `refresh_token`. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `refresh_token`, etc. :param requests_kwargs: additional parameters for the call to `requests` :return: a BearerToken \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"This BearerToken doesn't have a refresh_token\" ) refresh_token = refresh_token . refresh_token requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"refresh_token\" , refresh_token = refresh_token , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) def device_code ( self , device_code : Union [ str , DeviceAuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `urn:ietf:params:oauth:grant-type:device_code` grant. :param device_code: a device code, as received during the Device Authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc. :return: a BearerToken \"\"\" if isinstance ( device_code , DeviceAuthorizationResponse ): device_code = device_code . device_code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:device_code\" , device_code = device_code , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) def ciba ( self , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a CIBA request to the Token Endpoint. A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant. :param auth_req_id: an authentication request ID, as returned by the AS :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc. :return: \"\"\" if isinstance ( auth_req_id , BackChannelAuthenticationResponse ): auth_req_id = auth_req_id . auth_req_id requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:openid:params:grant-type:ciba\" , auth_req_id = auth_req_id , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) def token_exchange ( self , subject_token : Union [ str , BearerToken , IdToken ], subject_token_type : Optional [ str ] = None , actor_token : Union [ None , str , BearerToken , IdToken ] = None , actor_token_type : Optional [ str ] = None , requested_token_type : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a Token Exchange request. A Token Exchange request is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`. :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on `type(subject_token)`. :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on `type(actor_token)`. :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying `requests.post()` call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. \"\"\" requests_kwargs = requests_kwargs or {} try : subject_token_type = self . get_token_type ( subject_token_type , subject_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'subject_token' you provided. \" \"Please specify a 'subject_token_type'.\" ) if actor_token : # pragma: no branch try : actor_token_type = self . get_token_type ( actor_token_type , actor_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'actor_token' you provided. \" \"Please specify an 'actor_token_type'.\" ) data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:token-exchange\" , subject_token = subject_token , subject_token_type = subject_token_type , actor_token = actor_token , actor_token_type = actor_token_type , requested_token_type = requested_token_type , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) def pushed_authorization_request ( self , authorization_request : AuthorizationRequest ) -> RequestUriParameterAuthorizationRequest : \"\"\"Send a Pushed Authorization Request, return a RequestUriParameterAuthorizationRequest initialized with the AS response. :param authorization_request: the authorization request to send :return: the RequestUriParameterAuthorizationRequest initialized based on the AS response \"\"\" if not self . pushed_authorization_request_endpoint : raise AttributeError ( \"No 'pushed_authorization_request_endpoint' defined for this client.\" ) response = self . session . post ( self . pushed_authorization_request_endpoint , data = authorization_request . args , auth = self . auth , ) if not response . ok : return self . on_pushed_authorization_request_error ( response ) response_json = response . json () request_uri = response_json . get ( \"request_uri\" ) expires_in = response_json . get ( \"expires_in\" ) return RequestUriParameterAuthorizationRequest ( authorization_endpoint = authorization_request . authorization_endpoint , client_id = authorization_request . client_id , request_uri = request_uri , expires_in = expires_in , ) def on_pushed_authorization_request_error ( self , response : requests . Response ) -> RequestUriParameterAuthorizationRequest : \"\"\"Error Handler for Pushed Authorization Endpoint errors. :param response: the HTTP response as returned by the AS PAR endpoint. :return: a RequestUriParameterAuthorizationRequest, if the error is recoverable :raises: Exception \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidPushedAuthorizationResponse ( \"pushed authorization endpoint returned an HTTP error without error message\" , error_json , ) def userinfo ( self , access_token : Union [ BearerToken , str ]) -> Any : \"\"\" Call the UserInfo endpoint with the specified access_token and return the result. :param access_token: the access token to use :return: the [Response][requests.Response] returned by the userinfo endpoint. \"\"\" if not self . userinfo_endpoint : raise AttributeError ( \"No userinfo_endpoint defined for this client\" ) response = self . session . post ( self . userinfo_endpoint , auth = BearerAuth ( access_token ) ) return self . parse_userinfo_response ( response ) def parse_userinfo_response ( self , resp : requests . Response ) -> Any : \"\"\" Given a response obtained from the userinfo endpoint, extract its JSON content. :param resp: a [Response][requests.Response] returned from the UserInfo endpoint. :return: the parsed JSON content from this response. \"\"\" return resp . json () @classmethod def get_token_type ( cls , token_type : Optional [ str ] = None , token : Union [ None , str , BearerToken , IdToken ] = None , ) -> str : \"\"\" Return a standardised token type identifier, based on a short `token_type` hint and/or a token value. :param token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional) :param token: a token value, as an instance of BearerToken or IdToken, or as a `str`. :return: the token_type as defined in the Token Exchange RFC8693. \"\"\" if not ( token_type or token ): raise ValueError ( \"Cannot determine type of an empty token without a token_type hint\" ) if token_type is None : if isinstance ( token , str ): raise ValueError ( \"Cannot determine the type of provided token when it is a bare str. \" \"Please specify a token_type.\" ) elif isinstance ( token , BearerToken ): return \"urn:ietf:params:oauth:token-type:access_token\" elif isinstance ( token , IdToken ): return \"urn:ietf:params:oauth:token-type:id_token\" else : raise TypeError ( \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\" , type ( token ), ) elif token_type == \"access_token\" : if token is not None and not isinstance ( token , ( str , BearerToken )): raise TypeError ( \"The supplied token is not a BearerToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:access_token\" elif token_type == \"refresh_token\" : if ( token is not None and isinstance ( token , BearerToken ) and not token . refresh_token ): raise ValueError ( \"The supplied BearerToken doesn't have a refresh_token.\" ) return \"urn:ietf:params:oauth:token-type:refresh_token\" elif token_type == \"id_token\" : if token is not None and not isinstance ( token , ( str , IdToken )): raise TypeError ( \"The supplied token is not an IdToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:id_token\" else : return { \"saml1\" : \"urn:ietf:params:oauth:token-type:saml1\" , \"saml2\" : \"urn:ietf:params:oauth:token-type:saml2\" , \"jwt\" : \"urn:ietf:params:oauth:token-type:jwt\" , } . get ( token_type , token_type ) def revoke_access_token ( self , access_token : Union [ BearerToken , str ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint \"\"\" return self . revoke_token ( access_token , token_type_hint = \"access_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) def revoke_refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: `True` if the revocation request is successful, `False` if this client has no configured revocation endpoint. \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) refresh_token = refresh_token . refresh_token return self . revoke_token ( refresh_token , token_type_hint = \"refresh_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) def revoke_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a Token Revocation request. By default, authentication will be the same than the one used for the Token Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: `True` if the revocation succeeds, `False` if no revocation endpoint is present or a non-standardised error is returned. \"\"\" if not self . revocation_endpoint : return False requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( revoke_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . revocation_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return True return self . on_revocation_error ( response ) def on_revocation_error ( self , response : requests . Response ) -> bool : \"\"\" Error handler for [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token]. Invoked by :method:`revoke_token` when the revocation endpoint returns an error. :param response: the [Response][requests.Response] as returned by the Revocation Endpoint :return: returns `False` to signal that an error occurred. May raise exceptions instead depending on the revocation response. \"\"\" try : data = response . json () except ValueError : return False error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , RevocationError ) raise exception_class ( error , error_description , error_uri ) return False def introspect_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** introspect_kwargs : Any , ) -> Any : \"\"\" Send a request to the configured Introspection Endpoint. :param token: the token to introspect. :param token_type_hint: the token_type_hint to include in the request. :param requests_kwargs: additional parameters to the underling call to requests.post() :param introspect_kwargs: additional parameters to send to the introspection endpoint. :return: the response as returned by the Introspection Endpoint. \"\"\" if not self . introspection_endpoint : raise AttributeError ( \"No introspection endpoint defined for this client\" ) requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( introspect_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . introspection_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_introspection_response ( response ) return self . on_introspection_error ( response ) def parse_introspection_response ( self , response : requests . Response ) -> Any : \"\"\" Parse Token Introspection Responses received by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string. :param response: the [Response][requests.Response] as returned by the Introspection Endpoint. :return: the decoded JSON content, or a `str` with the content. \"\"\" try : return response . json () except ValueError : return response . text def on_introspection_error ( self , response : requests . Response ) -> Any : \"\"\" Error handler for [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response in the case an error is returned. :param response: the response as returned by the Introspection Endpoint. :return: raises exeptions. A subclass can return a default response instead. \"\"\" try : data = response . json () except ValueError : try : response . raise_for_status () except Exception as exc : raise UnknownIntrospectionError ( response ) from exc error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , IntrospectionError ) raise exception_class ( error , error_description , error_uri ) raise UnknownIntrospectionError ( response ) def backchannel_authentication_request ( self , scope : Union [ None , str , Iterable [ str ]] = \"openid\" , client_notification_token : Optional [ str ] = None , acr_values : Union [ None , str , Iterable [ str ]] = None , login_hint_token : Optional [ str ] = None , id_token_hint : Optional [ str ] = None , login_hint : Optional [ str ] = None , binding_message : Optional [ str ] = None , user_code : Optional [ str ] = None , requested_expiry : Optional [ int ] = None , private_jwk : Union [ Jwk , Dict [ str , Any ], None ] = None , alg : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** ciba_kwargs : Any , ) -> BackChannelAuthenticationResponse : \"\"\" Send a CIBA Authentication Request. :param scope: the scope to include in the request. :param client_notification_token: the Client Notification Token to include in the request. :param acr_values: the acr values to include in the request. :param login_hint_token: the Login Hint Token to include in the request. :param id_token_hint: the ID Token Hint to include in the request. :param login_hint: the Login Hint to include in the request. :param binding_message: the Binding Message to include in the request. :param user_code: the User Code to include in the request :param requested_expiry: the Requested Expiry, in seconds, to include in the request. :param private_jwk: the JWK to use to sign the request (optional) :param alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter. :param requests_kwargs: additional parameters for :param ciba_kwargs: additional parameters to include in the request. :return: a BackChannelAuthenticationResponse \"\"\" if not self . backchannel_authentication_endpoint : raise AttributeError ( \"No backchannel authentication endpoint defined for this client\" ) if not ( login_hint or login_hint_token or id_token_hint ): raise ValueError ( \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) if ( ( login_hint_token and id_token_hint ) or ( login_hint and id_token_hint ) or ( login_hint_token and login_hint ) ): raise ValueError ( \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported `scope` value\" ) from exc if acr_values is not None and not isinstance ( acr_values , str ): try : acr_values = \" \" . join ( acr_values ) except Exception as exc : raise ValueError ( \"Unsupported `acr_values`\" ) from exc data = dict ( ciba_kwargs , scope = scope , client_notification_token = client_notification_token , acr_values = acr_values , login_hint_token = login_hint_token , id_token_hint = id_token_hint , login_hint = login_hint , binding_message = binding_message , user_code = user_code , requested_expiry = requested_expiry , ) if private_jwk is not None : data = { \"request\" : str ( Jwt . sign ( data , jwk = private_jwk , alg = alg ))} response = self . session . post ( self . backchannel_authentication_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_backchannel_authentication_response ( response ) return self . on_backchannel_authentication_error ( response ) def parse_backchannel_authentication_response ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Parse a BackChannel Authentication Response received by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint. :param response: the response returned by the BackChannel Authentication Endpoint. :return: a :class:`BackChannelAuthenticationResponse` \"\"\" try : return BackChannelAuthenticationResponse ( ** response . json ()) except TypeError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc def on_backchannel_authentication_error ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Error handler for [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint, when it is an error. :param response: the response returned by the BackChannel Authentication Endpoint. :return: raises an exception. But a subclass can return a default response instead. \"\"\" try : error_json = response . json () except ValueError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , BackChannelAuthenticationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidBackChannelAuthenticationResponse ( response ) def authorize_device ( self , ** data : Any ) -> DeviceAuthorizationResponse : \"\"\" Send a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response \"\"\" if self . device_authorization_endpoint is None : raise AttributeError ( \"No device authorization endpoint defined for this client\" ) response = self . session . post ( self . device_authorization_endpoint , data = data , auth = self . auth ) if response . ok : return self . parse_device_authorization_response ( response ) return self . on_device_authorization_error ( response ) def parse_device_authorization_response ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Parse a Device Authorization Response received by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint. :param response: the response returned by the Device Authorization Endpoint. :return: a :class:`DeviceAuthorizationResponse` \"\"\" device_authorization_response = DeviceAuthorizationResponse ( ** response . json ()) return device_authorization_response def on_device_authorization_error ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Error handler for [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint, when that response is an error. :param response: the response returned by the Device Authorization Endpoint. :return: raises an Exception. But a subclass may return a default response instead. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , DeviceAuthorizationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidDeviceAuthorizationResponse ( \"device authorization endpoint returned an HTTP error without an error message\" , error_json , ) def get_public_jwks ( self ) -> JwkSet : \"\"\" Fetch and parse the public keys from the JWKS endpoint. :return: a JwkSet based on the retrieved keys. \"\"\" if not self . jwks_uri : raise ValueError ( \"No jwks uri defined for this client\" ) jwks = self . session . get ( self . jwks_uri , auth = None ) . json () return JwkSet ( jwks ) @classmethod def from_discovery_endpoint ( cls , url : str , issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, retrieving the endpoint uris from the server metadata exposed on a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client \"\"\" session = session or requests . Session () discovery = session . get ( url ) . json () return cls . from_discovery_document ( discovery , issuer = issuer , auth = auth , session = session ) @classmethod def from_discovery_document ( cls , discovery : Dict [ str , Any ], issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , https : bool = True , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, based on the server metadata from `discovery`. :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client \"\"\" if issuer : # pragma: no branch issuer_from_doc = discovery . get ( \"issuer\" ) if issuer_from_doc != issuer : raise ValueError ( \"issuer mismatch!\" , issuer_from_doc ) token_endpoint = discovery . get ( \"token_endpoint\" ) if token_endpoint is None : raise ValueError ( \"token_endpoint not found in that discovery document\" ) validate_endpoint_uri ( token_endpoint , https = https ) revocation_endpoint = discovery . get ( \"revocation_endpoint\" ) if revocation_endpoint is not None : validate_endpoint_uri ( revocation_endpoint , https = https ) introspection_endpoint = discovery . get ( \"introspection_endpoint\" ) if introspection_endpoint is not None : validate_endpoint_uri ( introspection_endpoint , https = https ) userinfo_endpoint = discovery . get ( \"userinfo_endpoint\" ) if userinfo_endpoint is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) jwks_uri = discovery . get ( \"jwks_uri\" ) if jwks_uri is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) return cls ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , introspection_endpoint = introspection_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , ) __init__ ( token_endpoint , auth , revocation_endpoint = None , introspection_endpoint = None , userinfo_endpoint = None , backchannel_authentication_endpoint = None , device_authorization_endpoint = None , pushed_authorization_request_endpoint = None , jwks_uri = None , session = None ) \u00b6 Initialize an OAuth2Client . :param token_endpoint: the Token Endpoint URI where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a requests.auth.AuthBase instance (which will be as-is), or a tuple of (client_id, client_secret) which will initialize an instance of ClientSecretPost , a (client_id, jwk) to initialize a PrivateKeyJwt , or a client_id which will use PublicApp authentication. :param revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens :param introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens :param userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user :param backchannel_authentication_endpoint: the BackChannel Authentication URI :param device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices :param jwks_uri: the JWKS URI to use to obtain the AS public keys :param session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS. Source code in requests_oauth2client/client.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def __init__ ( self , token_endpoint : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], Tuple [ str , Jwk ], str ], revocation_endpoint : Optional [ str ] = None , introspection_endpoint : Optional [ str ] = None , userinfo_endpoint : Optional [ str ] = None , backchannel_authentication_endpoint : Optional [ str ] = None , device_authorization_endpoint : Optional [ str ] = None , pushed_authorization_request_endpoint : Optional [ str ] = None , jwks_uri : Optional [ str ] = None , session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `OAuth2Client`. :param token_endpoint: the Token Endpoint URI where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a [requests.auth.AuthBase][] instance (which will be as-is), or a tuple of `(client_id, client_secret)` which will initialize an instance of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost], a `(client_id, jwk)` to initialize a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt], or a `client_id` which will use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication. :param revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens :param introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens :param userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user :param backchannel_authentication_endpoint: the BackChannel Authentication URI :param device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices :param jwks_uri: the JWKS URI to use to obtain the AS public keys :param session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS. \"\"\" self . token_endpoint = str ( token_endpoint ) self . revocation_endpoint = ( str ( revocation_endpoint ) if revocation_endpoint else None ) self . introspection_endpoint = ( str ( introspection_endpoint ) if introspection_endpoint else None ) self . userinfo_endpoint = str ( userinfo_endpoint ) if userinfo_endpoint else None self . backchannel_authentication_endpoint = ( str ( backchannel_authentication_endpoint ) if backchannel_authentication_endpoint else None ) self . device_authorization_endpoint = ( str ( device_authorization_endpoint ) if device_authorization_endpoint else None ) self . pushed_authorization_request_endpoint = ( str ( pushed_authorization_request_endpoint ) if pushed_authorization_request_endpoint else None ) self . jwks_uri = str ( jwks_uri ) if jwks_uri else None self . session = session or requests . Session () self . auth = client_auth_factory ( auth , ClientSecretPost ) authorization_code ( code , requests_kwargs = None , ** token_kwargs ) \u00b6 Send a request to the token endpoint with the authorization_code grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , code , etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse Source code in requests_oauth2client/client.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def authorization_code ( self , code : Union [ str , AuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `authorization_code` grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" if isinstance ( code , AuthorizationResponse ): if not isinstance ( code . code , str ): raise ValueError ( \"This AuthorizationResponse doesn't contain an authorization code\" ) token_kwargs . setdefault ( \"code_verifer\" , code . code_verifier ) token_kwargs . setdefault ( \"redirect_uri\" , code . redirect_uri ) code = code . code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"authorization_code\" , code = code , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) authorize_device ( ** data ) \u00b6 Send a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response Source code in requests_oauth2client/client.py 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 def authorize_device ( self , ** data : Any ) -> DeviceAuthorizationResponse : \"\"\" Send a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response \"\"\" if self . device_authorization_endpoint is None : raise AttributeError ( \"No device authorization endpoint defined for this client\" ) response = self . session . post ( self . device_authorization_endpoint , data = data , auth = self . auth ) if response . ok : return self . parse_device_authorization_response ( response ) return self . on_device_authorization_error ( response ) backchannel_authentication_request ( scope = 'openid' , client_notification_token = None , acr_values = None , login_hint_token = None , id_token_hint = None , login_hint = None , binding_message = None , user_code = None , requested_expiry = None , private_jwk = None , alg = None , requests_kwargs = None , ** ciba_kwargs ) \u00b6 Send a CIBA Authentication Request. :param scope: the scope to include in the request. :param client_notification_token: the Client Notification Token to include in the request. :param acr_values: the acr values to include in the request. :param login_hint_token: the Login Hint Token to include in the request. :param id_token_hint: the ID Token Hint to include in the request. :param login_hint: the Login Hint to include in the request. :param binding_message: the Binding Message to include in the request. :param user_code: the User Code to include in the request :param requested_expiry: the Requested Expiry, in seconds, to include in the request. :param private_jwk: the JWK to use to sign the request (optional) :param alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter. :param requests_kwargs: additional parameters for :param ciba_kwargs: additional parameters to include in the request. :return: a BackChannelAuthenticationResponse Source code in requests_oauth2client/client.py 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 def backchannel_authentication_request ( self , scope : Union [ None , str , Iterable [ str ]] = \"openid\" , client_notification_token : Optional [ str ] = None , acr_values : Union [ None , str , Iterable [ str ]] = None , login_hint_token : Optional [ str ] = None , id_token_hint : Optional [ str ] = None , login_hint : Optional [ str ] = None , binding_message : Optional [ str ] = None , user_code : Optional [ str ] = None , requested_expiry : Optional [ int ] = None , private_jwk : Union [ Jwk , Dict [ str , Any ], None ] = None , alg : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** ciba_kwargs : Any , ) -> BackChannelAuthenticationResponse : \"\"\" Send a CIBA Authentication Request. :param scope: the scope to include in the request. :param client_notification_token: the Client Notification Token to include in the request. :param acr_values: the acr values to include in the request. :param login_hint_token: the Login Hint Token to include in the request. :param id_token_hint: the ID Token Hint to include in the request. :param login_hint: the Login Hint to include in the request. :param binding_message: the Binding Message to include in the request. :param user_code: the User Code to include in the request :param requested_expiry: the Requested Expiry, in seconds, to include in the request. :param private_jwk: the JWK to use to sign the request (optional) :param alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter. :param requests_kwargs: additional parameters for :param ciba_kwargs: additional parameters to include in the request. :return: a BackChannelAuthenticationResponse \"\"\" if not self . backchannel_authentication_endpoint : raise AttributeError ( \"No backchannel authentication endpoint defined for this client\" ) if not ( login_hint or login_hint_token or id_token_hint ): raise ValueError ( \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) if ( ( login_hint_token and id_token_hint ) or ( login_hint and id_token_hint ) or ( login_hint_token and login_hint ) ): raise ValueError ( \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported `scope` value\" ) from exc if acr_values is not None and not isinstance ( acr_values , str ): try : acr_values = \" \" . join ( acr_values ) except Exception as exc : raise ValueError ( \"Unsupported `acr_values`\" ) from exc data = dict ( ciba_kwargs , scope = scope , client_notification_token = client_notification_token , acr_values = acr_values , login_hint_token = login_hint_token , id_token_hint = id_token_hint , login_hint = login_hint , binding_message = binding_message , user_code = user_code , requested_expiry = requested_expiry , ) if private_jwk is not None : data = { \"request\" : str ( Jwt . sign ( data , jwk = private_jwk , alg = alg ))} response = self . session . post ( self . backchannel_authentication_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_backchannel_authentication_response ( response ) return self . on_backchannel_authentication_error ( response ) ciba ( auth_req_id , requests_kwargs = None , ** token_kwargs ) \u00b6 Send a CIBA request to the Token Endpoint. A CIBA request is a Token Request using the urn:openid:params:grant-type:ciba grant. :param auth_req_id: an authentication request ID, as returned by the AS :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , auth_req_id , etc. :return: Source code in requests_oauth2client/client.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def ciba ( self , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a CIBA request to the Token Endpoint. A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant. :param auth_req_id: an authentication request ID, as returned by the AS :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc. :return: \"\"\" if isinstance ( auth_req_id , BackChannelAuthenticationResponse ): auth_req_id = auth_req_id . auth_req_id requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:openid:params:grant-type:ciba\" , auth_req_id = auth_req_id , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) client_credentials ( requests_kwargs = None , scope = None , ** token_kwargs ) \u00b6 Send a request to the token endpoint using the client_credentials grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside grant_type . Common parameters to pass that way include scope , audience , resource , etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse Source code in requests_oauth2client/client.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def client_credentials ( self , requests_kwargs : Optional [ Dict [ str , Any ]] = None , scope : Optional [ Union [ str , Iterable [ str ]]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint using the `client_credentials` grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters to pass that way include `scope`, `audience`, `resource`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc data = dict ( grant_type = \"client_credentials\" , scope = scope , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) device_code ( device_code , requests_kwargs = None , ** token_kwargs ) \u00b6 Send a request to the token endpoint with the urn:ietf:params:oauth:grant-type:device_code grant. :param device_code: a device code, as received during the Device Authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , device_code , etc. :return: a BearerToken Source code in requests_oauth2client/client.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def device_code ( self , device_code : Union [ str , DeviceAuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `urn:ietf:params:oauth:grant-type:device_code` grant. :param device_code: a device code, as received during the Device Authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc. :return: a BearerToken \"\"\" if isinstance ( device_code , DeviceAuthorizationResponse ): device_code = device_code . device_code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:device_code\" , device_code = device_code , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) from_discovery_document ( discovery , issuer , auth , session = None , https = True ) classmethod \u00b6 Initialise an OAuth2Client, based on the server metadata from discovery . :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client Source code in requests_oauth2client/client.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 @classmethod def from_discovery_document ( cls , discovery : Dict [ str , Any ], issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , https : bool = True , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, based on the server metadata from `discovery`. :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client \"\"\" if issuer : # pragma: no branch issuer_from_doc = discovery . get ( \"issuer\" ) if issuer_from_doc != issuer : raise ValueError ( \"issuer mismatch!\" , issuer_from_doc ) token_endpoint = discovery . get ( \"token_endpoint\" ) if token_endpoint is None : raise ValueError ( \"token_endpoint not found in that discovery document\" ) validate_endpoint_uri ( token_endpoint , https = https ) revocation_endpoint = discovery . get ( \"revocation_endpoint\" ) if revocation_endpoint is not None : validate_endpoint_uri ( revocation_endpoint , https = https ) introspection_endpoint = discovery . get ( \"introspection_endpoint\" ) if introspection_endpoint is not None : validate_endpoint_uri ( introspection_endpoint , https = https ) userinfo_endpoint = discovery . get ( \"userinfo_endpoint\" ) if userinfo_endpoint is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) jwks_uri = discovery . get ( \"jwks_uri\" ) if jwks_uri is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) return cls ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , introspection_endpoint = introspection_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , ) from_discovery_endpoint ( url , issuer , auth , session = None ) classmethod \u00b6 Initialise an OAuth2Client, retrieving the endpoint uris from the server metadata exposed on a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client Source code in requests_oauth2client/client.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 @classmethod def from_discovery_endpoint ( cls , url : str , issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, retrieving the endpoint uris from the server metadata exposed on a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client \"\"\" session = session or requests . Session () discovery = session . get ( url ) . json () return cls . from_discovery_document ( discovery , issuer = issuer , auth = auth , session = session ) get_public_jwks () \u00b6 Fetch and parse the public keys from the JWKS endpoint. :return: a JwkSet based on the retrieved keys. Source code in requests_oauth2client/client.py 928 929 930 931 932 933 934 935 936 937 def get_public_jwks ( self ) -> JwkSet : \"\"\" Fetch and parse the public keys from the JWKS endpoint. :return: a JwkSet based on the retrieved keys. \"\"\" if not self . jwks_uri : raise ValueError ( \"No jwks uri defined for this client\" ) jwks = self . session . get ( self . jwks_uri , auth = None ) . json () return JwkSet ( jwks ) get_token_type ( token_type = None , token = None ) classmethod \u00b6 Return a standardised token type identifier, based on a short token_type hint and/or a token value. :param token_type: a token_type hint, as str . May be \"access_token\", \"refresh_token\" or \"id_token\" (optional) :param token: a token value, as an instance of BearerToken or IdToken, or as a str . :return: the token_type as defined in the Token Exchange RFC8693. Source code in requests_oauth2client/client.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 @classmethod def get_token_type ( cls , token_type : Optional [ str ] = None , token : Union [ None , str , BearerToken , IdToken ] = None , ) -> str : \"\"\" Return a standardised token type identifier, based on a short `token_type` hint and/or a token value. :param token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional) :param token: a token value, as an instance of BearerToken or IdToken, or as a `str`. :return: the token_type as defined in the Token Exchange RFC8693. \"\"\" if not ( token_type or token ): raise ValueError ( \"Cannot determine type of an empty token without a token_type hint\" ) if token_type is None : if isinstance ( token , str ): raise ValueError ( \"Cannot determine the type of provided token when it is a bare str. \" \"Please specify a token_type.\" ) elif isinstance ( token , BearerToken ): return \"urn:ietf:params:oauth:token-type:access_token\" elif isinstance ( token , IdToken ): return \"urn:ietf:params:oauth:token-type:id_token\" else : raise TypeError ( \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\" , type ( token ), ) elif token_type == \"access_token\" : if token is not None and not isinstance ( token , ( str , BearerToken )): raise TypeError ( \"The supplied token is not a BearerToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:access_token\" elif token_type == \"refresh_token\" : if ( token is not None and isinstance ( token , BearerToken ) and not token . refresh_token ): raise ValueError ( \"The supplied BearerToken doesn't have a refresh_token.\" ) return \"urn:ietf:params:oauth:token-type:refresh_token\" elif token_type == \"id_token\" : if token is not None and not isinstance ( token , ( str , IdToken )): raise TypeError ( \"The supplied token is not an IdToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:id_token\" else : return { \"saml1\" : \"urn:ietf:params:oauth:token-type:saml1\" , \"saml2\" : \"urn:ietf:params:oauth:token-type:saml2\" , \"jwt\" : \"urn:ietf:params:oauth:token-type:jwt\" , } . get ( token_type , token_type ) introspect_token ( token , token_type_hint = None , requests_kwargs = None , ** introspect_kwargs ) \u00b6 Send a request to the configured Introspection Endpoint. :param token: the token to introspect. :param token_type_hint: the token_type_hint to include in the request. :param requests_kwargs: additional parameters to the underling call to requests.post() :param introspect_kwargs: additional parameters to send to the introspection endpoint. :return: the response as returned by the Introspection Endpoint. Source code in requests_oauth2client/client.py 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def introspect_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** introspect_kwargs : Any , ) -> Any : \"\"\" Send a request to the configured Introspection Endpoint. :param token: the token to introspect. :param token_type_hint: the token_type_hint to include in the request. :param requests_kwargs: additional parameters to the underling call to requests.post() :param introspect_kwargs: additional parameters to send to the introspection endpoint. :return: the response as returned by the Introspection Endpoint. \"\"\" if not self . introspection_endpoint : raise AttributeError ( \"No introspection endpoint defined for this client\" ) requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( introspect_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . introspection_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_introspection_response ( response ) return self . on_introspection_error ( response ) on_backchannel_authentication_error ( response ) \u00b6 Error handler for backchannel_authentication_request() . Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error. :param response: the response returned by the BackChannel Authentication Endpoint. :return: raises an exception. But a subclass can return a default response instead. Source code in requests_oauth2client/client.py 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 def on_backchannel_authentication_error ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Error handler for [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint, when it is an error. :param response: the response returned by the BackChannel Authentication Endpoint. :return: raises an exception. But a subclass can return a default response instead. \"\"\" try : error_json = response . json () except ValueError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , BackChannelAuthenticationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidBackChannelAuthenticationResponse ( response ) on_device_authorization_error ( response ) \u00b6 Error handler for authorize_device() . Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error. :param response: the response returned by the Device Authorization Endpoint. :return: raises an Exception. But a subclass may return a default response instead. Source code in requests_oauth2client/client.py 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 def on_device_authorization_error ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Error handler for [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint, when that response is an error. :param response: the response returned by the Device Authorization Endpoint. :return: raises an Exception. But a subclass may return a default response instead. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , DeviceAuthorizationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidDeviceAuthorizationResponse ( \"device authorization endpoint returned an HTTP error without an error message\" , error_json , ) on_introspection_error ( response ) \u00b6 Error handler for introspect_token() . Invoked by introspect_token() to parse the returned response in the case an error is returned. :param response: the response as returned by the Introspection Endpoint. :return: raises exeptions. A subclass can return a default response instead. Source code in requests_oauth2client/client.py 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 def on_introspection_error ( self , response : requests . Response ) -> Any : \"\"\" Error handler for [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response in the case an error is returned. :param response: the response as returned by the Introspection Endpoint. :return: raises exeptions. A subclass can return a default response instead. \"\"\" try : data = response . json () except ValueError : try : response . raise_for_status () except Exception as exc : raise UnknownIntrospectionError ( response ) from exc error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , IntrospectionError ) raise exception_class ( error , error_description , error_uri ) raise UnknownIntrospectionError ( response ) on_pushed_authorization_request_error ( response ) \u00b6 Error Handler for Pushed Authorization Endpoint errors. :param response: the HTTP response as returned by the AS PAR endpoint. :return: a RequestUriParameterAuthorizationRequest, if the error is recoverable :raises: Exception Source code in requests_oauth2client/client.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 def on_pushed_authorization_request_error ( self , response : requests . Response ) -> RequestUriParameterAuthorizationRequest : \"\"\"Error Handler for Pushed Authorization Endpoint errors. :param response: the HTTP response as returned by the AS PAR endpoint. :return: a RequestUriParameterAuthorizationRequest, if the error is recoverable :raises: Exception \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidPushedAuthorizationResponse ( \"pushed authorization endpoint returned an HTTP error without error message\" , error_json , ) on_revocation_error ( response ) \u00b6 Error handler for revoke_token() . Invoked by :method: revoke_token when the revocation endpoint returns an error. :param response: the Response as returned by the Revocation Endpoint :return: returns False to signal that an error occurred. May raise exceptions instead depending on the revocation response. Source code in requests_oauth2client/client.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 def on_revocation_error ( self , response : requests . Response ) -> bool : \"\"\" Error handler for [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token]. Invoked by :method:`revoke_token` when the revocation endpoint returns an error. :param response: the [Response][requests.Response] as returned by the Revocation Endpoint :return: returns `False` to signal that an error occurred. May raise exceptions instead depending on the revocation response. \"\"\" try : data = response . json () except ValueError : return False error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , RevocationError ) raise exception_class ( error , error_description , error_uri ) return False on_token_error ( response ) \u00b6 Error handler for token_request . Invoked by token_request when the Token Endpoint returns an error. :param response: the Response returned by the Token Endpoint. :return: returns nothing and raises an exception instead. But a subclass may return a BearerToken to implement a default behaviour if needed. Source code in requests_oauth2client/client.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def on_token_error ( self , response : requests . Response ) -> BearerToken : \"\"\" Error handler for [token_request][requests_oauth2client.client.OAuth2Client.token_request]. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the Token Endpoint returns an error. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: returns nothing and raises an exception instead. But a subclass may return a [BearerToken][requests_oauth2client.tokens.BearerToken] to implement a default behaviour if needed. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidTokenResponse ( \"token endpoint returned an HTTP error without error message\" , error_json , ) parse_backchannel_authentication_response ( response ) \u00b6 Parse a BackChannel Authentication Response received by backchannel_authentication_request() . Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint. :param response: the response returned by the BackChannel Authentication Endpoint. :return: a :class: BackChannelAuthenticationResponse Source code in requests_oauth2client/client.py 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 def parse_backchannel_authentication_response ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Parse a BackChannel Authentication Response received by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint. :param response: the response returned by the BackChannel Authentication Endpoint. :return: a :class:`BackChannelAuthenticationResponse` \"\"\" try : return BackChannelAuthenticationResponse ( ** response . json ()) except TypeError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc parse_device_authorization_response ( response ) \u00b6 Parse a Device Authorization Response received by authorize_device() . Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint. :param response: the response returned by the Device Authorization Endpoint. :return: a :class: DeviceAuthorizationResponse Source code in requests_oauth2client/client.py 889 890 891 892 893 894 895 896 897 898 899 900 def parse_device_authorization_response ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Parse a Device Authorization Response received by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint. :param response: the response returned by the Device Authorization Endpoint. :return: a :class:`DeviceAuthorizationResponse` \"\"\" device_authorization_response = DeviceAuthorizationResponse ( ** response . json ()) return device_authorization_response parse_introspection_response ( response ) \u00b6 Parse Token Introspection Responses received by introspect_token() . Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string. :param response: the Response as returned by the Introspection Endpoint. :return: the decoded JSON content, or a str with the content. Source code in requests_oauth2client/client.py 692 693 694 695 696 697 698 699 700 701 702 703 704 def parse_introspection_response ( self , response : requests . Response ) -> Any : \"\"\" Parse Token Introspection Responses received by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string. :param response: the [Response][requests.Response] as returned by the Introspection Endpoint. :return: the decoded JSON content, or a `str` with the content. \"\"\" try : return response . json () except ValueError : return response . text parse_token_response ( response ) \u00b6 Parse a Response returned by the Token Endpoint. Invoked by token_request to parse responses returned by the Token Endpoint. Those response contain an access_token and additional attributes. :param response: the Response returned by the Token Endpoint. :return: a BearerToken based on the response contents. Source code in requests_oauth2client/client.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def parse_token_response ( self , response : requests . Response ) -> BearerToken : \"\"\" Parse a Response returned by the Token Endpoint. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse responses returned by the Token Endpoint. Those response contain an `access_token` and additional attributes. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] based on the response contents. \"\"\" try : token_response = BearerToken ( ** response . json ()) return token_response except Exception as response_class_exc : try : return self . on_token_error ( response ) except Exception as token_error_exc : raise token_error_exc from response_class_exc parse_userinfo_response ( resp ) \u00b6 Given a response obtained from the userinfo endpoint, extract its JSON content. :param resp: a Response returned from the UserInfo endpoint. :return: the parsed JSON content from this response. Source code in requests_oauth2client/client.py 460 461 462 463 464 465 466 467 def parse_userinfo_response ( self , resp : requests . Response ) -> Any : \"\"\" Given a response obtained from the userinfo endpoint, extract its JSON content. :param resp: a [Response][requests.Response] returned from the UserInfo endpoint. :return: the parsed JSON content from this response. \"\"\" return resp . json () pushed_authorization_request ( authorization_request ) \u00b6 Send a Pushed Authorization Request, return a RequestUriParameterAuthorizationRequest initialized with the AS response. :param authorization_request: the authorization request to send :return: the RequestUriParameterAuthorizationRequest initialized based on the AS response Source code in requests_oauth2client/client.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def pushed_authorization_request ( self , authorization_request : AuthorizationRequest ) -> RequestUriParameterAuthorizationRequest : \"\"\"Send a Pushed Authorization Request, return a RequestUriParameterAuthorizationRequest initialized with the AS response. :param authorization_request: the authorization request to send :return: the RequestUriParameterAuthorizationRequest initialized based on the AS response \"\"\" if not self . pushed_authorization_request_endpoint : raise AttributeError ( \"No 'pushed_authorization_request_endpoint' defined for this client.\" ) response = self . session . post ( self . pushed_authorization_request_endpoint , data = authorization_request . args , auth = self . auth , ) if not response . ok : return self . on_pushed_authorization_request_error ( response ) response_json = response . json () request_uri = response_json . get ( \"request_uri\" ) expires_in = response_json . get ( \"expires_in\" ) return RequestUriParameterAuthorizationRequest ( authorization_endpoint = authorization_request . authorization_endpoint , client_id = authorization_request . client_id , request_uri = request_uri , expires_in = expires_in , ) refresh_token ( refresh_token , requests_kwargs = None , ** token_kwargs ) \u00b6 Send a request to the token endpoint with the refresh_token grant. :param refresh_token: a refresh_token, as a string, or as a BearerToken. That BearerToken must have a refresh_token . :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , refresh_token , etc. :param requests_kwargs: additional parameters for the call to requests :return: a BearerToken Source code in requests_oauth2client/client.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `refresh_token` grant. :param refresh_token: a refresh_token, as a string, or as a BearerToken. That BearerToken must have a `refresh_token`. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `refresh_token`, etc. :param requests_kwargs: additional parameters for the call to `requests` :return: a BearerToken \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"This BearerToken doesn't have a refresh_token\" ) refresh_token = refresh_token . refresh_token requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"refresh_token\" , refresh_token = refresh_token , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) revoke_access_token ( access_token , requests_kwargs = None , ** revoke_kwargs ) \u00b6 Send a request to the Revocation Endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint Source code in requests_oauth2client/client.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 def revoke_access_token ( self , access_token : Union [ BearerToken , str ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint \"\"\" return self . revoke_token ( access_token , token_type_hint = \"access_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) revoke_refresh_token ( refresh_token , requests_kwargs = None , ** revoke_kwargs ) \u00b6 Send a request to the Revocation Endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: True if the revocation request is successful, False if this client has no configured revocation endpoint. Source code in requests_oauth2client/client.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def revoke_refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: `True` if the revocation request is successful, `False` if this client has no configured revocation endpoint. \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) refresh_token = refresh_token . refresh_token return self . revoke_token ( refresh_token , token_type_hint = \"refresh_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) revoke_token ( token , token_type_hint = None , requests_kwargs = None , ** revoke_kwargs ) \u00b6 Send a Token Revocation request. By default, authentication will be the same than the one used for the Token Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: True if the revocation succeeds, False if no revocation endpoint is present or a non-standardised error is returned. Source code in requests_oauth2client/client.py 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def revoke_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a Token Revocation request. By default, authentication will be the same than the one used for the Token Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: `True` if the revocation succeeds, `False` if no revocation endpoint is present or a non-standardised error is returned. \"\"\" if not self . revocation_endpoint : return False requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( revoke_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . revocation_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return True return self . on_revocation_error ( response ) token_exchange ( subject_token , subject_token_type = None , actor_token = None , actor_token_type = None , requested_token_type = None , requests_kwargs = None , ** token_kwargs ) \u00b6 Send a Token Exchange request. A Token Exchange request is actually a request to the Token Endpoint with a grant_type urn:ietf:params:oauth:grant-type:token-exchange . :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on type(subject_token) . :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on type(actor_token) . :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying requests.post() call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. Source code in requests_oauth2client/client.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def token_exchange ( self , subject_token : Union [ str , BearerToken , IdToken ], subject_token_type : Optional [ str ] = None , actor_token : Union [ None , str , BearerToken , IdToken ] = None , actor_token_type : Optional [ str ] = None , requested_token_type : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a Token Exchange request. A Token Exchange request is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`. :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on `type(subject_token)`. :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on `type(actor_token)`. :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying `requests.post()` call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. \"\"\" requests_kwargs = requests_kwargs or {} try : subject_token_type = self . get_token_type ( subject_token_type , subject_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'subject_token' you provided. \" \"Please specify a 'subject_token_type'.\" ) if actor_token : # pragma: no branch try : actor_token_type = self . get_token_type ( actor_token_type , actor_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'actor_token' you provided. \" \"Please specify an 'actor_token_type'.\" ) data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:token-exchange\" , subject_token = subject_token , subject_token_type = subject_token_type , actor_token = actor_token , actor_token_type = actor_token_type , requested_token_type = requested_token_type , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) token_request ( data , timeout = 10 , ** requests_kwargs ) \u00b6 Send a request to the token endpoint. Authentication will be added automatically. :param data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request. :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as BearerToken instance. Source code in requests_oauth2client/client.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def token_request ( self , data : Dict [ str , Any ], timeout : int = 10 , ** requests_kwargs : Any ) -> BearerToken : \"\"\" Send a request to the token endpoint. Authentication will be added automatically. :param data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request. :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as [BearerToken][requests_oauth2client.tokens.BearerToken] instance. \"\"\" requests_kwargs = { key : value for key , value in requests_kwargs . items () if value is not None and value != \"\" } response = self . session . post ( self . token_endpoint , auth = self . auth , data = data , timeout = timeout , ** requests_kwargs , ) if response . ok : return self . parse_token_response ( response ) return self . on_token_error ( response ) userinfo ( access_token ) \u00b6 Call the UserInfo endpoint with the specified access_token and return the result. :param access_token: the access token to use :return: the Response returned by the userinfo endpoint. Source code in requests_oauth2client/client.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def userinfo ( self , access_token : Union [ BearerToken , str ]) -> Any : \"\"\" Call the UserInfo endpoint with the specified access_token and return the result. :param access_token: the access token to use :return: the [Response][requests.Response] returned by the userinfo endpoint. \"\"\" if not self . userinfo_endpoint : raise AttributeError ( \"No userinfo_endpoint defined for this client\" ) response = self . session . post ( self . userinfo_endpoint , auth = BearerAuth ( access_token ) ) return self . parse_userinfo_response ( response ) client_authentication \u00b6 This modules implements multiple Client Authentication Methods for OAuth 2.0 client to authenticate to an AS. BaseClientAuthenticationMethod \u00b6 Bases: requests . auth . AuthBase Base class for all Client Authentication methods. This extends [requests.auth.AuthBase]. This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request. Source code in requests_oauth2client/client_authentication.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class BaseClientAuthenticationMethod ( requests . auth . AuthBase ): \"\"\" Base class for all Client Authentication methods. This extends [requests.auth.AuthBase]. This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request. \"\"\" def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Check that the request is suitable for Client Authentication. It checks: * that the method is `POST` * that the Content-Type is \"application/x-www-form-urlencoded\" or None :param request: a [requests.PreparedRequest][] :return: a [requests.PreparedRequest][], unmodified \"\"\" if request . method != \"POST\" or request . headers . get ( \"Content-Type\" ) not in ( \"application/x-www-form-urlencoded\" , None , ): raise RuntimeError ( \"This request is not suitable for OAuth 2.0 Client Authentication\" ) return request __call__ ( request ) \u00b6 Check that the request is suitable for Client Authentication. It checks: * that the method is POST * that the Content-Type is \"application/x-www-form-urlencoded\" or None :param request: a requests.PreparedRequest :return: a requests.PreparedRequest , unmodified Source code in requests_oauth2client/client_authentication.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Check that the request is suitable for Client Authentication. It checks: * that the method is `POST` * that the Content-Type is \"application/x-www-form-urlencoded\" or None :param request: a [requests.PreparedRequest][] :return: a [requests.PreparedRequest][], unmodified \"\"\" if request . method != \"POST\" or request . headers . get ( \"Content-Type\" ) not in ( \"application/x-www-form-urlencoded\" , None , ): raise RuntimeError ( \"This request is not suitable for OAuth 2.0 Client Authentication\" ) return request ClientAssertionAuthenticationMethod \u00b6 Bases: BaseClientAuthenticationMethod Base class for assertion based client authentication methods. Source code in requests_oauth2client/client_authentication.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class ClientAssertionAuthenticationMethod ( BaseClientAuthenticationMethod ): \"\"\"Base class for assertion based client authentication methods.\"\"\" def __init__ ( self , client_id : str , alg : str , lifetime : int , jti_gen : Callable [[], str ] ): \"\"\" Initialize a `ClientAssertionAuthenticationMethod` Base Auth Handler. :param client_id: the client_id to use :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" self . client_id = str ( client_id ) self . alg = alg self . lifetime = lifetime self . jti_gen = jti_gen def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion for a specific audience. :param audience: the audience to use for the `aud` claim of the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" raise NotImplementedError () # pragma: no cover def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add a `client_assertion` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_assertion` field. \"\"\" request = super () . __call__ ( request ) token_endpoint = request . url assert token_endpoint is not None data = furl . Query ( request . body ) client_assertion = self . client_assertion ( token_endpoint ) data . set ( [ ( \"client_id\" , self . client_id ), ( \"client_assertion\" , client_assertion ), ( \"client_assertion_type\" , \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\" , ), ] ) request . prepare_body ( data . params , files = None ) return request __call__ ( request ) \u00b6 Add a client_assertion field in the request body. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added client_assertion field. Source code in requests_oauth2client/client_authentication.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add a `client_assertion` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_assertion` field. \"\"\" request = super () . __call__ ( request ) token_endpoint = request . url assert token_endpoint is not None data = furl . Query ( request . body ) client_assertion = self . client_assertion ( token_endpoint ) data . set ( [ ( \"client_id\" , self . client_id ), ( \"client_assertion\" , client_assertion ), ( \"client_assertion_type\" , \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\" , ), ] ) request . prepare_body ( data . params , files = None ) return request __init__ ( client_id , alg , lifetime , jti_gen ) \u00b6 Initialize a ClientAssertionAuthenticationMethod Base Auth Handler. :param client_id: the client_id to use :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids ( jti ) for generated Client Assertions. Source code in requests_oauth2client/client_authentication.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __init__ ( self , client_id : str , alg : str , lifetime : int , jti_gen : Callable [[], str ] ): \"\"\" Initialize a `ClientAssertionAuthenticationMethod` Base Auth Handler. :param client_id: the client_id to use :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" self . client_id = str ( client_id ) self . alg = alg self . lifetime = lifetime self . jti_gen = jti_gen client_assertion ( audience ) \u00b6 Generate a Client Assertion for a specific audience. :param audience: the audience to use for the aud claim of the generated Client Assertion. :return: a Client Assertion, as str . Source code in requests_oauth2client/client_authentication.py 115 116 117 118 119 120 121 122 def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion for a specific audience. :param audience: the audience to use for the `aud` claim of the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" raise NotImplementedError () # pragma: no cover ClientSecretBasic \u00b6 Bases: BaseClientAuthenticationMethod Implement client_secret_basic authentication (client_id and client_secret passed as Basic authentication). Source code in requests_oauth2client/client_authentication.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class ClientSecretBasic ( BaseClientAuthenticationMethod ): \"\"\"Implement `client_secret_basic` authentication (client_id and client_secret passed as Basic authentication).\"\"\" def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretBasic` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret ) def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the appropriate `Authorization: Basic` header with `client_id` as username and `client_secret` as password. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added Authorization header. \"\"\" request = super () . __call__ ( request ) b64encoded_credentials = ( BinaPy ( f \" { self . client_id } : { self . client_secret } \" ) . to ( \"b64\" ) . ascii () ) request . headers [ \"Authorization\" ] = f \"Basic { b64encoded_credentials } \" return request __call__ ( request ) \u00b6 Add the appropriate Authorization: Basic header with client_id as username and client_secret as password. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added Authorization header. Source code in requests_oauth2client/client_authentication.py 54 55 56 57 58 59 60 61 62 63 64 65 66 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the appropriate `Authorization: Basic` header with `client_id` as username and `client_secret` as password. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added Authorization header. \"\"\" request = super () . __call__ ( request ) b64encoded_credentials = ( BinaPy ( f \" { self . client_id } : { self . client_secret } \" ) . to ( \"b64\" ) . ascii () ) request . headers [ \"Authorization\" ] = f \"Basic { b64encoded_credentials } \" return request __init__ ( client_id , client_secret ) \u00b6 Initialize a ClientSecretBasic Auth Handler. :param client_id: client_id to use. :param client_secret: client_secret to use. Source code in requests_oauth2client/client_authentication.py 44 45 46 47 48 49 50 51 52 def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretBasic` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret ) ClientSecretJwt \u00b6 Bases: ClientAssertionAuthenticationMethod Implement client_secret_jwt client authentication method (using a client_assertion field, symmetrically signed with the client_secret). Source code in requests_oauth2client/client_authentication.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 class ClientSecretJwt ( ClientAssertionAuthenticationMethod ): \"\"\"Implement `client_secret_jwt` client authentication method (using a `client_assertion` field, symmetrically signed with the client_secret).\"\"\" def __init__ ( self , client_id : str , client_secret : str , alg : str = \"HS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `ClientSecretJwt` Auth Handler. :param client_id: the `client_id` to use. :param client_secret: the `client_secret` to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . client_secret = str ( client_secret ) def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, symmetrically signed with the `client_secret` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwk = SymmetricJwk . from_bytes ( self . client_secret . encode ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = jwk , alg = self . alg , ) return str ( jwt ) __init__ ( client_id , client_secret , alg = 'HS256' , lifetime = 60 , jti_gen = lambda : uuid4 ()) \u00b6 Initialize a ClientSecretJwt Auth Handler. :param client_id: the client_id to use. :param client_secret: the client_secret to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids ( jti ) for generated Client Assertions. Source code in requests_oauth2client/client_authentication.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , client_id : str , client_secret : str , alg : str = \"HS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `ClientSecretJwt` Auth Handler. :param client_id: the `client_id` to use. :param client_secret: the `client_secret` to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . client_secret = str ( client_secret ) client_assertion ( audience ) \u00b6 Generate a Client Assertion, symmetrically signed with the client_secret as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion, as str . Source code in requests_oauth2client/client_authentication.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, symmetrically signed with the `client_secret` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwk = SymmetricJwk . from_bytes ( self . client_secret . encode ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = jwk , alg = self . alg , ) return str ( jwt ) ClientSecretPost \u00b6 Bases: BaseClientAuthenticationMethod Implement client_secret_post client authentication method (client_id and client_secret passed as part of the request form data). Source code in requests_oauth2client/client_authentication.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class ClientSecretPost ( BaseClientAuthenticationMethod ): \"\"\"Implement `client_secret_post` client authentication method (client_id and client_secret passed as part of the request form data).\"\"\" def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretPost` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret ) def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` and `client_secret` parameters in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added client credentials fields. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id ), ( \"client_secret\" , self . client_secret )]) request . prepare_body ( data . params , files = None ) return request __call__ ( request ) \u00b6 Add the client_id and client_secret parameters in the request body. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added client credentials fields. Source code in requests_oauth2client/client_authentication.py 82 83 84 85 86 87 88 89 90 91 92 93 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` and `client_secret` parameters in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added client credentials fields. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id ), ( \"client_secret\" , self . client_secret )]) request . prepare_body ( data . params , files = None ) return request __init__ ( client_id , client_secret ) \u00b6 Initialize a ClientSecretPost Auth Handler. :param client_id: client_id to use. :param client_secret: client_secret to use. Source code in requests_oauth2client/client_authentication.py 72 73 74 75 76 77 78 79 80 def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretPost` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret ) PrivateKeyJwt \u00b6 Bases: ClientAssertionAuthenticationMethod Implement private_key_jwt client authentication method (client_assertion asymmetrically signed with a private key). Source code in requests_oauth2client/client_authentication.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 class PrivateKeyJwt ( ClientAssertionAuthenticationMethod ): \"\"\"Implement `private_key_jwt` client authentication method (client_assertion asymmetrically signed with a private key).\"\"\" def __init__ ( self , client_id : str , private_jwk : Union [ Jwk , Dict [ str , Any ]], alg : str = \"RS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `PrivateKeyJwt` Auth Handler. :param client_id: the `client_id` to use. :param private_jwk: the private JWK to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" if not isinstance ( private_jwk , Jwk ): private_jwk = Jwk ( private_jwk ) alg = private_jwk . alg or alg if not alg : raise ValueError ( \"Asymmetric signing requires an alg, either as part of the private JWK, or passed as parameter\" ) kid = private_jwk . get ( \"kid\" ) if not kid : raise ValueError ( \"Asymmetric signing requires a kid, either as part of the private JWK, or passed as parameter\" ) super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . private_jwk = private_jwk def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, asumetrically signed with `private_jwk` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = self . private_jwk , alg = self . alg , ) return str ( jwt ) __init__ ( client_id , private_jwk , alg = 'RS256' , lifetime = 60 , jti_gen = lambda : uuid4 ()) \u00b6 Initialize a PrivateKeyJwt Auth Handler. :param client_id: the client_id to use. :param private_jwk: the private JWK to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids ( jti ) for generated Client Assertions. Source code in requests_oauth2client/client_authentication.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def __init__ ( self , client_id : str , private_jwk : Union [ Jwk , Dict [ str , Any ]], alg : str = \"RS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `PrivateKeyJwt` Auth Handler. :param client_id: the `client_id` to use. :param private_jwk: the private JWK to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" if not isinstance ( private_jwk , Jwk ): private_jwk = Jwk ( private_jwk ) alg = private_jwk . alg or alg if not alg : raise ValueError ( \"Asymmetric signing requires an alg, either as part of the private JWK, or passed as parameter\" ) kid = private_jwk . get ( \"kid\" ) if not kid : raise ValueError ( \"Asymmetric signing requires a kid, either as part of the private JWK, or passed as parameter\" ) super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . private_jwk = private_jwk client_assertion ( audience ) \u00b6 Generate a Client Assertion, asumetrically signed with private_jwk as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion. Source code in requests_oauth2client/client_authentication.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, asumetrically signed with `private_jwk` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = self . private_jwk , alg = self . alg , ) return str ( jwt ) PublicApp \u00b6 Bases: BaseClientAuthenticationMethod Implement the none authentication method for public apps (where the client only sends its client_id). Source code in requests_oauth2client/client_authentication.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 class PublicApp ( BaseClientAuthenticationMethod ): \"\"\"Implement the `none` authentication method for public apps (where the client only sends its client_id).\"\"\" def __init__ ( self , client_id : str ) -> None : \"\"\" Initialize a `PublicApp` Auth Handler. :param client_id: the client_id to use. \"\"\" self . client_id = client_id def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_id` field. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id )]) request . prepare_body ( data . params , files = None ) return request __call__ ( request ) \u00b6 Add the client_id field in the request body. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added client_id field. Source code in requests_oauth2client/client_authentication.py 275 276 277 278 279 280 281 282 283 284 285 286 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_id` field. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id )]) request . prepare_body ( data . params , files = None ) return request __init__ ( client_id ) \u00b6 Initialize a PublicApp Auth Handler. :param client_id: the client_id to use. Source code in requests_oauth2client/client_authentication.py 267 268 269 270 271 272 273 def __init__ ( self , client_id : str ) -> None : \"\"\" Initialize a `PublicApp` Auth Handler. :param client_id: the client_id to use. \"\"\" self . client_id = client_id client_auth_factory ( auth , default_auth_handler = ClientSecretPost ) \u00b6 Initialize the appropriate Auth Handler based on the provided parameters. This initializes a ClientAuthenticationMethod subclass based on the provided parameters. :param auth: Can be a :class: requests.auth.AuthBase instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize, by default, an instance of default_auth_handler , a (client_id, jwk) to initialize a :class: PrivateKeyJWK , or a client_id which will use :class: PublicApp authentication. :param default_auth_handler: if auth is a tuple of two string, consider that they are a client_id and client_secret, and initialize an instance of this class with those 2 parameters. :return: an Auth Handler that will manage client authentication to the AS Token Endpoint or other backend endpoints. Source code in requests_oauth2client/client_authentication.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def client_auth_factory ( auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], Tuple [ str , Jwk ], str ], default_auth_handler : Union [ Type [ ClientSecretPost ], Type [ ClientSecretBasic ], Type [ ClientSecretJwt ] ] = ClientSecretPost , ) -> requests . auth . AuthBase : \"\"\" Initialize the appropriate Auth Handler based on the provided parameters. This initializes a `ClientAuthenticationMethod` subclass based on the provided parameters. :param auth: Can be a :class:`requests.auth.AuthBase` instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize, by default, an instance of `default_auth_handler`, a (client_id, jwk) to initialize a :class:`PrivateKeyJWK`, or a `client_id` which will use :class:`PublicApp` authentication. :param default_auth_handler: if auth is a tuple of two string, consider that they are a client_id and client_secret, and initialize an instance of this class with those 2 parameters. :return: an Auth Handler that will manage client authentication to the AS Token Endpoint or other backend endpoints. \"\"\" if isinstance ( auth , requests . auth . AuthBase ): return auth elif isinstance ( auth , tuple ) and len ( auth ) == 2 : client_id , credential = auth if isinstance ( credential , Jwk ): private_jwk = credential return PrivateKeyJwt ( str ( client_id ), private_jwk ) else : return default_auth_handler ( str ( client_id ), credential ) elif isinstance ( auth , str ): client_id = auth return PublicApp ( client_id ) else : raise ValueError ( \"\"\"Parameter 'auth' is required to define the Authentication Method that this Client will use when sending requests to the Token Endpoint. 'auth' can be: - an instance of a requests.auth.AuthBase subclass, including ClientSecretPost, ClientSecretBasic, ClientSecretJwt, PrivateKeyJwt, PublicApp, - a (client_id, client_secret) tuple, both as str, for ClientSecretPost, - a (client_id, private_key) tuple, with client_id as str and private_key as a dict in JWK format, for PrivateKeyJwt, - a client_id, as str, for PublicApp. \"\"\" ) device_authorization \u00b6 Implements the Device Authorization Flow as defined in RFC8628 . DeviceAuthorizationPoolingJob \u00b6 Bases: TokenEndpointPoolingJob A pooling job for checking if the user has finished with his authorization in a Device Authorization flow. Usage: 1 2 3 4 5 6 7 8 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , auth = ( \"client_id\" , \"client_secret\" ) ) pool_job = DeviceAuthorizationPoolingJob ( client = client , device_code = \"my_device_code\" ) token = None while token is None : token = pool_job () Source code in requests_oauth2client/device_authorization.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class DeviceAuthorizationPoolingJob ( TokenEndpointPoolingJob ): \"\"\" A pooling job for checking if the user has finished with his authorization in a Device Authorization flow. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\") ) pool_job = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\") token = None while token is None: token = pool_job() ``` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , device_code : Union [ str , DeviceAuthorizationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `DeviceAuthorizationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . device_code = device_code def token_request ( self ) -> BearerToken : \"\"\" Implement the Device Code token request. This actually calls [OAuth2Client.device_code(device_code)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . device_code ( self . device_code , requests_kwargs = self . requests_kwargs , ** self . token_kwargs ) __init__ ( client , device_code , interval = None , slow_down_interval = 5 , requests_kwargs = None , ** token_kwargs ) \u00b6 Initialize a DeviceAuthorizationPoolingJob . :param client: an OAuth2Client that will be used to pool the token endpoint. :param device_code: a device_code as str or a DeviceAuthorizationResponse . :param interval: The pooling interval to use. This overrides the one in auth_req_id if it is a BackChannelAuthenticationResponse . :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to requests.request . :param token_kwargs: Additional parameters for the token request. Source code in requests_oauth2client/device_authorization.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , client : \"OAuth2Client\" , device_code : Union [ str , DeviceAuthorizationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `DeviceAuthorizationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . device_code = device_code token_request () \u00b6 Implement the Device Code token request. This actually calls [OAuth2Client.device_code(device_code)] on client . :return: a BearerToken Source code in requests_oauth2client/device_authorization.py 105 106 107 108 109 110 111 112 113 114 def token_request ( self ) -> BearerToken : \"\"\" Implement the Device Code token request. This actually calls [OAuth2Client.device_code(device_code)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . device_code ( self . device_code , requests_kwargs = self . requests_kwargs , ** self . token_kwargs ) DeviceAuthorizationResponse \u00b6 Represent a response returned by the device Authorization Endpoint. Source code in requests_oauth2client/device_authorization.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class DeviceAuthorizationResponse : \"\"\"Represent a response returned by the device Authorization Endpoint.\"\"\" @accepts_expires_in def __init__ ( self , device_code : str , user_code : str , verification_uri : str , verification_uri_complete : Optional [ str ] = None , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = None , ** kwargs : Any , ): \"\"\" Initialize a DeviceAuthorizationResponse. All parameters are those returned by the AS as response to a Device Authorization Request. :param device_code: the `device_code` as returned by the AS. :param user_code: the `device_code` as returned by the AS. :param verification_uri: the `device_code` as returned by the AS. :param verification_uri_complete: the `device_code` as returned by the AS. :param expires_at: the expiration date for the device_code. This method also accepts an `expires_in` parameter, as a number of seconds in the future. :param interval: the pooling `interval` as returned by the AS. :param kwargs: additional parameters as returned by the AS. \"\"\" self . device_code = device_code self . user_code = user_code self . verification_uri = verification_uri self . verification_uri_complete = verification_uri_complete self . expires_at = expires_at self . interval = interval self . other = kwargs def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the `device_code` within this response is expired at the time of the call. :return: `True` if the device_code is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None __init__ ( device_code , user_code , verification_uri , verification_uri_complete = None , expires_at = None , interval = None , ** kwargs ) \u00b6 Initialize a DeviceAuthorizationResponse. All parameters are those returned by the AS as response to a Device Authorization Request. :param device_code: the device_code as returned by the AS. :param user_code: the device_code as returned by the AS. :param verification_uri: the device_code as returned by the AS. :param verification_uri_complete: the device_code as returned by the AS. :param expires_at: the expiration date for the device_code. This method also accepts an expires_in parameter, as a number of seconds in the future. :param interval: the pooling interval as returned by the AS. :param kwargs: additional parameters as returned by the AS. Source code in requests_oauth2client/device_authorization.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @accepts_expires_in def __init__ ( self , device_code : str , user_code : str , verification_uri : str , verification_uri_complete : Optional [ str ] = None , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = None , ** kwargs : Any , ): \"\"\" Initialize a DeviceAuthorizationResponse. All parameters are those returned by the AS as response to a Device Authorization Request. :param device_code: the `device_code` as returned by the AS. :param user_code: the `device_code` as returned by the AS. :param verification_uri: the `device_code` as returned by the AS. :param verification_uri_complete: the `device_code` as returned by the AS. :param expires_at: the expiration date for the device_code. This method also accepts an `expires_in` parameter, as a number of seconds in the future. :param interval: the pooling `interval` as returned by the AS. :param kwargs: additional parameters as returned by the AS. \"\"\" self . device_code = device_code self . user_code = user_code self . verification_uri = verification_uri self . verification_uri_complete = verification_uri_complete self . expires_at = expires_at self . interval = interval self . other = kwargs is_expired ( leeway = 0 ) \u00b6 Check if the device_code within this response is expired at the time of the call. :return: True if the device_code is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client/device_authorization.py 49 50 51 52 53 54 55 56 57 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the `device_code` within this response is expired at the time of the call. :return: `True` if the device_code is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None discovery \u00b6 Implements Metadata discovery documents, as specified in RFC8615 and OpenID Connect Discovery 1.0 . oauth2_discovery_document_url ( issuer ) \u00b6 Given an issuer identifier, return the standardised URL where the OAuth20 server metadata can be retrieved. The returned URL is built as specified in RFC8414 . :param issuer: an OAuth20 Authentication Server issuer :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client/discovery.py 35 36 37 38 39 40 41 42 43 def oauth2_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OAuth20 server metadata can be retrieved. The returned URL is built as specified in [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). :param issuer: an OAuth20 Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"oauth-authorization-server\" , at_root = True ) oidc_discovery_document_url ( issuer ) \u00b6 Given an issuer identifier, return the standardised URL where the OIDC discovery document can be retrieved. The returned URL is biuilt as specified in OpenID Connect Discovery 1.0 . :param issuer: an OIDC Authentication Server issuer :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client/discovery.py 24 25 26 27 28 29 30 31 32 def oidc_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can be retrieved. The returned URL is biuilt as specified in [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). :param issuer: an OIDC Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"openid-configuration\" , at_root = False ) well_known_uri ( origin , name , at_root = True ) \u00b6 Return the location of a well-known document on an origin, according to RFC8615 . :param origin: origin to use to build the well-known uri. :param name: document name to use to build the well-known uri. :param at_root: if True , assume the well-known document is at root level (as defined in RFC8615 ). If False , assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0 . :return: the well-know uri, relative to origin, where the well-known document named name should be found. Source code in requests_oauth2client/discovery.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def well_known_uri ( origin : str , name : str , at_root : bool = True ) -> str : \"\"\" Return the location of a well-known document on an origin, according to [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615). :param origin: origin to use to build the well-known uri. :param name: document name to use to build the well-known uri. :param at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)). If `False`, assume the well-known location is per-directory, as defined in [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). :return: the well-know uri, relative to origin, where the well-known document named `name` should be found. \"\"\" url = furl ( origin ) if at_root : url . path = Path ( \".well-known\" ) / url . path / name else : url . path . add ( Path ( \".well-known\" ) / name ) return str ( url ) exceptions \u00b6 This module contains all exceptions that can be raised by methods from requests_oauth2client . AccessDenied \u00b6 Bases: EndpointError Raised when the Authorization Server returns error = access_denied . Source code in requests_oauth2client/exceptions.py 64 65 class AccessDenied ( EndpointError ): \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\" AccountSelectionRequired \u00b6 Bases: InteractionRequired Raised when the Authorization Endpoint returns error = account_selection_required . Source code in requests_oauth2client/exceptions.py 140 141 class AccountSelectionRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\" AuthorizationPending \u00b6 Bases: TokenEndpointError Raised when the Token Endpoint returns error = authorization_pending . Source code in requests_oauth2client/exceptions.py 92 93 class AuthorizationPending ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\" AuthorizationResponseError \u00b6 Bases: Exception Base class for error responses returned by the Authorization endpoint. Source code in requests_oauth2client/exceptions.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class AuthorizationResponseError ( Exception ): \"\"\"Base class for error responses returned by the Authorization endpoint.\"\"\" def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `AuthorizationResponseError`. An `AuthorizationResponseError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri __init__ ( error , description = None , uri = None ) \u00b6 Initialize an AuthorizationResponseError . An AuthorizationResponseError contains the error message, description and uri that are returned by the AS. :param error: the error identifier as returned by the AS :param description: the error_description as returned by the AS :param uri: the error_uri as returned by the AS Source code in requests_oauth2client/exceptions.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `AuthorizationResponseError`. An `AuthorizationResponseError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri BackChannelAuthenticationError \u00b6 Bases: EndpointError Base class for errors returned by the BackChannel Authentication endpoint. Source code in requests_oauth2client/exceptions.py 168 169 class BackChannelAuthenticationError ( EndpointError ): \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\" ConsentRequired \u00b6 Bases: InteractionRequired Raised when the Authorization Endpoint returns error = consent_required . Source code in requests_oauth2client/exceptions.py 148 149 class ConsentRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\" DeviceAuthorizationError \u00b6 Bases: EndpointError Base class for Device Authorization Endpoint errors. Source code in requests_oauth2client/exceptions.py 88 89 class DeviceAuthorizationError ( EndpointError ): \"\"\"Base class for Device Authorization Endpoint errors.\"\"\" EndpointError \u00b6 Bases: OAuth2Error Base class for exceptions raised when a token endpoint returns a standardised error. Source code in requests_oauth2client/exceptions.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class EndpointError ( OAuth2Error ): \"\"\"Base class for exceptions raised when a token endpoint returns a standardised error.\"\"\" def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `EndpointError`. An `EndpointError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri __init__ ( error , description = None , uri = None ) \u00b6 Initialize an EndpointError . An EndpointError contains the error message, description and uri that are returned by the AS. :param error: the error identifier as returned by the AS :param description: the error_description as returned by the AS :param uri: the error_uri as returned by the AS Source code in requests_oauth2client/exceptions.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `EndpointError`. An `EndpointError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri ExpiredAccessToken \u00b6 Bases: OAuth2Error Raised when an expired access token is used. Source code in requests_oauth2client/exceptions.py 36 37 class ExpiredAccessToken ( OAuth2Error ): \"\"\"Raised when an expired access token is used.\"\"\" ExpiredToken \u00b6 Bases: TokenEndpointError Raised when the Token Endpoint returns error = expired_token . Source code in requests_oauth2client/exceptions.py 100 101 class ExpiredToken ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\" InteractionRequired \u00b6 Bases: AuthorizationResponseError Raised when the Authorization Endpoint returns error = interaction_required . Source code in requests_oauth2client/exceptions.py 132 133 class InteractionRequired ( AuthorizationResponseError ): \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\" IntrospectionError \u00b6 Bases: EndpointError Base class for Introspection Endpoint errors. Source code in requests_oauth2client/exceptions.py 80 81 class IntrospectionError ( EndpointError ): \"\"\"Base class for Introspection Endpoint errors.\"\"\" InvalidAuthResponse \u00b6 Bases: OAuth2Error Base class for errors due to Auth Responses that don't obey the standard (e.g. missing mandatory params). Source code in requests_oauth2client/exceptions.py 152 153 class InvalidAuthResponse ( OAuth2Error ): \"\"\"Base class for errors due to Auth Responses that don't obey the standard (e.g. missing mandatory params).\"\"\" InvalidBackChannelAuthenticationResponse \u00b6 Bases: OAuth2Error Raised when the BackChannel Authentication endpoint returns non-standardised errors. Source code in requests_oauth2client/exceptions.py 172 173 class InvalidBackChannelAuthenticationResponse ( OAuth2Error ): \"\"\"Raised when the BackChannel Authentication endpoint returns non-standardised errors.\"\"\" InvalidDeviceAuthorizationResponse \u00b6 Bases: OAuth2Error Raised when the Device Authorization Endpoint returns a non-standard error response. Source code in requests_oauth2client/exceptions.py 104 105 class InvalidDeviceAuthorizationResponse ( OAuth2Error ): \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\" InvalidGrant \u00b6 Bases: TokenEndpointError Raised when the Token Endpoint returns error = invalid_grant . Source code in requests_oauth2client/exceptions.py 60 61 class InvalidGrant ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\" InvalidIdToken \u00b6 Bases: InvalidJwt Raised when trying to validate an invalid Id Token value. Source code in requests_oauth2client/exceptions.py 108 109 class InvalidIdToken ( InvalidJwt ): \"\"\"Raised when trying to validate an invalid Id Token value.\"\"\" InvalidPushedAuthorizationResponse \u00b6 Bases: OAuth2Error Raised when the Pushed Authorization Endpoint returns an error. Source code in requests_oauth2client/exceptions.py 176 177 class InvalidPushedAuthorizationResponse ( OAuth2Error ): \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\" InvalidScope \u00b6 Bases: TokenEndpointError Raised when the Token Endpoint returns error = invalid_scope . Source code in requests_oauth2client/exceptions.py 52 53 class InvalidScope ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\" InvalidTarget \u00b6 Bases: TokenEndpointError Raised when the Token Endpoint returns error = invalid_target . Source code in requests_oauth2client/exceptions.py 56 57 class InvalidTarget ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\" InvalidTokenResponse \u00b6 Bases: OAuth2Error Base class for exceptions raised when a token endpoint returns a non-standardised response. Source code in requests_oauth2client/exceptions.py 32 33 class InvalidTokenResponse ( OAuth2Error ): \"\"\"Base class for exceptions raised when a token endpoint returns a non-standardised response.\"\"\" LoginRequired \u00b6 Bases: InteractionRequired Raised when the Authorization Endpoint returns error = login_required . Source code in requests_oauth2client/exceptions.py 136 137 class LoginRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\" MismatchingIssuer \u00b6 Bases: InvalidAuthResponse Raised when an auth response contains an 'iss' parameter that doesn't match the expected value. Source code in requests_oauth2client/exceptions.py 164 165 class MismatchingIssuer ( InvalidAuthResponse ): \"\"\"Raised when an auth response contains an 'iss' parameter that doesn't match the expected value.\"\"\" MismatchingState \u00b6 Bases: InvalidAuthResponse Raised when an auth response contains a 'state' parameter that doesn't match the expected value. Source code in requests_oauth2client/exceptions.py 160 161 class MismatchingState ( InvalidAuthResponse ): \"\"\"Raised when an auth response contains a 'state' parameter that doesn't match the expected value.\"\"\" MissingAuthCode \u00b6 Bases: InvalidAuthResponse Raised when the authorization code is missing from the auth response and no error is returned. Source code in requests_oauth2client/exceptions.py 156 157 class MissingAuthCode ( InvalidAuthResponse ): \"\"\"Raised when the authorization code is missing from the auth response and no error is returned.\"\"\" OAuth2Error \u00b6 Bases: Exception Base class for Exceptions raised by requests_oauth2client. Source code in requests_oauth2client/exceptions.py 8 9 class OAuth2Error ( Exception ): \"\"\"Base class for Exceptions raised by requests_oauth2client.\"\"\" RevocationError \u00b6 Bases: EndpointError Base class for Revocation Endpoint errors. Source code in requests_oauth2client/exceptions.py 72 73 class RevocationError ( EndpointError ): \"\"\"Base class for Revocation Endpoint errors.\"\"\" ServerError \u00b6 Bases: EndpointError Raised when the token endpoint returns error = server_error . Source code in requests_oauth2client/exceptions.py 44 45 class ServerError ( EndpointError ): \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\" SessionSelectionRequired \u00b6 Bases: InteractionRequired Raised when the Authorization Endpoint returns error = session_selection_required . Source code in requests_oauth2client/exceptions.py 144 145 class SessionSelectionRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\" SlowDown \u00b6 Bases: TokenEndpointError Raised when the Token Endpoint returns error = slow_down . Source code in requests_oauth2client/exceptions.py 96 97 class SlowDown ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\" TokenEndpointError \u00b6 Bases: EndpointError Base class for errors that are specific to the token endpoint. Source code in requests_oauth2client/exceptions.py 48 49 class TokenEndpointError ( EndpointError ): \"\"\"Base class for errors that are specific to the token endpoint.\"\"\" UnauthorizedClient \u00b6 Bases: EndpointError Raised when the Authorization Server returns error = unauthorized_client . Source code in requests_oauth2client/exceptions.py 68 69 class UnauthorizedClient ( EndpointError ): \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\" UnknownIntrospectionError \u00b6 Bases: OAuth2Error Raised when the Introspection Endpoint retuns a non-standard error. Source code in requests_oauth2client/exceptions.py 84 85 class UnknownIntrospectionError ( OAuth2Error ): \"\"\"Raised when the Introspection Endpoint retuns a non-standard error.\"\"\" UnknownTokenEndpointError \u00b6 Bases: EndpointError Raised when an otherwise unknown error is returned by the token endpoint. Source code in requests_oauth2client/exceptions.py 40 41 class UnknownTokenEndpointError ( EndpointError ): \"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\" UnsupportedTokenType \u00b6 Bases: RevocationError Raised when the Revocation endpoint returns error = unsupported_token_type . Source code in requests_oauth2client/exceptions.py 76 77 class UnsupportedTokenType ( RevocationError ): \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\" flask \u00b6 This modules contains helper classes for the Flask framework. auth \u00b6 Helper classes for the Flask framework. FlaskOAuth2ClientCredentialsAuth \u00b6 Bases: FlaskSessionAuthMixin , OAuth2ClientCredentialsAuth A Flask-specific requests Authentication handler that fetches Access Tokens using the Client Credentials Grant. It will automatically gets access tokens from an OAuth 2.x Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask session , so that each user has a different access token. Source code in requests_oauth2client/flask/auth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class FlaskOAuth2ClientCredentialsAuth ( FlaskSessionAuthMixin , OAuth2ClientCredentialsAuth ): \"\"\" A Flask-specific `requests` Authentication handler that fetches Access Tokens using the Client Credentials Grant. It will automatically gets access tokens from an OAuth 2.x Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask `session`, so that each user has a different access token. \"\"\" def __init__ ( self , client : OAuth2Client , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize a `FlaskOAuth2ClientCredentialsAuth`. :param client: an OAuth2Client that will be used to retrieve tokens. :param session_key: the key that will be used to store the access token in Flask session :param serializer: a serializer that will be used to serialize the access token in Flask session :param token_kwargs: additional kwargs for the Token Request \"\"\" super () . __init__ ( session_key , serializer ) self . client = client self . token_kwargs = token_kwargs __init__ ( client , session_key , serializer = None , ** token_kwargs ) \u00b6 Initialize a FlaskOAuth2ClientCredentialsAuth . :param client: an OAuth2Client that will be used to retrieve tokens. :param session_key: the key that will be used to store the access token in Flask session :param serializer: a serializer that will be used to serialize the access token in Flask session :param token_kwargs: additional kwargs for the Token Request Source code in requests_oauth2client/flask/auth.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , client : OAuth2Client , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize a `FlaskOAuth2ClientCredentialsAuth`. :param client: an OAuth2Client that will be used to retrieve tokens. :param session_key: the key that will be used to store the access token in Flask session :param serializer: a serializer that will be used to serialize the access token in Flask session :param token_kwargs: additional kwargs for the Token Request \"\"\" super () . __init__ ( session_key , serializer ) self . client = client self . token_kwargs = token_kwargs FlaskSessionAuthMixin \u00b6 A Mixin for auth handlers to store their tokens in Flask session. Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens will be persisted between multiple requests to the front-end Flask app. Source code in requests_oauth2client/flask/auth.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class FlaskSessionAuthMixin : \"\"\" A Mixin for auth handlers to store their tokens in Flask session. Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens will be persisted between multiple requests to the front-end Flask app. \"\"\" def __init__ ( self , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None ): \"\"\" Initialize a FlaskSessionAuthMixin. :param session_key: the key that will be used to store the access token in session. :param serializer: the serializer that will be used to store the access token in session. \"\"\" self . serializer = serializer or BearerTokenSerializer () self . session_key = session_key @property def token ( self ) -> Optional [ BearerToken ]: \"\"\"Return the Access Token stored in session.\"\"\" serialized_token = session . get ( self . session_key ) if serialized_token is None : return None return self . serializer . loads ( serialized_token ) @token . setter def token ( self , token : Optional [ BearerToken ]) -> None : \"\"\" Store an Access Token in session. :param token: the token to store \"\"\" if token : serialized_token = self . serializer . dumps ( token ) session [ self . session_key ] = serialized_token else : session . pop ( self . session_key , None ) __init__ ( session_key , serializer = None ) \u00b6 Initialize a FlaskSessionAuthMixin. :param session_key: the key that will be used to store the access token in session. :param serializer: the serializer that will be used to store the access token in session. Source code in requests_oauth2client/flask/auth.py 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None ): \"\"\" Initialize a FlaskSessionAuthMixin. :param session_key: the key that will be used to store the access token in session. :param serializer: the serializer that will be used to store the access token in session. \"\"\" self . serializer = serializer or BearerTokenSerializer () self . session_key = session_key token () writable property \u00b6 Return the Access Token stored in session. Source code in requests_oauth2client/flask/auth.py 31 32 33 34 35 36 37 @property def token ( self ) -> Optional [ BearerToken ]: \"\"\"Return the Access Token stored in session.\"\"\" serialized_token = session . get ( self . session_key ) if serialized_token is None : return None return self . serializer . loads ( serialized_token ) pooling \u00b6 Base classes for pooling jobs, that call an endpoint at regular interval to obtain some response. TokenEndpointPoolingJob \u00b6 Bases: ABC Base class for Token Endpoint pooling jobs on decoupled flows like CIBA or Device Authorization. This class must be subclassed to implement actual BackChannel flows. Source code in requests_oauth2client/pooling.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class TokenEndpointPoolingJob ( ABC ): \"\"\" Base class for Token Endpoint pooling jobs on decoupled flows like CIBA or Device Authorization. This class must be subclassed to implement actual BackChannel flows. \"\"\" def __init__ ( self , client : \"OAuth2Client\" , interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `TokenEndpointPoolingJob`. This needs an [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. The initial pooling `interval` is configurable. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. :param interval: initial pooling interval, in seconds. If `None`, default to `5`. :param slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is received, this number of seconds will be added to the pooling interval. :param requests_kwargs: additional parameters for the underlying calls to [requests.request][] :param token_kwargs: additional parameters for the token request \"\"\" self . client = client self . interval = interval or 5 self . slow_down_interval = slow_down_interval self . requests_kwargs = requests_kwargs self . token_kwargs = token_kwargs def __call__ ( self ) -> Optional [ BearerToken ]: \"\"\" Wrap the actual Token Endpoint call with a pooling interval. Everytime this method is called, it will wait for the entire duration of the pooling interval before calling [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So you can call it immediately after initiating the BackChannel flow, and it will wait before initiating the first call. This implements the logic to handle [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or `None` if the Authorization is still pending. \"\"\" time . sleep ( self . interval ) try : return self . token_request () except SlowDown : self . interval += self . slow_down_interval except AuthorizationPending : pass return None @abstractmethod def token_request ( self ) -> BearerToken : \"\"\" Abstract method for the token endpoint call. This must be implemented by subclasses. This method must Must raise [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase the pooling interval by `slow_down_interval` seconds. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" raise NotImplementedError # pragma: no cover __call__ () \u00b6 Wrap the actual Token Endpoint call with a pooling interval. Everytime this method is called, it will wait for the entire duration of the pooling interval before calling token_request() . So you can call it immediately after initiating the BackChannel flow, and it will wait before initiating the first call. This implements the logic to handle AuthorizationPending or SlowDown requests by the AS. :return: a BearerToken if the AS returns one, or None if the Authorization is still pending. Source code in requests_oauth2client/pooling.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __call__ ( self ) -> Optional [ BearerToken ]: \"\"\" Wrap the actual Token Endpoint call with a pooling interval. Everytime this method is called, it will wait for the entire duration of the pooling interval before calling [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So you can call it immediately after initiating the BackChannel flow, and it will wait before initiating the first call. This implements the logic to handle [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or `None` if the Authorization is still pending. \"\"\" time . sleep ( self . interval ) try : return self . token_request () except SlowDown : self . interval += self . slow_down_interval except AuthorizationPending : pass return None __init__ ( client , interval = None , slow_down_interval = 5 , requests_kwargs = None , ** token_kwargs ) \u00b6 Initialize a TokenEndpointPoolingJob . This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling interval is configurable. :param client: the OAuth2Client that will be used to pool the token endpoint. :param interval: initial pooling interval, in seconds. If None , default to 5 . :param slow_down_interval: when a SlowDown is received, this number of seconds will be added to the pooling interval. :param requests_kwargs: additional parameters for the underlying calls to requests.request :param token_kwargs: additional parameters for the token request Source code in requests_oauth2client/pooling.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , client : \"OAuth2Client\" , interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `TokenEndpointPoolingJob`. This needs an [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. The initial pooling `interval` is configurable. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. :param interval: initial pooling interval, in seconds. If `None`, default to `5`. :param slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is received, this number of seconds will be added to the pooling interval. :param requests_kwargs: additional parameters for the underlying calls to [requests.request][] :param token_kwargs: additional parameters for the token request \"\"\" self . client = client self . interval = interval or 5 self . slow_down_interval = slow_down_interval self . requests_kwargs = requests_kwargs self . token_kwargs = token_kwargs token_request () abstractmethod \u00b6 Abstract method for the token endpoint call. This must be implemented by subclasses. This method must Must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by slow_down_interval seconds. :return: a BearerToken Source code in requests_oauth2client/pooling.py 68 69 70 71 72 73 74 75 76 77 78 79 @abstractmethod def token_request ( self ) -> BearerToken : \"\"\" Abstract method for the token endpoint call. This must be implemented by subclasses. This method must Must raise [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase the pooling interval by `slow_down_interval` seconds. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" raise NotImplementedError # pragma: no cover tokens \u00b6 This modules contain classes that represent Tokens used in OAuth2.0 / OIDC. BearerToken \u00b6 Represents a Bearer Token and its associated parameters as returned by a Token Endpoint. This is a wrapper around a Bearer Token and associated expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint. Source code in requests_oauth2client/tokens.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class BearerToken : \"\"\" Represents a Bearer Token and its associated parameters as returned by a Token Endpoint. This is a wrapper around a Bearer Token and associated expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint. \"\"\" @accepts_expires_in def __init__ ( self , access_token : str , * , expires_at : Optional [ datetime ] = None , scope : Optional [ str ] = None , refresh_token : Optional [ str ] = None , token_type : str = \"Bearer\" , id_token : Optional [ str ] = None , ** kwargs : Any , ): \"\"\" Initialize a BearerToken. All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in the future, can be passed instead. :param access_token: an `access_token`, as returned by the AS. :param expires_at: an expiration date. This method also accepts an `expires_in` hint as returned by the AS, if any. :param scope: a `scope`, as returned by the AS, if any. :param refresh_token: a `refresh_token`, as returned by the AS, if any. :param token_type: a `token_type`, as returned by the AS. :param id_token: an `id_token`, as returned by the AS, if any. :param kwargs: additional parameters as returned by the AS, if any. \"\"\" if token_type . title () != \"Bearer\" : raise ValueError ( \"This is not a Bearer Token!\" , token_type ) self . access_token = access_token self . expires_at = expires_at self . scope = scope self . refresh_token = refresh_token self . id_token = IdToken ( id_token ) if id_token else None self . other = kwargs def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the access token is expired. Returns `True` if the access token is expired at the time of the call. :param leeway: If the token expires in the next given number of seconds, then consider it expired already. :return: `True` if the access token is expired, `False` if it is still valid, `None` if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None def authorization_header ( self ) -> str : \"\"\" Return the Authorization Header value containing this access token, correctly formatted according to RFC6750. :return: the value to use in a HTTP Authorization Header \"\"\" return f \"Bearer { self . access_token } \" def __str__ ( self ) -> str : \"\"\" Return the access token value, as a string. :return: the access token string \"\"\" return self . access_token def __contains__ ( self , key : str ) -> bool : \"\"\" Check existence of a key in the token response. Allows testing like `assert \"refresh_token\" in token_response`. :param key: a key :return: True if the key exists in the token response, False otherwise \"\"\" if key == \"access_token\" : return True elif key == \"refresh_token\" : return self . refresh_token is not None elif key == \"scope\" : return self . scope is not None elif key == \"token_type\" : return True elif key == \"expires_in\" : return self . expires_at is not None else : return key in self . other def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this BearerToken. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not found in this response. \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) elif key == \"token_type\" : return \"Bearer\" return self . other . get ( key ) or super () . __getattribute__ ( key ) def as_dict ( self , expires_at : bool = False ) -> Dict [ str , Any ]: \"\"\" Return all the attributes from this BearerToken as a `dict`. :param expires_at: if `True`, the dict will contain an extra `expires_at` field with the token expiration date. :return: a `dict` containing this BearerToken attributes. \"\"\" r : Dict [ str , Any ] = { \"access_token\" : self . access_token , \"token_type\" : \"Bearer\" , } if self . expires_at : r [ \"expires_in\" ] = self . expires_in if expires_at : r [ \"expires_at\" ] = self . expires_at if self . scope : r [ \"scope\" ] = self . scope if self . refresh_token : r [ \"refresh_token\" ] = self . refresh_token if self . other : r . update ( self . other ) return r def __repr__ ( self ) -> str : \"\"\" Return a representation of this BearerToken. This representation is a pretty formatted `dict` that looks like a Token Endpoint response. :return: a `str` representation of this BearerToken. \"\"\" return pprint . pformat ( self . as_dict ()) def __eq__ ( self , other : object ) -> bool : \"\"\" Check if this BearerToken is equal to another. It supports comparison with another BearerToken, or with an `access_token` as `str`. :param other: another token to compare to :return: `True` if equal, `False` otherwise \"\"\" if isinstance ( other , BearerToken ): return ( self . access_token == other . access_token and self . refresh_token == other . refresh_token and self . expires_at == other . expires_at and self . token_type == other . token_type ) elif isinstance ( other , str ): return self . access_token == other return super () . __eq__ ( other ) __contains__ ( key ) \u00b6 Check existence of a key in the token response. Allows testing like assert \"refresh_token\" in token_response . :param key: a key :return: True if the key exists in the token response, False otherwise Source code in requests_oauth2client/tokens.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def __contains__ ( self , key : str ) -> bool : \"\"\" Check existence of a key in the token response. Allows testing like `assert \"refresh_token\" in token_response`. :param key: a key :return: True if the key exists in the token response, False otherwise \"\"\" if key == \"access_token\" : return True elif key == \"refresh_token\" : return self . refresh_token is not None elif key == \"scope\" : return self . scope is not None elif key == \"token_type\" : return True elif key == \"expires_in\" : return self . expires_at is not None else : return key in self . other __eq__ ( other ) \u00b6 Check if this BearerToken is equal to another. It supports comparison with another BearerToken, or with an access_token as str . :param other: another token to compare to :return: True if equal, False otherwise Source code in requests_oauth2client/tokens.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def __eq__ ( self , other : object ) -> bool : \"\"\" Check if this BearerToken is equal to another. It supports comparison with another BearerToken, or with an `access_token` as `str`. :param other: another token to compare to :return: `True` if equal, `False` otherwise \"\"\" if isinstance ( other , BearerToken ): return ( self . access_token == other . access_token and self . refresh_token == other . refresh_token and self . expires_at == other . expires_at and self . token_type == other . token_type ) elif isinstance ( other , str ): return self . access_token == other return super () . __eq__ ( other ) __getattr__ ( key ) \u00b6 Return attributes from this BearerToken. Allows token_response.expires_in or token_response.any_custom_attribute :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not found in this response. Source code in requests_oauth2client/tokens.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this BearerToken. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not found in this response. \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) elif key == \"token_type\" : return \"Bearer\" return self . other . get ( key ) or super () . __getattribute__ ( key ) __init__ ( access_token , * , expires_at = None , scope = None , refresh_token = None , token_type = 'Bearer' , id_token = None , ** kwargs ) \u00b6 Initialize a BearerToken. All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the expires_at parameter, or an expires_in parameter, as number of seconds in the future, can be passed instead. :param access_token: an access_token , as returned by the AS. :param expires_at: an expiration date. This method also accepts an expires_in hint as returned by the AS, if any. :param scope: a scope , as returned by the AS, if any. :param refresh_token: a refresh_token , as returned by the AS, if any. :param token_type: a token_type , as returned by the AS. :param id_token: an id_token , as returned by the AS, if any. :param kwargs: additional parameters as returned by the AS, if any. Source code in requests_oauth2client/tokens.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @accepts_expires_in def __init__ ( self , access_token : str , * , expires_at : Optional [ datetime ] = None , scope : Optional [ str ] = None , refresh_token : Optional [ str ] = None , token_type : str = \"Bearer\" , id_token : Optional [ str ] = None , ** kwargs : Any , ): \"\"\" Initialize a BearerToken. All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in the future, can be passed instead. :param access_token: an `access_token`, as returned by the AS. :param expires_at: an expiration date. This method also accepts an `expires_in` hint as returned by the AS, if any. :param scope: a `scope`, as returned by the AS, if any. :param refresh_token: a `refresh_token`, as returned by the AS, if any. :param token_type: a `token_type`, as returned by the AS. :param id_token: an `id_token`, as returned by the AS, if any. :param kwargs: additional parameters as returned by the AS, if any. \"\"\" if token_type . title () != \"Bearer\" : raise ValueError ( \"This is not a Bearer Token!\" , token_type ) self . access_token = access_token self . expires_at = expires_at self . scope = scope self . refresh_token = refresh_token self . id_token = IdToken ( id_token ) if id_token else None self . other = kwargs __repr__ () \u00b6 Return a representation of this BearerToken. This representation is a pretty formatted dict that looks like a Token Endpoint response. :return: a str representation of this BearerToken. Source code in requests_oauth2client/tokens.py 146 147 148 149 150 151 152 153 154 def __repr__ ( self ) -> str : \"\"\" Return a representation of this BearerToken. This representation is a pretty formatted `dict` that looks like a Token Endpoint response. :return: a `str` representation of this BearerToken. \"\"\" return pprint . pformat ( self . as_dict ()) __str__ () \u00b6 Return the access token value, as a string. :return: the access token string Source code in requests_oauth2client/tokens.py 77 78 79 80 81 82 83 def __str__ ( self ) -> str : \"\"\" Return the access token value, as a string. :return: the access token string \"\"\" return self . access_token as_dict ( expires_at = False ) \u00b6 Return all the attributes from this BearerToken as a dict . :param expires_at: if True , the dict will contain an extra expires_at field with the token expiration date. :return: a dict containing this BearerToken attributes. Source code in requests_oauth2client/tokens.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def as_dict ( self , expires_at : bool = False ) -> Dict [ str , Any ]: \"\"\" Return all the attributes from this BearerToken as a `dict`. :param expires_at: if `True`, the dict will contain an extra `expires_at` field with the token expiration date. :return: a `dict` containing this BearerToken attributes. \"\"\" r : Dict [ str , Any ] = { \"access_token\" : self . access_token , \"token_type\" : \"Bearer\" , } if self . expires_at : r [ \"expires_in\" ] = self . expires_in if expires_at : r [ \"expires_at\" ] = self . expires_at if self . scope : r [ \"scope\" ] = self . scope if self . refresh_token : r [ \"refresh_token\" ] = self . refresh_token if self . other : r . update ( self . other ) return r authorization_header () \u00b6 Return the Authorization Header value containing this access token, correctly formatted according to RFC6750. :return: the value to use in a HTTP Authorization Header Source code in requests_oauth2client/tokens.py 69 70 71 72 73 74 75 def authorization_header ( self ) -> str : \"\"\" Return the Authorization Header value containing this access token, correctly formatted according to RFC6750. :return: the value to use in a HTTP Authorization Header \"\"\" return f \"Bearer { self . access_token } \" is_expired ( leeway = 0 ) \u00b6 Check if the access token is expired. Returns True if the access token is expired at the time of the call. :param leeway: If the token expires in the next given number of seconds, then consider it expired already. :return: True if the access token is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client/tokens.py 56 57 58 59 60 61 62 63 64 65 66 67 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the access token is expired. Returns `True` if the access token is expired at the time of the call. :param leeway: If the token expires in the next given number of seconds, then consider it expired already. :return: `True` if the access token is expired, `False` if it is still valid, `None` if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None BearerTokenSerializer \u00b6 An helper class to serialize Tokens. This may be used to store BearerTokens in session or cookies. Source code in requests_oauth2client/tokens.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 class BearerTokenSerializer : \"\"\"An helper class to serialize Tokens. This may be used to store BearerTokens in session or cookies.\"\"\" def __init__ ( self , dumper : Optional [ Callable [[ BearerToken ], str ]] = None , loader : Optional [ Callable [[ str ], BearerToken ]] = None , ): \"\"\" Initialize a `BearerTokenSerializer`. This needs a `dumper` and a `loader` functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided. :param dumper: a function to serialize a token into a `str`. :param loader: a function do deserialize a serialized token representation. \"\"\" self . dumper = dumper or self . default_dumper self . loader = loader or self . default_loader @staticmethod def default_dumper ( token : BearerToken ) -> str : \"\"\" Serialize a token as JSON, then gzip compress, then encodes as base64url. :param token: the :class:`BearerToken` to serialize :return: the serialized value \"\"\" return ( BinaPy . serialize_to ( \"json\" , token . as_dict ( True )) . to ( \"gzip\" ) . to ( \"b64u\" ) . ascii () ) def default_loader ( self , serialized : str , token_class : Type [ BearerToken ] = BearerToken ) -> BearerToken : \"\"\" Deserialize a BearerToken. Does the opposite operations than `default_dumper`. :param serialized: the serialized token :return: a BearerToken \"\"\" attrs = ( BinaPy ( serialized ) . decode_from ( \"b64u\" ) . decode_from ( \"gzip\" ) . parse_from ( \"json\" ) ) expires_at = attrs . get ( \"expires_at\" ) if expires_at : attrs [ \"expires_at\" ] = datetime . fromtimestamp ( expires_at ) return token_class ( ** attrs ) def dumps ( self , token : BearerToken ) -> str : \"\"\" Serialize and compress a given token for easier storage. :param token: a BearerToken to serialize :return: the serialized token, as a str \"\"\" return self . dumper ( token ) def loads ( self , serialized : str ) -> BearerToken : \"\"\" Deserialize a serialized token. :param serialized: the serialized token :return: the deserialized token \"\"\" return self . loader ( serialized ) __init__ ( dumper = None , loader = None ) \u00b6 Initialize a BearerTokenSerializer . This needs a dumper and a loader functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided. :param dumper: a function to serialize a token into a str . :param loader: a function do deserialize a serialized token representation. Source code in requests_oauth2client/tokens.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def __init__ ( self , dumper : Optional [ Callable [[ BearerToken ], str ]] = None , loader : Optional [ Callable [[ str ], BearerToken ]] = None , ): \"\"\" Initialize a `BearerTokenSerializer`. This needs a `dumper` and a `loader` functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided. :param dumper: a function to serialize a token into a `str`. :param loader: a function do deserialize a serialized token representation. \"\"\" self . dumper = dumper or self . default_dumper self . loader = loader or self . default_loader default_dumper ( token ) staticmethod \u00b6 Serialize a token as JSON, then gzip compress, then encodes as base64url. :param token: the :class: BearerToken to serialize :return: the serialized value Source code in requests_oauth2client/tokens.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @staticmethod def default_dumper ( token : BearerToken ) -> str : \"\"\" Serialize a token as JSON, then gzip compress, then encodes as base64url. :param token: the :class:`BearerToken` to serialize :return: the serialized value \"\"\" return ( BinaPy . serialize_to ( \"json\" , token . as_dict ( True )) . to ( \"gzip\" ) . to ( \"b64u\" ) . ascii () ) default_loader ( serialized , token_class = BearerToken ) \u00b6 Deserialize a BearerToken. Does the opposite operations than default_dumper . :param serialized: the serialized token :return: a BearerToken Source code in requests_oauth2client/tokens.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def default_loader ( self , serialized : str , token_class : Type [ BearerToken ] = BearerToken ) -> BearerToken : \"\"\" Deserialize a BearerToken. Does the opposite operations than `default_dumper`. :param serialized: the serialized token :return: a BearerToken \"\"\" attrs = ( BinaPy ( serialized ) . decode_from ( \"b64u\" ) . decode_from ( \"gzip\" ) . parse_from ( \"json\" ) ) expires_at = attrs . get ( \"expires_at\" ) if expires_at : attrs [ \"expires_at\" ] = datetime . fromtimestamp ( expires_at ) return token_class ( ** attrs ) dumps ( token ) \u00b6 Serialize and compress a given token for easier storage. :param token: a BearerToken to serialize :return: the serialized token, as a str Source code in requests_oauth2client/tokens.py 230 231 232 233 234 235 236 237 def dumps ( self , token : BearerToken ) -> str : \"\"\" Serialize and compress a given token for easier storage. :param token: a BearerToken to serialize :return: the serialized token, as a str \"\"\" return self . dumper ( token ) loads ( serialized ) \u00b6 Deserialize a serialized token. :param serialized: the serialized token :return: the deserialized token Source code in requests_oauth2client/tokens.py 239 240 241 242 243 244 245 246 def loads ( self , serialized : str ) -> BearerToken : \"\"\" Deserialize a serialized token. :param serialized: the serialized token :return: the deserialized token \"\"\" return self . loader ( serialized ) IdToken \u00b6 Bases: SignedJwt Represent an ID Token. An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be prealably decoded. Source code in requests_oauth2client/tokens.py 249 250 251 252 253 254 class IdToken ( SignedJwt ): \"\"\" Represent an ID Token. An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be prealably decoded. \"\"\" utils \u00b6 This module contains helper methods that are used in multiple places within requests_oauth2client . accepts_expires_in ( f ) \u00b6 Decorate methods that accept an expires_at datetime parameter, to also allow an expires_in parameter in seconds. If supplied, expires_in will be converted to a datetime expires_in seconds in the future, and passed as expires_at in the decorated method. :param f: the method to decorate, with an expires_at parameter :return: a decorated method that accepts either expires_in or expires_at . Source code in requests_oauth2client/utils.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def accepts_expires_in ( f : Callable [ ... , Any ]) -> Callable [ ... , Any ]: \"\"\" Decorate methods that accept an `expires_at` datetime parameter, to also allow an `expires_in` parameter in seconds. If supplied, `expires_in` will be converted to a datetime `expires_in` seconds in the future, and passed as `expires_at` in the decorated method. :param f: the method to decorate, with an `expires_at` parameter :return: a decorated method that accepts either `expires_in` or `expires_at`. \"\"\" @wraps ( f ) def decorator ( * args : Any , expires_in : Optional [ int ] = None , expires_at : Optional [ datetime ] = None , ** kwargs : Any , ) -> Any : if expires_in is None and expires_at is None : return f ( * args , ** kwargs ) if expires_in and isinstance ( expires_in , int ) and expires_in >= 1 : expires_at = datetime . now () + timedelta ( seconds = expires_in ) return f ( * args , expires_at = expires_at , ** kwargs ) return decorator validate_endpoint_uri ( uri , https = True , no_fragment = True , path = True ) \u00b6 Validate that an URI is suitable as an endpoint URI. It checks: that the scheme is https that no fragment is included that a path is present Those check can be individually disabled using the parameters https , no_fragment and path . :param uri: the uri :param https: if True , check that the uri is https :param no_fragment: if True , check that the uri contains no fragment :param path: if True , check that the uri contains a path component :return: Source code in requests_oauth2client/utils.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def validate_endpoint_uri ( uri : str , https : bool = True , no_fragment : bool = True , path : bool = True ) -> None : \"\"\" Validate that an URI is suitable as an endpoint URI. It checks: - that the scheme is `https` - that no fragment is included - that a path is present Those check can be individually disabled using the parameters `https`, `no_fragment` and `path`. :param uri: the uri :param https: if `True`, check that the uri is https :param no_fragment: if `True`, check that the uri contains no fragment :param path: if `True`, check that the uri contains a path component :return: \"\"\" url = furl ( uri ) if https and url . scheme != \"https\" : raise ValueError ( \"url must use https\" ) if no_fragment and url . fragment : raise ValueError ( \"url must not contain a fragment\" ) if path and ( not url . path or url . path == \"/\" ): raise ValueError ( \"url has no path\" ) vendor_specific \u00b6 This module contains vendor-specific subclasses of [requests_oauth2client] classes, that make it easier to work with specific OAuth 2.x providers and/or fix compatibility issues. auth0 \u00b6 Implements subclasses for Auth0 . Auth0Client \u00b6 Bases: OAuth2Client A OAuth2Client for an Auth0 tenant. You only have to provide a tenant name and all endpoints will be initialized to work with your tenant. Source code in requests_oauth2client/vendor_specific/auth0.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Auth0Client ( OAuth2Client ): \"\"\" A OAuth2Client for an Auth0 tenant. You only have to provide a tenant name and all endpoints will be initialized to work with your tenant. \"\"\" def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `Auth0Client`. :param tenant: the tenant name or FQDN. If it doesn't contain a `.` or it ends with `.eu`, `.us`, or `.au`, then `.auth0.com` will automatically be suffixed to the provided tenant name. :param auth: the client credentials, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] :param session: the session to use, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] \"\"\" if ( \".\" not in tenant or tenant . endswith ( \".eu\" ) or tenant . endswith ( \".us\" ) or tenant . endswith ( \".au\" ) ): tenant = f \" { tenant } .auth0.com\" self . tenant = tenant token_endpoint = f \"https:// { tenant } /oauth/token\" revocation_endpoint = f \"https:// { tenant } /oauth/revoke\" userinfo_endpoint = f \"https:// { tenant } /userinfo\" jwks_uri = f \"https:// { tenant } /.well-known/jwks.json\" super () . __init__ ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , ) __init__ ( tenant , auth , session = None ) \u00b6 Initialize an Auth0Client . :param tenant: the tenant name or FQDN. If it doesn't contain a . or it ends with .eu , .us , or .au , then .auth0.com will automatically be suffixed to the provided tenant name. :param auth: the client credentials, same definition as for OAuth2Client :param session: the session to use, same definition as for OAuth2Client Source code in requests_oauth2client/vendor_specific/auth0.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `Auth0Client`. :param tenant: the tenant name or FQDN. If it doesn't contain a `.` or it ends with `.eu`, `.us`, or `.au`, then `.auth0.com` will automatically be suffixed to the provided tenant name. :param auth: the client credentials, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] :param session: the session to use, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] \"\"\" if ( \".\" not in tenant or tenant . endswith ( \".eu\" ) or tenant . endswith ( \".us\" ) or tenant . endswith ( \".au\" ) ): tenant = f \" { tenant } .auth0.com\" self . tenant = tenant token_endpoint = f \"https:// { tenant } /oauth/token\" revocation_endpoint = f \"https:// { tenant } /oauth/revoke\" userinfo_endpoint = f \"https:// { tenant } /userinfo\" jwks_uri = f \"https:// { tenant } /.well-known/jwks.json\" super () . __init__ ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , ) Auth0ManagementApiClient \u00b6 Bases: ApiClient A wrapper around Auth0 Management API v2 , for a given Auth0 tenant. Usage: 1 2 a0mgmt = Auth0ManagementApiClient ( \"mytenant.eu\" , ( client_id , client_secret )) users = a0mgmt . get ( \"users\" , params = { \"page\" : 0 , \"per_page\" : 100 }) Source code in requests_oauth2client/vendor_specific/auth0.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Auth0ManagementApiClient ( ApiClient ): \"\"\" A wrapper around [Auth0 Management API v2](https://auth0.com/docs/api/management/v2), for a given Auth0 tenant. Usage: ```python a0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (client_id, client_secret)) users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100}) ``` \"\"\" def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an Auth0ManagementApiClient against a given Auth0 tenant. :param tenant: the tenant name. Same definition as for [Auth0Client][requests_oauth2client.vendor_specific.auth0.Auth0Client] :param auth: client credentials. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param session: requests session. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param kwargs: additional kwargs to pass to the ApiClient base class \"\"\" client = Auth0Client ( tenant , auth , session = session ) audience = f \"https:// { client . tenant } /api/v2/\" api_auth = OAuth2ClientCredentialsAuth ( client , audience = audience ) super () . __init__ ( url = audience , auth = api_auth , session = session , ** kwargs , ) __init__ ( tenant , auth , session = None , ** kwargs ) \u00b6 Initialize an Auth0ManagementApiClient against a given Auth0 tenant. :param tenant: the tenant name. Same definition as for Auth0Client :param auth: client credentials. Same definition as for OAuth2Client :param session: requests session. Same definition as for OAuth2Client :param kwargs: additional kwargs to pass to the ApiClient base class Source code in requests_oauth2client/vendor_specific/auth0.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an Auth0ManagementApiClient against a given Auth0 tenant. :param tenant: the tenant name. Same definition as for [Auth0Client][requests_oauth2client.vendor_specific.auth0.Auth0Client] :param auth: client credentials. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param session: requests session. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param kwargs: additional kwargs to pass to the ApiClient base class \"\"\" client = Auth0Client ( tenant , auth , session = session ) audience = f \"https:// { client . tenant } /api/v2/\" api_auth = OAuth2ClientCredentialsAuth ( client , audience = audience ) super () . __init__ ( url = audience , auth = api_auth , session = session , ** kwargs , ) selection: docstring_style: restructured-text filters: - \"!^_\" - \"^ init \" - \"!^utils\" rendering: members_order: source show_root_heading: true","title":"API"},{"location":"api/#requests_oauth2client.api_client","text":"ApiClient main module.","title":"api_client"},{"location":"api/#requests_oauth2client.api_client.ApiClient","text":"A Wrapper around requests.Session to simplify Rest API calls. This allows setting a root url at creation time, then passing relative urls at request time. It may also raise exceptions instead of returning error responses. You can also pass additional kwargs at init time, which will be used to configure the Session , instead of setting them later. Basic usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from requests_oauth2client import ApiClient api = ApiClient ( \"https://myapi.local/resource\" , timeout = 10 ) resp = api . get ( \"/myid\" ) # this will send a GET request # to https://myapi.local/resource/myid # you can pass an underlying requests.Session at init time session = requests . Session () session . proxies = { \"https\" : \"https://localhost:3128\" } api = ApiClient ( \"https://myapi.local/resource\" , session = session ) # or you can let ApiClient init it's own session and provide additional configuration parameters: api = ApiClient ( \"https://myapi.local/resource\" , proxies = { \"https\" : \"https://localhost:3128\" } ) Source code in requests_oauth2client/api_client.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 class ApiClient : \"\"\" A Wrapper around [requests.Session][] to simplify Rest API calls. This allows setting a root url at creation time, then passing relative urls at request time. It may also raise exceptions instead of returning error responses. You can also pass additional kwargs at init time, which will be used to configure the [Session][requests.Session], instead of setting them later. Basic usage: ```python from requests_oauth2client import ApiClient api = ApiClient(\"https://myapi.local/resource\", timeout=10) resp = api.get(\"/myid\") # this will send a GET request # to https://myapi.local/resource/myid # you can pass an underlying requests.Session at init time session = requests.Session() session.proxies = {\"https\": \"https://localhost:3128\"} api = ApiClient(\"https://myapi.local/resource\", session=session) # or you can let ApiClient init it's own session and provide additional configuration parameters: api = ApiClient( \"https://myapi.local/resource\", proxies={\"https\": \"https://localhost:3128\"} ) ``` \"\"\" def __init__ ( self , base_url : Optional [ str ] = None , auth : Optional [ requests . auth . AuthBase ] = None , timeout : Optional [ int ] = 60 , raise_for_status : bool = True , none_fields : Literal [ \"include\" , \"exclude\" , \"empty\" ] = \"exclude\" , bool_fields : Optional [ Tuple [ Any , Any ]] = ( \"true\" , \"false\" ), session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an `ApiClient`, with an optional root url. `base_url` will serve as root for relative urls passed to [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request], [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc. An `HTTPError` will be raised everytime an API call returns an error code (>= 400), unless you set `raise_for_status` to `False`. Additional parameters passed at init time, including `auth` will be used to configure the [Session][requests.Session]. :param base_url: the base api url, that should be root for all the target API endpoints. :param auth: the [requests.auth.AuthBase][] to use as authentication handler. :param timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to `None` to disable timeout. :param raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (>= 400). :param none_fields: if `\"exclude\"` (default), data or json fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with a boolean value (`True` or `False`) will be serialized to the corresponding value. This can be useful since some APIs expect a `'true'` or `'false'` value as boolean, and requests serialises `True` to `'True'` and `False` to `'False'`. Set it to `None` to restore default requests behaviour. :param kwargs: additional kwargs to configure this session. This parameter may be overridden at request time. \"\"\" super ( ApiClient , self ) . __init__ () self . base_url = base_url self . raise_for_status = raise_for_status self . none_fields = none_fields self . bool_fields = bool_fields if bool_fields is not None else ( True , False ) self . timeout = timeout self . session = session or requests . Session () self . session . auth = auth for key , val in kwargs . items (): setattr ( self . session , key , val ) def request ( # noqa: C901 self , method : str , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , params : Union [ None , bytes , MutableMapping [ str , str ]] = None , data : Union [ None , str , bytes , Mapping [ str , Any ], Iterable [ Tuple [ str , Optional [ str ]]], IO [ Any ], ] = None , headers : Optional [ MutableMapping [ str , str ]] = None , cookies : Union [ None , RequestsCookieJar , MutableMapping [ str , str ]] = None , files : Optional [ MutableMapping [ str , IO [ Any ]]] = None , auth : Union [ None , Tuple [ str , str ], requests . auth . AuthBase , Callable [[ requests . PreparedRequest ], requests . PreparedRequest ], ] = None , timeout : Union [ None , float , Tuple [ float , float ], Tuple [ float , None ]] = None , allow_redirects : Optional [ bool ] = True , proxies : Optional [ MutableMapping [ str , str ]] = None , hooks : Optional [ MutableMapping [ str , Union [ Iterable [ Callable [[ requests . Response ], Any ]], Callable [[ requests . Response ], Any ], ], ] ] = None , stream : Optional [ bool ] = None , verify : Optional [ Union [ str , bool ]] = None , cert : Optional [ Union [ str , Tuple [ str , str ]]] = None , json : Optional [ Mapping [ str , Any ]] = None , raise_for_status : Optional [ bool ] = None , none_fields : Optional [ Literal [ \"include\" , \"exclude\" , \"empty\" ]] = None , bool_fields : Optional [ Tuple [ Any , Any ]] = None , ) -> requests . Response : \"\"\" Overridden `request` method that can handle a relative path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url. :param raise_for_status: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param none_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param bool_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :return: a [requests.Response][] as returned by requests \"\"\" url = self . to_absolute_url ( url ) if none_fields is None : none_fields = self . none_fields if none_fields == \"exclude\" : if isinstance ( data , Mapping ): data = { key : val for key , val in data . items () if val is not None } if isinstance ( json , Mapping ): json = { key : val for key , val in json . items () if val is not None } elif none_fields == \"empty\" : if isinstance ( data , Mapping ): data = { key : val if val is not None else \"\" for key , val in data . items () } if isinstance ( json , Mapping ): json = { key : val if val is not None else \"\" for key , val in json . items () } if bool_fields is None : bool_fields = self . bool_fields if bool_fields : try : true_value , false_value = bool_fields except ValueError : raise ValueError ( \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\" ) if isinstance ( data , MutableMapping ): for key , val in data . items (): if val is True : data [ key ] = true_value elif val is False : data [ key ] = false_value if isinstance ( params , MutableMapping ): for key , val in params . items (): if val is True : params [ key ] = true_value elif val is False : params [ key ] = false_value timeout = timeout or self . timeout response = self . session . request ( method , url , params = params , data = data , headers = headers , cookies = cookies , files = files , auth = auth , timeout = timeout , allow_redirects = allow_redirects , proxies = proxies , hooks = hooks , stream = stream , verify = verify , cert = cert , json = json , ) if raise_for_status is None : raise_for_status = self . raise_for_status if raise_for_status : response . raise_for_status () return response def to_absolute_url ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None ) -> str : \"\"\"Given an 'url', that can be relative or absolute, return the matching absolute url, based on the base url. :param url: a (possibly relative) url :return: the matching absolute url \"\"\" if self . base_url : if url is not None : if not isinstance ( url , ( str , bytes )): try : url = \"/\" . join ( [ part . decode () if isinstance ( part , bytes ) else str ( part ) for part in url if part ] ) except TypeError : raise TypeError ( \"Unexpected url type, please pass a relative path as string or bytes, \" \"or an iterable of string-able objects\" , type ( url ), ) if isinstance ( url , bytes ): url = url . decode () url = urljoin ( self . base_url + \"/\" , url . lstrip ( \"/\" )) else : url = self . base_url if url is None or not isinstance ( url , str ): raise ValueError ( \"Unable to determine an absolute url.\" ) return url def get ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a GET request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param none_data_fields: if `\"exclude\"` (default), data fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param kwargs: Optional arguments that [request()][requests.request] takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. and an error response is returned. \"\"\" return self . request ( \"GET\" , url , raise_for_status = raise_for_status , ** kwargs ) def post ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a POST request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"POST\" , url , raise_for_status = raise_for_status , ** kwargs ) def patch ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PATCH request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PATCH\" , url , raise_for_status = raise_for_status , ** kwargs ) def put ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PUT request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PUT\" , url , raise_for_status = raise_for_status , ** kwargs ) def delete ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a DELETE request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"DELETE\" , url , raise_for_status = raise_for_status , ** kwargs ) def __getattr__ ( self , item : str ) -> ApiClient : \"\"\"Allow access sub resources with an attribute-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api.resource1.get() # GET https://myapi.local/resource1 resource2 = api.resource2.get() # GET https://myapi.local/resource2 ``` :param item: a subpath :return: a new ApiClient initialised on the new base url \"\"\" return self [ item ] def __getitem__ ( self , item : str ) -> ApiClient : \"\"\"Allow access to sub resources with a subscription-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api['resource1'].get() # GET https://myapi.local/resource1 resource2 = api['resource2'].get() # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the the new base url \"\"\" new_base_uri = self . to_absolute_url ( item ) return self . __class__ ( new_base_uri , session = self . session , none_fields = self . none_fields , bool_fields = self . bool_fields , timeout = self . timeout , raise_for_status = self . raise_for_status , ) def __enter__ ( self ) -> ApiClient : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" return self def __exit__ ( self , * args : Any ) -> None : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" self . session . close ()","title":"ApiClient"},{"location":"api/#requests_oauth2client.api_client.ApiClient.__enter__","text":"Allow ApiClient to act as a context manager, the same way as requests.Session . Source code in requests_oauth2client/api_client.py 395 396 397 def __enter__ ( self ) -> ApiClient : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" return self","title":"__enter__()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.__exit__","text":"Allow ApiClient to act as a context manager, the same way as requests.Session . Source code in requests_oauth2client/api_client.py 399 400 401 def __exit__ ( self , * args : Any ) -> None : \"\"\"Allow `ApiClient` to act as a context manager, the same way as `requests.Session`.\"\"\" self . session . close ()","title":"__exit__()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.__getattr__","text":"Allow access sub resources with an attribute-based syntax. 1 2 3 api = ApiClient ( \"https://myapi.local\" ) resource1 = api . resource1 . get () # GET https://myapi.local/resource1 resource2 = api . resource2 . get () # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the new base url Source code in requests_oauth2client/api_client.py 360 361 362 363 364 365 366 367 368 369 370 371 372 def __getattr__ ( self , item : str ) -> ApiClient : \"\"\"Allow access sub resources with an attribute-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api.resource1.get() # GET https://myapi.local/resource1 resource2 = api.resource2.get() # GET https://myapi.local/resource2 ``` :param item: a subpath :return: a new ApiClient initialised on the new base url \"\"\" return self [ item ]","title":"__getattr__()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.__getitem__","text":"Allow access to sub resources with a subscription-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api['resource1'].get() # GET https://myapi.local/resource1 resource2 = api['resource2'].get() # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the the new base url Source code in requests_oauth2client/api_client.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def __getitem__ ( self , item : str ) -> ApiClient : \"\"\"Allow access to sub resources with a subscription-based syntax. ```python api = ApiClient(\"https://myapi.local\") resource1 = api['resource1'].get() # GET https://myapi.local/resource1 resource2 = api['resource2'].get() # GET https://myapi.local/resource2 :param item: a subpath :return: a new ApiClient initialised on the the new base url \"\"\" new_base_uri = self . to_absolute_url ( item ) return self . __class__ ( new_base_uri , session = self . session , none_fields = self . none_fields , bool_fields = self . bool_fields , timeout = self . timeout , raise_for_status = self . raise_for_status , )","title":"__getitem__()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.__init__","text":"Initialize an ApiClient , with an optional root url. base_url will serve as root for relative urls passed to ApiClient.request() , ApiClient.get() , etc. An HTTPError will be raised everytime an API call returns an error code (>= 400), unless you set raise_for_status to False . Additional parameters passed at init time, including auth will be used to configure the Session . :param base_url: the base api url, that should be root for all the target API endpoints. :param auth: the requests.auth.AuthBase to use as authentication handler. :param timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to None to disable timeout. :param raise_for_status: if True , exceptions will be raised everytime a request returns an error code (>= 400). :param none_fields: if \"exclude\" (default), data or json fields whose values are None are not included in the request. If \"include\", they are included with string value None (this is the default behavior of requests ). If \"empty\", they are included with an empty value (as an empty string). :param bool_fields: a tuple of (true_value, false_value). Fields from data or params with a boolean value ( True or False ) will be serialized to the corresponding value. This can be useful since some APIs expect a 'true' or 'false' value as boolean, and requests serialises True to 'True' and False to 'False' . Set it to None to restore default requests behaviour. :param kwargs: additional kwargs to configure this session. This parameter may be overridden at request time. Source code in requests_oauth2client/api_client.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , base_url : Optional [ str ] = None , auth : Optional [ requests . auth . AuthBase ] = None , timeout : Optional [ int ] = 60 , raise_for_status : bool = True , none_fields : Literal [ \"include\" , \"exclude\" , \"empty\" ] = \"exclude\" , bool_fields : Optional [ Tuple [ Any , Any ]] = ( \"true\" , \"false\" ), session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an `ApiClient`, with an optional root url. `base_url` will serve as root for relative urls passed to [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request], [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc. An `HTTPError` will be raised everytime an API call returns an error code (>= 400), unless you set `raise_for_status` to `False`. Additional parameters passed at init time, including `auth` will be used to configure the [Session][requests.Session]. :param base_url: the base api url, that should be root for all the target API endpoints. :param auth: the [requests.auth.AuthBase][] to use as authentication handler. :param timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to `None` to disable timeout. :param raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (>= 400). :param none_fields: if `\"exclude\"` (default), data or json fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with a boolean value (`True` or `False`) will be serialized to the corresponding value. This can be useful since some APIs expect a `'true'` or `'false'` value as boolean, and requests serialises `True` to `'True'` and `False` to `'False'`. Set it to `None` to restore default requests behaviour. :param kwargs: additional kwargs to configure this session. This parameter may be overridden at request time. \"\"\" super ( ApiClient , self ) . __init__ () self . base_url = base_url self . raise_for_status = raise_for_status self . none_fields = none_fields self . bool_fields = bool_fields if bool_fields is not None else ( True , False ) self . timeout = timeout self . session = session or requests . Session () self . session . auth = auth for key , val in kwargs . items (): setattr ( self . session , key , val )","title":"__init__()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.delete","text":"Send a DELETE request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def delete ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a DELETE request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"DELETE\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"delete()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.get","text":"Send a GET request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param none_data_fields: if \"exclude\" (default), data fields whose values are None are not included in the request. If \"include\", they are included with string value None (this is the default behavior of requests ). If \"empty\", they are included with an empty value (as an empty string). :param kwargs: Optional arguments that request() takes. :return: a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. and an error response is returned. Source code in requests_oauth2client/api_client.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def get ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a GET request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param none_data_fields: if `\"exclude\"` (default), data fields whose values are `None` are not included in the request. If \"include\", they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string). :param kwargs: Optional arguments that [request()][requests.request] takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. and an error response is returned. \"\"\" return self . request ( \"GET\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"get()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.patch","text":"Send a PATCH request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def patch ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PATCH request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PATCH\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"patch()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.post","text":"Send a POST request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def post ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a POST request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"POST\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"post()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.put","text":"Send a PUT request. Return a Response object. The passed url may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request() . :param url: a url where the request will be sent. :param raise_for_status: overrides the raises_for_status parameter passed at initialization time. :param kwargs: Optional arguments that request takes. :return: a a Response object. :raises requests.HTTPError: if raises_for_status is True (in this request or at initialization time) and an error response is returned. Source code in requests_oauth2client/api_client.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def put ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Send a PUT request. Return a [Response][requests.Response] object. The passed `url` may be relative to the url passed at initialization time. It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request]. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a a [Response][requests.Response] object. :raises requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PUT\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"put()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.request","text":"Overridden request method that can handle a relative path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url. :param raise_for_status: like the parameter of the same name from ApiClient.__init__ , but this will be applied for this request only. :param none_fields: like the parameter of the same name from ApiClient.__init__ , but this will be applied for this request only. :param bool_fields: like the parameter of the same name from ApiClient.__init__ , but this will be applied for this request only. :return: a requests.Response as returned by requests Source code in requests_oauth2client/api_client.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def request ( # noqa: C901 self , method : str , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None , params : Union [ None , bytes , MutableMapping [ str , str ]] = None , data : Union [ None , str , bytes , Mapping [ str , Any ], Iterable [ Tuple [ str , Optional [ str ]]], IO [ Any ], ] = None , headers : Optional [ MutableMapping [ str , str ]] = None , cookies : Union [ None , RequestsCookieJar , MutableMapping [ str , str ]] = None , files : Optional [ MutableMapping [ str , IO [ Any ]]] = None , auth : Union [ None , Tuple [ str , str ], requests . auth . AuthBase , Callable [[ requests . PreparedRequest ], requests . PreparedRequest ], ] = None , timeout : Union [ None , float , Tuple [ float , float ], Tuple [ float , None ]] = None , allow_redirects : Optional [ bool ] = True , proxies : Optional [ MutableMapping [ str , str ]] = None , hooks : Optional [ MutableMapping [ str , Union [ Iterable [ Callable [[ requests . Response ], Any ]], Callable [[ requests . Response ], Any ], ], ] ] = None , stream : Optional [ bool ] = None , verify : Optional [ Union [ str , bool ]] = None , cert : Optional [ Union [ str , Tuple [ str , str ]]] = None , json : Optional [ Mapping [ str , Any ]] = None , raise_for_status : Optional [ bool ] = None , none_fields : Optional [ Literal [ \"include\" , \"exclude\" , \"empty\" ]] = None , bool_fields : Optional [ Tuple [ Any , Any ]] = None , ) -> requests . Response : \"\"\" Overridden `request` method that can handle a relative path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url. :param raise_for_status: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param none_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :param bool_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only. :return: a [requests.Response][] as returned by requests \"\"\" url = self . to_absolute_url ( url ) if none_fields is None : none_fields = self . none_fields if none_fields == \"exclude\" : if isinstance ( data , Mapping ): data = { key : val for key , val in data . items () if val is not None } if isinstance ( json , Mapping ): json = { key : val for key , val in json . items () if val is not None } elif none_fields == \"empty\" : if isinstance ( data , Mapping ): data = { key : val if val is not None else \"\" for key , val in data . items () } if isinstance ( json , Mapping ): json = { key : val if val is not None else \"\" for key , val in json . items () } if bool_fields is None : bool_fields = self . bool_fields if bool_fields : try : true_value , false_value = bool_fields except ValueError : raise ValueError ( \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\" ) if isinstance ( data , MutableMapping ): for key , val in data . items (): if val is True : data [ key ] = true_value elif val is False : data [ key ] = false_value if isinstance ( params , MutableMapping ): for key , val in params . items (): if val is True : params [ key ] = true_value elif val is False : params [ key ] = false_value timeout = timeout or self . timeout response = self . session . request ( method , url , params = params , data = data , headers = headers , cookies = cookies , files = files , auth = auth , timeout = timeout , allow_redirects = allow_redirects , proxies = proxies , hooks = hooks , stream = stream , verify = verify , cert = cert , json = json , ) if raise_for_status is None : raise_for_status = self . raise_for_status if raise_for_status : response . raise_for_status () return response","title":"request()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.to_absolute_url","text":"Given an 'url', that can be relative or absolute, return the matching absolute url, based on the base url. :param url: a (possibly relative) url :return: the matching absolute url Source code in requests_oauth2client/api_client.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def to_absolute_url ( self , url : Union [ None , str , bytes , Iterable [ Union [ str , bytes , int ]]] = None ) -> str : \"\"\"Given an 'url', that can be relative or absolute, return the matching absolute url, based on the base url. :param url: a (possibly relative) url :return: the matching absolute url \"\"\" if self . base_url : if url is not None : if not isinstance ( url , ( str , bytes )): try : url = \"/\" . join ( [ part . decode () if isinstance ( part , bytes ) else str ( part ) for part in url if part ] ) except TypeError : raise TypeError ( \"Unexpected url type, please pass a relative path as string or bytes, \" \"or an iterable of string-able objects\" , type ( url ), ) if isinstance ( url , bytes ): url = url . decode () url = urljoin ( self . base_url + \"/\" , url . lstrip ( \"/\" )) else : url = self . base_url if url is None or not isinstance ( url , str ): raise ValueError ( \"Unable to determine an absolute url.\" ) return url","title":"to_absolute_url()"},{"location":"api/#requests_oauth2client.auth","text":"This module contains requests Auth Handlers that implement OAuth 2.0.","title":"auth"},{"location":"api/#requests_oauth2client.auth.BearerAuth","text":"Bases: requests . auth . AuthBase A requests AuthBase that includes a Bearer Access Token in API calls, as defined in RFC6750$2.1 . As a prerequisite to using this AuthBase, you have to obtain an access token manually. If you want to abstract that, see others Auth Handlers in this module that will automatically obtain access tokens from an OAuth 2.x server. Usage: 1 2 auth = BearerAuth ( \"my_access_token\" ) resp = requests . get ( \"https://my.api.local/resource\" , auth = auth ) The HTTP request will look like: 1 2 3 GET /resource HTTP/1.1 Host: my.api.local Authorization: Bearer my_access_token Source code in requests_oauth2client/auth.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class BearerAuth ( requests . auth . AuthBase ): \"\"\" A [requests AuthBase][requests.auth.AuthBase] that includes a Bearer Access Token in API calls, as defined in [RFC6750$2.1](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1). As a prerequisite to using this AuthBase, you have to obtain an access token manually. If you want to abstract that, see others Auth Handlers in this module that will automatically obtain access tokens from an OAuth 2.x server. Usage: ```python auth = BearerAuth(\"my_access_token\") resp = requests.get(\"https://my.api.local/resource\", auth=auth) ``` The HTTP request will look like: ``` GET /resource HTTP/1.1 Host: my.api.local Authorization: Bearer my_access_token ``` \"\"\" def __init__ ( self , token : Optional [ Union [ str , BearerToken ]] = None ) -> None : \"\"\" Initialize a BearerAuth with an existing Access Token. :param token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string to use as token for this Auth Handler. If `None`, this Auth Handler is a no op. \"\"\" self . token = token # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed @property def token ( self ) -> Optional [ BearerToken ]: \"\"\" Return the token that is used for authorization against the API. :return: the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this AuthHandler. \"\"\" return self . _token @token . setter def token ( self , token : Union [ str , BearerToken ]) -> None : \"\"\" Change the access token used with this AuthHandler. Accepts a [BearerToken][requests_oauth2client.tokens.BearerToken] or an access token as `str`. :param token: an access token to use for this Auth Handler \"\"\" if token is not None and not isinstance ( token , BearerToken ): token = BearerToken ( token ) self . _token = token def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding the `Authorization: Bearer <token>` header in the request. If the configuerd token is a instance of BearerToken with an expires_at attribute, raises [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access token is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" if self . token is None : return request if self . token . is_expired (): raise ExpiredAccessToken ( self . token ) request . headers [ \"Authorization\" ] = self . token . authorization_header () return request","title":"BearerAuth"},{"location":"api/#requests_oauth2client.auth.BearerAuth.__call__","text":"Implement the logic of adding the Authorization: Bearer <token> header in the request. If the configuerd token is a instance of BearerToken with an expires_at attribute, raises ExpiredAccessToken once the access token is expired. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding the `Authorization: Bearer <token>` header in the request. If the configuerd token is a instance of BearerToken with an expires_at attribute, raises [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access token is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" if self . token is None : return request if self . token . is_expired (): raise ExpiredAccessToken ( self . token ) request . headers [ \"Authorization\" ] = self . token . authorization_header () return request","title":"__call__()"},{"location":"api/#requests_oauth2client.auth.BearerAuth.__init__","text":"Initialize a BearerAuth with an existing Access Token. :param token: a BearerToken or a string to use as token for this Auth Handler. If None , this Auth Handler is a no op. Source code in requests_oauth2client/auth.py 35 36 37 38 39 40 41 def __init__ ( self , token : Optional [ Union [ str , BearerToken ]] = None ) -> None : \"\"\" Initialize a BearerAuth with an existing Access Token. :param token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string to use as token for this Auth Handler. If `None`, this Auth Handler is a no op. \"\"\" self . token = token # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed","title":"__init__()"},{"location":"api/#requests_oauth2client.auth.BearerAuth.token","text":"Return the token that is used for authorization against the API. :return: the configured BearerToken used with this AuthHandler. Source code in requests_oauth2client/auth.py 43 44 45 46 47 48 49 50 @property def token ( self ) -> Optional [ BearerToken ]: \"\"\" Return the token that is used for authorization against the API. :return: the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this AuthHandler. \"\"\" return self . _token","title":"token()"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth","text":"Bases: BearerAuth A Requests Authentication handler using a Bearer access token, and can automatically refreshes it when expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken( access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\") # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ```` Source code in requests_oauth2client/auth.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class OAuth2AccessTokenAuth ( BearerAuth ): \"\"\" A Requests Authentication handler using a Bearer access token, and can automatically refreshes it when expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken( access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\") # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ```` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , token : Optional [ Union [ str , BearerToken ]] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2AccessTokenAuth`, with an initial token. Token can be a simple `str` containing a raw access token value, or a [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens. :param token: a access token that has been previously obtained :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( token ) self . client = client self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding access token in requests, and refreshing that token once it is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if ( token is not None and token . is_expired () and token . refresh_token and self . client is not None ): self . token = self . client . refresh_token ( refresh_token = token . refresh_token , ** self . token_kwargs ) return super () . __call__ ( request )","title":"OAuth2AccessTokenAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.__call__","text":"Implement the logic of adding access token in requests, and refreshing that token once it is expired. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of adding access token in requests, and refreshing that token once it is expired. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if ( token is not None and token . is_expired () and token . refresh_token and self . client is not None ): self . token = self . client . refresh_token ( refresh_token = token . refresh_token , ** self . token_kwargs ) return super () . __call__ ( request )","title":"__call__()"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.__init__","text":"Initialize an OAuth2AccessTokenAuth , with an initial token. Token can be a simple str containing a raw access token value, or a BearerToken that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired. :param client: the OAuth2Client to use to refresh tokens. :param token: a access token that has been previously obtained :param token_kwargs: additional kwargs to pass to the token endpoint Source code in requests_oauth2client/auth.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def __init__ ( self , client : \"OAuth2Client\" , token : Optional [ Union [ str , BearerToken ]] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2AccessTokenAuth`, with an initial token. Token can be a simple `str` containing a raw access token value, or a [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens. :param token: a access token that has been previously obtained :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( token ) self . client = client self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth","text":"Bases: OAuth2AccessTokenAuth A Requests Auth handler that exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\" oauth2ac_auth = OAuth2AuthorizationCodeAuth(client, code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` Source code in requests_oauth2client/auth.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class OAuth2AuthorizationCodeAuth ( OAuth2AccessTokenAuth ): \"\"\" A [Requests Auth handler][requests.auth.AuthBase] that exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\" oauth2ac_auth = OAuth2AuthorizationCodeAuth(client, code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , code : str , ** token_kwargs : Any ) -> None : \"\"\" Initialize an `OAuth2AuthorizationCodeAuth` with a given Authorization Code. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param code: an Authorization Code that has been manually obtained from the AS. :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . code : Optional [ str ] = code self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Authorization Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): if self . code : # pragma: no branch self . token = self . client . authorization_code ( code = self . code , ** self . token_kwargs ) self . code = None return super () . __call__ ( request )","title":"OAuth2AuthorizationCodeAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth.__call__","text":"Implement the logic of exchanging the Authorization Code for an access token and adding it in the request. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Authorization Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): if self . code : # pragma: no branch self . token = self . client . authorization_code ( code = self . code , ** self . token_kwargs ) self . code = None return super () . __call__ ( request )","title":"__call__()"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth.__init__","text":"Initialize an OAuth2AuthorizationCodeAuth with a given Authorization Code. :param client: the OAuth2Client to use to obtain Access Tokens. :param code: an Authorization Code that has been manually obtained from the AS. :param token_kwargs: additional kwargs to pass to the token endpoint Source code in requests_oauth2client/auth.py 191 192 193 194 195 196 197 198 199 200 201 def __init__ ( self , client : \"OAuth2Client\" , code : str , ** token_kwargs : Any ) -> None : \"\"\" Initialize an `OAuth2AuthorizationCodeAuth` with a given Authorization Code. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param code: an Authorization Code that has been manually obtained from the AS. :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . code : Optional [ str ] = code self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth","text":"Bases: BearerAuth A requests AuthBase that automatically gets access tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, then will get a new one once the current one is expired. Usage: 1 2 3 4 5 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , auth = ( \"client_id\" , \"client_secret\" ) ) oauth2cc = OAuth2ClientCredentialsAuth ( client , scope = \"my_scope\" ) resp = requests . post ( \"https://my.api.local/resource\" , auth = oauth2cc ) Source code in requests_oauth2client/auth.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class OAuth2ClientCredentialsAuth ( BearerAuth ): \"\"\" A [requests AuthBase][requests.auth.AuthBase] that automatically gets access tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, then will get a new one once the current one is expired. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\") ) oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc) ``` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , ** token_kwargs : Any ): \"\"\" Initialize an `OAuth2ClientCredentialsAuth`. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc. \"\"\" super () . __init__ ( None ) self . client = client self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of obtaining a token using the Client Credentials Grant, and including that token in requests. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): self . token = self . client . client_credentials ( ** self . token_kwargs ) return super () . __call__ ( request )","title":"OAuth2ClientCredentialsAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth.__call__","text":"Implement the logic of obtaining a token using the Client Credentials Grant, and including that token in requests. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 108 109 110 111 112 113 114 115 116 117 118 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of obtaining a token using the Client Credentials Grant, and including that token in requests. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" token = self . token if token is None or token . is_expired (): self . token = self . client . client_credentials ( ** self . token_kwargs ) return super () . __call__ ( request )","title":"__call__()"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth.__init__","text":"Initialize an OAuth2ClientCredentialsAuth . :param client: the OAuth2Client to use to obtain Access Tokens. :param token_kwargs: extra kw parameters to pass to the Token Endpoint. May include scope , resource , etc. Source code in requests_oauth2client/auth.py 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , client : \"OAuth2Client\" , ** token_kwargs : Any ): \"\"\" Initialize an `OAuth2ClientCredentialsAuth`. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc. \"\"\" super () . __init__ ( None ) self . client = client self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth","text":"Bases: OAuth2AccessTokenAuth A Requests Auth handler that exchange a Device Code for an access token, then automatically refresh it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = \"my_device_code\" oauth2ac_auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` Source code in requests_oauth2client/auth.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class OAuth2DeviceCodeAuth ( OAuth2AccessTokenAuth ): \"\"\" A [Requests Auth handler][requests.auth.AuthBase] that exchange a Device Code for an access token, then automatically refresh it once it is expired. Usage: ```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = \"my_device_code\" oauth2ac_auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=oauth2ac_auth) ```` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , device_code : str , interval : int = 5 , expires_in : int = 360 , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2DeviceCodeAuth`. It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param device_code: a Device Code obtained from the AS. :param interval: the interval to use to pool the Token Endpoint, in seconds. :param expires_in: the lifetime of the token, in seconds :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . device_code : Optional [ str ] = device_code self . interval = interval self . expires_in = expires_in self . token_kwargs = token_kwargs def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Device Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" from .device_authorization import DeviceAuthorizationPoolingJob token = self . token if token is None or token . is_expired (): if self . device_code : # pragma: no branch pooling_job = DeviceAuthorizationPoolingJob ( client = self . client , device_code = self . device_code , interval = self . interval , ) while self . token is None : self . token = pooling_job () self . device_code = None return super () . __call__ ( request )","title":"OAuth2DeviceCodeAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth.__call__","text":"Implement the logic of exchanging the Device Code for an access token and adding it in the request. :param request: a PreparedRequest :return: a PreparedRequest with an Access Token added in Authorization Header Source code in requests_oauth2client/auth.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Implement the logic of exchanging the Device Code for an access token and adding it in the request. :param request: a [PreparedRequest][requests.PreparedRequest] :return: a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header \"\"\" from .device_authorization import DeviceAuthorizationPoolingJob token = self . token if token is None or token . is_expired (): if self . device_code : # pragma: no branch pooling_job = DeviceAuthorizationPoolingJob ( client = self . client , device_code = self . device_code , interval = self . interval , ) while self . token is None : self . token = pooling_job () self . device_code = None return super () . __call__ ( request )","title":"__call__()"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth.__init__","text":"Initialize an OAuth2DeviceCodeAuth . It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent. :param client: the OAuth2Client to use to obtain Access Tokens. :param device_code: a Device Code obtained from the AS. :param interval: the interval to use to pool the Token Endpoint, in seconds. :param expires_in: the lifetime of the token, in seconds :param token_kwargs: additional kwargs to pass to the token endpoint Source code in requests_oauth2client/auth.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def __init__ ( self , client : \"OAuth2Client\" , device_code : str , interval : int = 5 , expires_in : int = 360 , ** token_kwargs : Any , ) -> None : \"\"\" Initialize an `OAuth2DeviceCodeAuth`. It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens. :param device_code: a Device Code obtained from the AS. :param interval: the interval to use to pool the Token Endpoint, in seconds. :param expires_in: the lifetime of the token, in seconds :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( client , None ) self . device_code : Optional [ str ] = device_code self . interval = interval self . expires_in = expires_in self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.authorization_request","text":"This module contains classes and utilities related to Authorization Requests and Responses.","title":"authorization_request"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest","text":"Represents an Authorization Request. This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response. Source code in requests_oauth2client/authorization_request.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 class AuthorizationRequest : \"\"\" Represents an Authorization Request. This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response. \"\"\" exception_classes : Dict [ str , Type [ Exception ]] = { \"interaction_required\" : InteractionRequired , \"login_required\" : LoginRequired , \"session_selection_required\" : SessionSelectionRequired , \"consent_required\" : ConsentRequired , } def __init__ ( self , authorization_endpoint : str , client_id : str , redirect_uri : Optional [ str ], scope : Union [ None , str , Iterable [ str ]], response_type : str = \"code\" , state : Union [ str , bool , None ] = True , nonce : Union [ str , bool , None ] = True , code_verifier : Optional [ str ] = None , code_challenge_method : Optional [ str ] = \"S256\" , issuer : Union [ str , bool , None ] = None , ** kwargs : Any , ) -> None : \"\"\" Create an `AuthorizationRequest`. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: * `state`: if True (default), a random state parameter will be generated for you. You may pass your own state as `str`, or set it to `None` so that the state parameter will not be included in the request. You may access that state in the `state` attribute from this request. * `nonce`: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the `nonce` attribute from this request. * `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`, a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated, and the `code_challenge` will be included in the request. You may pass your own `code_verifier` as a `str` parameter, in which case the appropriate `code_challenge` will be included in the request, according to the `code_challenge_method`. :param authorization_endpoint: the uri for the authorization endpoint. :param client_id: the client_id to include in the request. :param redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization Request. :param scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`. :param response_type: the response type to include in the request. :param state: the state to include in the request, or `True` to autogenerate one (default). :param nonce: the nonce to include in the request, or `True` to autogenerate one (default). :param code_verifier: the state to include in the request, or `True` to autogenerate one (default). :param code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`. :param issuer: Issuer Identifier value from the OAuth/OIDC Server, if known. Set it to `False` if the AS doesn't support Server Issuer Identification. :param kwargs: extra parameters to include in the request, as-is. \"\"\" if state is True : state = secrets . token_urlsafe ( 32 ) elif state is False : state = None if scope is not None and isinstance ( scope , str ): scope = scope . split ( \" \" ) if nonce is True and scope is not None and \"openid\" in scope : nonce = secrets . token_urlsafe ( 32 ) elif nonce is False : nonce = None if scope is not None and not isinstance ( scope , str ): scope = \" \" . join ( str ( s ) for s in scope ) if \"code_challenge\" in kwargs : raise ValueError ( \"A code_challenge must not be passed as parameter. \" \"Pass the code_verifier instead, and the appropriate code_challenge \" \"will automatically be derived from it and included in the request, \" \"based on code_challenge_method.\" ) if not code_challenge_method : code_verifier = code_challenge = code_challenge_method = None else : if not code_verifier : code_verifier = PkceUtils . generate_code_verifier () code_challenge = PkceUtils . derive_challenge ( code_verifier , code_challenge_method ) self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . redirect_uri = redirect_uri self . response_type = response_type self . scope = scope self . state = state self . nonce = nonce self . code_verifier = code_verifier self . code_challenge = code_challenge self . code_challenge_method = code_challenge_method self . kwargs = kwargs self . issuer = issuer self . args = dict ( client_id = client_id , redirect_uri = redirect_uri , response_type = response_type , scope = scope , state = state , nonce = nonce , code_challenge = code_challenge , code_challenge_method = code_challenge_method , ** kwargs , ) def sign_request_jwt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> Jwt : \"\"\" Sign the `request` object that matches this Authorization Request parameters. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: a :class:`Jwt` that contains the signed request object. \"\"\" return Jwt . sign ( claims = { key : val for key , val in self . args . items () if val is not None }, jwk = jwk , alg = alg , ) def sign ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> \"AuthorizationRequest\" : \"\"\" Sign the current Authorization Request. This replaces all parameters with a signed `request` JWT. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: the signed Authorization Request \"\"\" request_jwt = self . sign_request_jwt ( jwk , alg ) self . args = { \"request\" : str ( request_jwt )} return self def sign_and_encrypt_request_jwt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> Jwt : \"\"\" Sign and encrypt the `request` object that matches the current Authorization Request parameters. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: the signed and encrypted request object, as a :class:`Jwt` \"\"\" return Jwt . sign_and_encrypt ( claims = { key : val for key , val in self . args . items () if val is not None }, sign_jwk = sign_jwk , sign_alg = sign_alg , enc_jwk = enc_jwk , enc_alg = enc_alg , enc = enc , ) def sign_and_encrypt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> \"AuthorizationRequest\" : \"\"\" Sign and encrypt the current Authorization Request. This replaces all parameters with a matching `request` object. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: \"\"\" request_jwt = self . sign_and_encrypt_request_jwt ( sign_jwk = sign_jwk , enc_jwk = enc_jwk , sign_alg = sign_alg , enc_alg = enc_alg , enc = enc , ) self . args = { \"request\" : str ( request_jwt )} return self def validate_callback ( self , response : str ) -> AuthorizationResponse : \"\"\" Validate a given Authorization Response URI against this Authorization Request, and return an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse]. This includes matching the `state` parameter, checking for returned errors, and extracting the returned `code` and other parameters. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: the extracted code, if the :raises MismatchingState: if the response `state` does not match the expected value. :raises OAuth2Error: if the response includes an error. :raises MissingAuthCode: if the response does not contain a `code`. \"\"\" try : response_url = furl ( response ) except ValueError : return self . on_response_error ( response ) # validate 'iss' according to https://www.ietf.org/archive/id/draft-ietf-oauth-iss-auth-resp-05.html expected_issuer = self . issuer if expected_issuer is not None : received_issuer = response_url . args . get ( \"iss\" ) if ( expected_issuer is False and received_issuer is not None ) or ( expected_issuer and received_issuer != expected_issuer ): raise MismatchingIssuer ( expected_issuer , received_issuer ) requested_state = self . state if requested_state : received_state = response_url . args . get ( \"state\" ) if requested_state != received_state : raise MismatchingState ( requested_state , received_state ) error = response_url . args . get ( \"error\" ) if error : return self . on_response_error ( response ) code : str = response_url . args . get ( \"code\" ) if code is None : raise MissingAuthCode () return AuthorizationResponse ( code_verifier = self . code_verifier , redirect_uri = self . redirect_uri , ** response_url . args , ) def on_response_error ( self , response : str ) -> AuthorizationResponse : \"\"\" Triggered by [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback] if the response uri contains an error. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: may return a default code that will be returned by `validate_callback`. But this method will most likely raise exceptions instead. \"\"\" response_url = furl ( response ) error = response_url . args . get ( \"error\" ) error_description = response_url . args . get ( \"error_description\" ) error_uri = response_url . args . get ( \"error_uri\" ) exception_class = self . exception_classes . get ( error , AuthorizationResponseError ) raise exception_class ( error , error_description , error_uri ) @property def uri ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. You may also use `repr()` or `str()` on an AuthorizationRequest to obtain the same uri. Authorization requests typically look like: ``` https://myas.local/authorize?client_id=<client_id>&response_type=code&scope=openid&redirect_uri=<redirect_uri> ``` Unless they have been signed, and optionally encrypted, into a `request` object, then they look like: ``` https://myas.local/authorize?request=<request> ``` :return: the Authorization Request URI. \"\"\" return str ( furl ( self . authorization_endpoint , args = { key : value for key , value in self . args . items () if value is not None }, ) . url ) def __repr__ ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri def __eq__ ( self , other : Any ) -> bool : \"\"\" Check if this Authorization Request is the same as another one. :param other: :return: \"\"\" if isinstance ( other , AuthorizationRequest ): return ( self . authorization_endpoint == other . authorization_endpoint and self . args == other . kwargs and self . issuer == other . issuer ) elif isinstance ( other , str ): return self . uri == other return super () . __eq__ ( other )","title":"AuthorizationRequest"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.__eq__","text":"Check if this Authorization Request is the same as another one. :param other: :return: Source code in requests_oauth2client/authorization_request.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def __eq__ ( self , other : Any ) -> bool : \"\"\" Check if this Authorization Request is the same as another one. :param other: :return: \"\"\" if isinstance ( other , AuthorizationRequest ): return ( self . authorization_endpoint == other . authorization_endpoint and self . args == other . kwargs and self . issuer == other . issuer ) elif isinstance ( other , str ): return self . uri == other return super () . __eq__ ( other )","title":"__eq__()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.__init__","text":"Create an AuthorizationRequest . All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: state : if True (default), a random state parameter will be generated for you. You may pass your own state as str , or set it to None so that the state parameter will not be included in the request. You may access that state in the state attribute from this request. nonce : if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the nonce attribute from this request. code_verifier : if None , and code_challenge_method is 'S256' or 'plain' , a valid code_challenge and code_verifier for PKCE will be automatically generated, and the code_challenge will be included in the request. You may pass your own code_verifier as a str parameter, in which case the appropriate code_challenge will be included in the request, according to the code_challenge_method . :param authorization_endpoint: the uri for the authorization endpoint. :param client_id: the client_id to include in the request. :param redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass None if you don't need any redirect_uri in the Authorization Request. :param scope: the scope to include in the request, as an iterable of str , or a single space-separated str . :param response_type: the response type to include in the request. :param state: the state to include in the request, or True to autogenerate one (default). :param nonce: the nonce to include in the request, or True to autogenerate one (default). :param code_verifier: the state to include in the request, or True to autogenerate one (default). :param code_challenge_method: the method to use to derive the code_challenge from the code_verifier . :param issuer: Issuer Identifier value from the OAuth/OIDC Server, if known. Set it to False if the AS doesn't support Server Issuer Identification. :param kwargs: extra parameters to include in the request, as-is. Source code in requests_oauth2client/authorization_request.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __init__ ( self , authorization_endpoint : str , client_id : str , redirect_uri : Optional [ str ], scope : Union [ None , str , Iterable [ str ]], response_type : str = \"code\" , state : Union [ str , bool , None ] = True , nonce : Union [ str , bool , None ] = True , code_verifier : Optional [ str ] = None , code_challenge_method : Optional [ str ] = \"S256\" , issuer : Union [ str , bool , None ] = None , ** kwargs : Any , ) -> None : \"\"\" Create an `AuthorizationRequest`. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: * `state`: if True (default), a random state parameter will be generated for you. You may pass your own state as `str`, or set it to `None` so that the state parameter will not be included in the request. You may access that state in the `state` attribute from this request. * `nonce`: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the `nonce` attribute from this request. * `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`, a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated, and the `code_challenge` will be included in the request. You may pass your own `code_verifier` as a `str` parameter, in which case the appropriate `code_challenge` will be included in the request, according to the `code_challenge_method`. :param authorization_endpoint: the uri for the authorization endpoint. :param client_id: the client_id to include in the request. :param redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization Request. :param scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`. :param response_type: the response type to include in the request. :param state: the state to include in the request, or `True` to autogenerate one (default). :param nonce: the nonce to include in the request, or `True` to autogenerate one (default). :param code_verifier: the state to include in the request, or `True` to autogenerate one (default). :param code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`. :param issuer: Issuer Identifier value from the OAuth/OIDC Server, if known. Set it to `False` if the AS doesn't support Server Issuer Identification. :param kwargs: extra parameters to include in the request, as-is. \"\"\" if state is True : state = secrets . token_urlsafe ( 32 ) elif state is False : state = None if scope is not None and isinstance ( scope , str ): scope = scope . split ( \" \" ) if nonce is True and scope is not None and \"openid\" in scope : nonce = secrets . token_urlsafe ( 32 ) elif nonce is False : nonce = None if scope is not None and not isinstance ( scope , str ): scope = \" \" . join ( str ( s ) for s in scope ) if \"code_challenge\" in kwargs : raise ValueError ( \"A code_challenge must not be passed as parameter. \" \"Pass the code_verifier instead, and the appropriate code_challenge \" \"will automatically be derived from it and included in the request, \" \"based on code_challenge_method.\" ) if not code_challenge_method : code_verifier = code_challenge = code_challenge_method = None else : if not code_verifier : code_verifier = PkceUtils . generate_code_verifier () code_challenge = PkceUtils . derive_challenge ( code_verifier , code_challenge_method ) self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . redirect_uri = redirect_uri self . response_type = response_type self . scope = scope self . state = state self . nonce = nonce self . code_verifier = code_verifier self . code_challenge = code_challenge self . code_challenge_method = code_challenge_method self . kwargs = kwargs self . issuer = issuer self . args = dict ( client_id = client_id , redirect_uri = redirect_uri , response_type = response_type , scope = scope , state = state , nonce = nonce , code_challenge = code_challenge , code_challenge_method = code_challenge_method , ** kwargs , )","title":"__init__()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.__repr__","text":"Return the Authorization Request URI, as a str . :return: the Authorization Request URI. Source code in requests_oauth2client/authorization_request.py 457 458 459 460 461 462 463 def __repr__ ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri","title":"__repr__()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.on_response_error","text":"Triggered by validate_callback() if the response uri contains an error. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: may return a default code that will be returned by validate_callback . But this method will most likely raise exceptions instead. Source code in requests_oauth2client/authorization_request.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 def on_response_error ( self , response : str ) -> AuthorizationResponse : \"\"\" Triggered by [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback] if the response uri contains an error. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: may return a default code that will be returned by `validate_callback`. But this method will most likely raise exceptions instead. \"\"\" response_url = furl ( response ) error = response_url . args . get ( \"error\" ) error_description = response_url . args . get ( \"error_description\" ) error_uri = response_url . args . get ( \"error_uri\" ) exception_class = self . exception_classes . get ( error , AuthorizationResponseError ) raise exception_class ( error , error_description , error_uri )","title":"on_response_error()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign","text":"Sign the current Authorization Request. This replaces all parameters with a signed request JWT. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :return: the signed Authorization Request Source code in requests_oauth2client/authorization_request.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def sign ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> \"AuthorizationRequest\" : \"\"\" Sign the current Authorization Request. This replaces all parameters with a signed `request` JWT. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: the signed Authorization Request \"\"\" request_jwt = self . sign_request_jwt ( jwk , alg ) self . args = { \"request\" : str ( request_jwt )} return self","title":"sign()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt","text":"Sign and encrypt the current Authorization Request. This replaces all parameters with a matching request object. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :param enc_alg: the alg to use to encrypt the request, if the passed jwk has no alg parameter. :param enc: the encoding to use to encrypt the request, if the passed jwk has no enc parameter. :return: Source code in requests_oauth2client/authorization_request.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def sign_and_encrypt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> \"AuthorizationRequest\" : \"\"\" Sign and encrypt the current Authorization Request. This replaces all parameters with a matching `request` object. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: \"\"\" request_jwt = self . sign_and_encrypt_request_jwt ( sign_jwk = sign_jwk , enc_jwk = enc_jwk , sign_alg = sign_alg , enc_alg = enc_alg , enc = enc , ) self . args = { \"request\" : str ( request_jwt )} return self","title":"sign_and_encrypt()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt_request_jwt","text":"Sign and encrypt the request object that matches the current Authorization Request parameters. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :param enc_alg: the alg to use to encrypt the request, if the passed jwk has no alg parameter. :param enc: the encoding to use to encrypt the request, if the passed jwk has no enc parameter. :return: the signed and encrypted request object, as a :class: Jwt Source code in requests_oauth2client/authorization_request.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def sign_and_encrypt_request_jwt ( self , sign_jwk : Union [ Jwk , Dict [ str , Any ]], enc_jwk : Union [ Jwk , Dict [ str , Any ]], sign_alg : Optional [ str ] = None , enc_alg : Optional [ str ] = None , enc : Optional [ str ] = None , ) -> Jwt : \"\"\" Sign and encrypt the `request` object that matches the current Authorization Request parameters. :param sign_jwk: the JWK to use to sign the request :param enc_jwk: the JWK to use to encrypt the request :param sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :param enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter. :param enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter. :return: the signed and encrypted request object, as a :class:`Jwt` \"\"\" return Jwt . sign_and_encrypt ( claims = { key : val for key , val in self . args . items () if val is not None }, sign_jwk = sign_jwk , sign_alg = sign_alg , enc_jwk = enc_jwk , enc_alg = enc_alg , enc = enc , )","title":"sign_and_encrypt_request_jwt()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_request_jwt","text":"Sign the request object that matches this Authorization Request parameters. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed jwk has no alg parameter. :return: a :class: Jwt that contains the signed request object. Source code in requests_oauth2client/authorization_request.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def sign_request_jwt ( self , jwk : Union [ Jwk , Dict [ str , Any ]], alg : Optional [ str ] = None ) -> Jwt : \"\"\" Sign the `request` object that matches this Authorization Request parameters. :param jwk: the JWK to use to sign the request :param alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter. :return: a :class:`Jwt` that contains the signed request object. \"\"\" return Jwt . sign ( claims = { key : val for key , val in self . args . items () if val is not None }, jwk = jwk , alg = alg , )","title":"sign_request_jwt()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.uri","text":"Return the Authorization Request URI, as a str . You may also use repr() or str() on an AuthorizationRequest to obtain the same uri. Authorization requests typically look like: 1 https://myas.local/authorize?client_id=<client_id>&response_type=code&scope=openid&redirect_uri=<redirect_uri> Unless they have been signed, and optionally encrypted, into a request object, then they look like: 1 https://myas.local/authorize?request=<request> :return: the Authorization Request URI. Source code in requests_oauth2client/authorization_request.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 @property def uri ( self ) -> str : \"\"\" Return the Authorization Request URI, as a `str`. You may also use `repr()` or `str()` on an AuthorizationRequest to obtain the same uri. Authorization requests typically look like: ``` https://myas.local/authorize?client_id=<client_id>&response_type=code&scope=openid&redirect_uri=<redirect_uri> ``` Unless they have been signed, and optionally encrypted, into a `request` object, then they look like: ``` https://myas.local/authorize?request=<request> ``` :return: the Authorization Request URI. \"\"\" return str ( furl ( self . authorization_endpoint , args = { key : value for key , value in self . args . items () if value is not None }, ) . url )","title":"uri()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback","text":"Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse . This includes matching the state parameter, checking for returned errors, and extracting the returned code and other parameters. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: the extracted code, if the :raises MismatchingState: if the response state does not match the expected value. :raises OAuth2Error: if the response includes an error. :raises MissingAuthCode: if the response does not contain a code . Source code in requests_oauth2client/authorization_request.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def validate_callback ( self , response : str ) -> AuthorizationResponse : \"\"\" Validate a given Authorization Response URI against this Authorization Request, and return an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse]. This includes matching the `state` parameter, checking for returned errors, and extracting the returned `code` and other parameters. :param response: the Authorization Response URI. This can be the full URL, or just the query parameters. :return: the extracted code, if the :raises MismatchingState: if the response `state` does not match the expected value. :raises OAuth2Error: if the response includes an error. :raises MissingAuthCode: if the response does not contain a `code`. \"\"\" try : response_url = furl ( response ) except ValueError : return self . on_response_error ( response ) # validate 'iss' according to https://www.ietf.org/archive/id/draft-ietf-oauth-iss-auth-resp-05.html expected_issuer = self . issuer if expected_issuer is not None : received_issuer = response_url . args . get ( \"iss\" ) if ( expected_issuer is False and received_issuer is not None ) or ( expected_issuer and received_issuer != expected_issuer ): raise MismatchingIssuer ( expected_issuer , received_issuer ) requested_state = self . state if requested_state : received_state = response_url . args . get ( \"state\" ) if requested_state != received_state : raise MismatchingState ( requested_state , received_state ) error = response_url . args . get ( \"error\" ) if error : return self . on_response_error ( response ) code : str = response_url . args . get ( \"code\" ) if code is None : raise MissingAuthCode () return AuthorizationResponse ( code_verifier = self . code_verifier , redirect_uri = self . redirect_uri , ** response_url . args , )","title":"validate_callback()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse","text":"Represent a successful Authorization Response. An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to AuthorizationRequest.validate_callback() once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes: - all the parameters that have been returned by the AS, most notably the code , and optional parameters such as state . - the redirect_uri that was used for the Authorization Request - the code_verifier matching the code_challenge that was used for the Authorization Request Usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 request = AuthorizationRequest ( client_id , scope = \"openid\" , redirect_uri = \"http://localhost:54121/callback\" ) webbrowser . open ( request ) # open the authorization request in a browser response_uri = ... # at this point, manage to get the response uri response = request . validate_callback ( response_uri ) # get an AuthorizationResponse at this point client = OAuth2Client ( token_endpoint , auth = ( client_id , client_secret )) client . authorization_code ( response ) # you can pass this response on a call to `OAuth2Client.authorization_code()` Source code in requests_oauth2client/authorization_request.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class AuthorizationResponse : \"\"\" Represent a successful Authorization Response. An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to `AuthorizationRequest.validate_callback()` once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes: - all the parameters that have been returned by the AS, most notably the `code`, and optional parameters such as `state`. - the redirect_uri that was used for the Authorization Request - the code_verifier matching the code_challenge that was used for the Authorization Request Usage: ```python request = AuthorizationRequest( client_id, scope=\"openid\", redirect_uri=\"http://localhost:54121/callback\" ) webbrowser.open(request) # open the authorization request in a browser response_uri = ... # at this point, manage to get the response uri response = request.validate_callback( response_uri ) # get an AuthorizationResponse at this point client = OAuth2Client(token_endpoint, auth=(client_id, client_secret)) client.authorization_code( response ) # you can pass this response on a call to `OAuth2Client.authorization_code()` ``` \"\"\" def __init__ ( self , code : Optional [ str ] = None , redirect_uri : Optional [ str ] = None , code_verifier : Optional [ str ] = None , state : Optional [ str ] = None , ** kwargs : str , ): \"\"\" Initialise an `AuthorizationResponse`. Parameters `redirect_uri` and `code_verifier` must be those from the matching `AuthorizationRequest`. All other parameters including `code` and `state` must be those extracted from the Authorization Response parameters. :param code: the authorization code returned by the AS :param redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest :param code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest :param state: the state returned by the AS :param kwargs: other parameters as returned by the AS \"\"\" self . code = code self . redirect_uri = redirect_uri self . code_verifier = code_verifier self . state = state self . others = kwargs def __getattr__ ( self , item : str ) -> Optional [ str ]: \"\"\" Allow attribute access to additional parameters from this Authorization Response. :param item: the attribute name :return: the attribute value, or None if it isn't part of the returned attributes \"\"\" return self . others . get ( item )","title":"AuthorizationResponse"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse.__getattr__","text":"Allow attribute access to additional parameters from this Authorization Response. :param item: the attribute name :return: the attribute value, or None if it isn't part of the returned attributes Source code in requests_oauth2client/authorization_request.py 154 155 156 157 158 159 160 161 def __getattr__ ( self , item : str ) -> Optional [ str ]: \"\"\" Allow attribute access to additional parameters from this Authorization Response. :param item: the attribute name :return: the attribute value, or None if it isn't part of the returned attributes \"\"\" return self . others . get ( item )","title":"__getattr__()"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse.__init__","text":"Initialise an AuthorizationResponse . Parameters redirect_uri and code_verifier must be those from the matching AuthorizationRequest . All other parameters including code and state must be those extracted from the Authorization Response parameters. :param code: the authorization code returned by the AS :param redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest :param code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest :param state: the state returned by the AS :param kwargs: other parameters as returned by the AS Source code in requests_oauth2client/authorization_request.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , code : Optional [ str ] = None , redirect_uri : Optional [ str ] = None , code_verifier : Optional [ str ] = None , state : Optional [ str ] = None , ** kwargs : str , ): \"\"\" Initialise an `AuthorizationResponse`. Parameters `redirect_uri` and `code_verifier` must be those from the matching `AuthorizationRequest`. All other parameters including `code` and `state` must be those extracted from the Authorization Response parameters. :param code: the authorization code returned by the AS :param redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest :param code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest :param state: the state returned by the AS :param kwargs: other parameters as returned by the AS \"\"\" self . code = code self . redirect_uri = redirect_uri self . code_verifier = code_verifier self . state = state self . others = kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils","text":"Contains helper methods for PKCE, as described in RFC7636 . Source code in requests_oauth2client/authorization_request.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class PkceUtils : \"\"\"Contains helper methods for PKCE, as described in [RFC7636](https://tools.ietf.org/html/rfc7636).\"\"\" code_verifier_re = re . compile ( r \"^[a-zA-Z0-9_\\-~.]{43,128}$\" ) \"\"\"A regex that matches valid code verifiers.\"\"\" @classmethod def generate_code_verifier ( cls ) -> str : \"\"\" Generate a valid `code_verifier`. :return: a code_verifier ready to use for PKCE \"\"\" return secrets . token_urlsafe ( 96 ) @classmethod def derive_challenge ( cls , verifier : Union [ str , bytes ], method : str = \"S256\" ) -> str : \"\"\" Derive the `code_challenge` from a given `code_verifier`. :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier \"\"\" if isinstance ( verifier , bytes ): verifier = verifier . decode () if not cls . code_verifier_re . match ( verifier ): raise ValueError ( f \"Invalid code verifier, does not match { cls . code_verifier_re } \" , verifier , ) if method == \"S256\" : return BinaPy ( verifier ) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () elif method == \"plain\" : return verifier else : raise ValueError ( \"Unsupported code_challenge_method\" , method ) @classmethod def generate_code_verifier_and_challenge ( cls , method : str = \"S256\" ) -> Tuple [ str , str ]: \"\"\" Generate a valid `code_verifier` and derive its `code_challenge`. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. \"\"\" verifier = cls . generate_code_verifier () challenge = cls . derive_challenge ( verifier , method ) return verifier , challenge @classmethod def validate_code_verifier ( cls , verifier : str , challenge : str , method : str = \"S256\" ) -> bool : \"\"\" Validate a `code_verifier` against a `code_challenge`. :param verifier: the `code_verifier`, exactly as submitted by the client on token request. :param challenge: the `code_challenge`, exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise \"\"\" return ( cls . code_verifier_re . match ( verifier ) is not None and cls . derive_challenge ( verifier , method ) == challenge )","title":"PkceUtils"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.code_verifier_re","text":"A regex that matches valid code verifiers.","title":"code_verifier_re"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.derive_challenge","text":"Derive the code_challenge from a given code_verifier . :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier Source code in requests_oauth2client/authorization_request.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @classmethod def derive_challenge ( cls , verifier : Union [ str , bytes ], method : str = \"S256\" ) -> str : \"\"\" Derive the `code_challenge` from a given `code_verifier`. :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier \"\"\" if isinstance ( verifier , bytes ): verifier = verifier . decode () if not cls . code_verifier_re . match ( verifier ): raise ValueError ( f \"Invalid code verifier, does not match { cls . code_verifier_re } \" , verifier , ) if method == \"S256\" : return BinaPy ( verifier ) . to ( \"sha256\" ) . to ( \"b64u\" ) . ascii () elif method == \"plain\" : return verifier else : raise ValueError ( \"Unsupported code_challenge_method\" , method )","title":"derive_challenge()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier","text":"Generate a valid code_verifier . :return: a code_verifier ready to use for PKCE Source code in requests_oauth2client/authorization_request.py 32 33 34 35 36 37 38 39 @classmethod def generate_code_verifier ( cls ) -> str : \"\"\" Generate a valid `code_verifier`. :return: a code_verifier ready to use for PKCE \"\"\" return secrets . token_urlsafe ( 96 )","title":"generate_code_verifier()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier_and_challenge","text":"Generate a valid code_verifier and derive its code_challenge . :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. Source code in requests_oauth2client/authorization_request.py 66 67 68 69 70 71 72 73 74 75 76 77 78 @classmethod def generate_code_verifier_and_challenge ( cls , method : str = \"S256\" ) -> Tuple [ str , str ]: \"\"\" Generate a valid `code_verifier` and derive its `code_challenge`. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. \"\"\" verifier = cls . generate_code_verifier () challenge = cls . derive_challenge ( verifier , method ) return verifier , challenge","title":"generate_code_verifier_and_challenge()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.validate_code_verifier","text":"Validate a code_verifier against a code_challenge . :param verifier: the code_verifier , exactly as submitted by the client on token request. :param challenge: the code_challenge , exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise Source code in requests_oauth2client/authorization_request.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod def validate_code_verifier ( cls , verifier : str , challenge : str , method : str = \"S256\" ) -> bool : \"\"\" Validate a `code_verifier` against a `code_challenge`. :param verifier: the `code_verifier`, exactly as submitted by the client on token request. :param challenge: the `code_challenge`, exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise \"\"\" return ( cls . code_verifier_re . match ( verifier ) is not None and cls . derive_challenge ( verifier , method ) == challenge )","title":"validate_code_verifier()"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest","text":"Represent an Authorization Request that includes a request object. Source code in requests_oauth2client/authorization_request.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 class RequestUriParameterAuthorizationRequest : \"\"\"Represent an Authorization Request that includes a `request` object.\"\"\" @accepts_expires_in def __init__ ( self , authorization_endpoint : str , client_id : str , request_uri : str , expires_at : Optional [ datetime ] = None , ): \"\"\"Init a RequestUriParameterAuthorizationRequest. It needs an authorization endpoint, a client_id, a request_uri, and an optional expiration date. \"\"\" self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . request_uri = request_uri self . expires_at = expires_at @property def uri ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`.\"\"\" return str ( furl ( self . authorization_endpoint , args = { \"client_id\" : self . client_id , \"request_uri\" : self . request_uri }, ) . url ) def __repr__ ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri","title":"RequestUriParameterAuthorizationRequest"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.__init__","text":"Init a RequestUriParameterAuthorizationRequest. It needs an authorization endpoint, a client_id, a request_uri, and an optional expiration date. Source code in requests_oauth2client/authorization_request.py 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 @accepts_expires_in def __init__ ( self , authorization_endpoint : str , client_id : str , request_uri : str , expires_at : Optional [ datetime ] = None , ): \"\"\"Init a RequestUriParameterAuthorizationRequest. It needs an authorization endpoint, a client_id, a request_uri, and an optional expiration date. \"\"\" self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . request_uri = request_uri self . expires_at = expires_at","title":"__init__()"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.__repr__","text":"Return the Authorization Request URI, as a str . :return: the Authorization Request URI. Source code in requests_oauth2client/authorization_request.py 513 514 515 516 517 518 def __repr__ ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`. :return: the Authorization Request URI. \"\"\" return self . uri","title":"__repr__()"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.uri","text":"Return the Authorization Request URI, as a str . Source code in requests_oauth2client/authorization_request.py 503 504 505 506 507 508 509 510 511 @property def uri ( self ) -> str : \"\"\"Return the Authorization Request URI, as a `str`.\"\"\" return str ( furl ( self . authorization_endpoint , args = { \"client_id\" : self . client_id , \"request_uri\" : self . request_uri }, ) . url )","title":"uri()"},{"location":"api/#requests_oauth2client.backchannel_authentication","text":"Implementation of Client Initiated BackChannel Authentication (CIBA) .","title":"backchannel_authentication"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob","text":"Bases: TokenEndpointPoolingJob A pooling job for checking if the user has finished with his authorization in a BackChannel Authentication flow. Usage: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , auth = ( \"client_id\" , \"client_secret\" ) ) pool_job = BackChannelAuthenticationPoolingJob ( client = client , auth_req_id = \"my_auth_req_id\" ) token = None while token is None : token = pool_job () Source code in requests_oauth2client/backchannel_authentication.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 class BackChannelAuthenticationPoolingJob ( TokenEndpointPoolingJob ): \"\"\" A pooling job for checking if the user has finished with his authorization in a BackChannel Authentication flow. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\") ) pool_job = BackChannelAuthenticationPoolingJob( client=client, auth_req_id=\"my_auth_req_id\" ) token = None while token is None: token = pool_job() ``` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" if ( isinstance ( auth_req_id , BackChannelAuthenticationResponse ) and interval is None ): interval = auth_req_id . interval super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . auth_req_id = auth_req_id def token_request ( self ) -> BearerToken : \"\"\" Implement the CIBA token request. This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . ciba ( self . auth_req_id , requests_kwargs = self . requests_kwargs , ** self . token_kwargs )","title":"BackChannelAuthenticationPoolingJob"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob.__init__","text":"Initialize a BackChannelAuthenticationPoolingJob . :param client: an OAuth2Client that will be used to pool the token endpoint. :param auth_req_id: an auth_req_id as str or a BackChannelAuthenticationResponse . :param interval: The pooling interval to use. This overrides the one in auth_req_id if it is a BackChannelAuthenticationResponse . :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to requests.request . :param token_kwargs: Additional parameters for the token request. Source code in requests_oauth2client/backchannel_authentication.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , client : \"OAuth2Client\" , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" if ( isinstance ( auth_req_id , BackChannelAuthenticationResponse ) and interval is None ): interval = auth_req_id . interval super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . auth_req_id = auth_req_id","title":"__init__()"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob.token_request","text":"Implement the CIBA token request. This actually calls [OAuth2Client.ciba(auth_req_id)] on client . :return: a BearerToken Source code in requests_oauth2client/backchannel_authentication.py 125 126 127 128 129 130 131 132 133 134 def token_request ( self ) -> BearerToken : \"\"\" Implement the CIBA token request. This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . ciba ( self . auth_req_id , requests_kwargs = self . requests_kwargs , ** self . token_kwargs )","title":"token_request()"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse","text":"Represent a BackChannel Authentication Response. This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as auth_req_id , expires_at , interval , and/or any custom parameters. Source code in requests_oauth2client/backchannel_authentication.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class BackChannelAuthenticationResponse : \"\"\" Represent a BackChannel Authentication Response. This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as `auth_req_id`, `expires_at`, `interval`, and/or any custom parameters. \"\"\" @accepts_expires_in def __init__ ( self , auth_req_id : str , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = 20 , ** kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationResponse`. Such a response MUST include an `auth_req_id`. :param auth_req_id: the `auth_req_id` as returned by the AS. :param expires_at: the date when the `auth_req_id` expires. Note that this request also accepts an `expires_in` parameter, in seconds. :param interval: the Token Endpoint pooling interval, in seconds, as returned by the AS. :param kwargs: any additional custom parameters as returned by the AS. \"\"\" self . auth_req_id = auth_req_id self . expires_at = expires_at self . interval = interval self . other = kwargs def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Return `True` if the auth_req_id within this response is expired at the time of the call. :return: `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this `BackChannelAuthenticationResponse`. Allows accessing response parameters with `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not present in the response \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) return self . other . get ( key ) or super () . __getattribute__ ( key )","title":"BackChannelAuthenticationResponse"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.__getattr__","text":"Return attributes from this BackChannelAuthenticationResponse . Allows accessing response parameters with token_response.expires_in or token_response.any_custom_attribute :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not present in the response Source code in requests_oauth2client/backchannel_authentication.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this `BackChannelAuthenticationResponse`. Allows accessing response parameters with `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not present in the response \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) return self . other . get ( key ) or super () . __getattribute__ ( key )","title":"__getattr__()"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.__init__","text":"Initialize a BackChannelAuthenticationResponse . Such a response MUST include an auth_req_id . :param auth_req_id: the auth_req_id as returned by the AS. :param expires_at: the date when the auth_req_id expires. Note that this request also accepts an expires_in parameter, in seconds. :param interval: the Token Endpoint pooling interval, in seconds, as returned by the AS. :param kwargs: any additional custom parameters as returned by the AS. Source code in requests_oauth2client/backchannel_authentication.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @accepts_expires_in def __init__ ( self , auth_req_id : str , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = 20 , ** kwargs : Any , ): \"\"\" Initialize a `BackChannelAuthenticationResponse`. Such a response MUST include an `auth_req_id`. :param auth_req_id: the `auth_req_id` as returned by the AS. :param expires_at: the date when the `auth_req_id` expires. Note that this request also accepts an `expires_in` parameter, in seconds. :param interval: the Token Endpoint pooling interval, in seconds, as returned by the AS. :param kwargs: any additional custom parameters as returned by the AS. \"\"\" self . auth_req_id = auth_req_id self . expires_at = expires_at self . interval = interval self . other = kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.is_expired","text":"Return True if the auth_req_id within this response is expired at the time of the call. :return: True if the auth_req_id is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client/backchannel_authentication.py 45 46 47 48 49 50 51 52 53 54 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Return `True` if the auth_req_id within this response is expired at the time of the call. :return: `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None","title":"is_expired()"},{"location":"api/#requests_oauth2client.client","text":"This module contains the OAuth2Client class, which is a central part of requests_oauth2client .","title":"client"},{"location":"api/#requests_oauth2client.client.OAuth2Client","text":"An OAuth 2.0 client, that can send requests to an OAuth 2.0 Authorization Server. OAuth2Client is able to obtain tokens from the Token Endpoint using one of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint. This class doesn't implement anything related to the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest . Usage: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , revocation_endpoint = \"https://my.as.local/revoke\" , auth = ( \"client_id\" , \"client_secret\" ), ) # once intialized, a client can send requests to its configured endpoints cc_token = client . client_credentials ( scope = \"my_scope\" ) ac_token = client . authorization_code ( code = \"my_code\" ) client . revoke_access_token ( cc_token ) Source code in requests_oauth2client/client.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 class OAuth2Client : \"\"\" An OAuth 2.0 client, that can send requests to an OAuth 2.0 Authorization Server. `OAuth2Client` is able to obtain tokens from the Token Endpoint using one of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint. This class doesn't implement anything related to the end-user authentication or any request that goes in a browser. For authentication requests, see [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", revocation_endpoint=\"https://my.as.local/revoke\", auth=(\"client_id\", \"client_secret\"), ) # once intialized, a client can send requests to its configured endpoints cc_token = client.client_credentials(scope=\"my_scope\") ac_token = client.authorization_code(code=\"my_code\") client.revoke_access_token(cc_token) ``` \"\"\" exception_classes : Dict [ str , Type [ Exception ]] = { \"server_error\" : ServerError , \"invalid_scope\" : InvalidScope , \"invalid_target\" : InvalidTarget , \"invalid_grant\" : InvalidGrant , \"access_denied\" : AccessDenied , \"unauthorized_client\" : UnauthorizedClient , \"authorization_pending\" : AuthorizationPending , \"slow_down\" : SlowDown , \"expired_token\" : ExpiredToken , \"unsupported_token_type\" : UnsupportedTokenType , } def __init__ ( self , token_endpoint : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], Tuple [ str , Jwk ], str ], revocation_endpoint : Optional [ str ] = None , introspection_endpoint : Optional [ str ] = None , userinfo_endpoint : Optional [ str ] = None , backchannel_authentication_endpoint : Optional [ str ] = None , device_authorization_endpoint : Optional [ str ] = None , pushed_authorization_request_endpoint : Optional [ str ] = None , jwks_uri : Optional [ str ] = None , session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `OAuth2Client`. :param token_endpoint: the Token Endpoint URI where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a [requests.auth.AuthBase][] instance (which will be as-is), or a tuple of `(client_id, client_secret)` which will initialize an instance of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost], a `(client_id, jwk)` to initialize a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt], or a `client_id` which will use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication. :param revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens :param introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens :param userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user :param backchannel_authentication_endpoint: the BackChannel Authentication URI :param device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices :param jwks_uri: the JWKS URI to use to obtain the AS public keys :param session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS. \"\"\" self . token_endpoint = str ( token_endpoint ) self . revocation_endpoint = ( str ( revocation_endpoint ) if revocation_endpoint else None ) self . introspection_endpoint = ( str ( introspection_endpoint ) if introspection_endpoint else None ) self . userinfo_endpoint = str ( userinfo_endpoint ) if userinfo_endpoint else None self . backchannel_authentication_endpoint = ( str ( backchannel_authentication_endpoint ) if backchannel_authentication_endpoint else None ) self . device_authorization_endpoint = ( str ( device_authorization_endpoint ) if device_authorization_endpoint else None ) self . pushed_authorization_request_endpoint = ( str ( pushed_authorization_request_endpoint ) if pushed_authorization_request_endpoint else None ) self . jwks_uri = str ( jwks_uri ) if jwks_uri else None self . session = session or requests . Session () self . auth = client_auth_factory ( auth , ClientSecretPost ) def token_request ( self , data : Dict [ str , Any ], timeout : int = 10 , ** requests_kwargs : Any ) -> BearerToken : \"\"\" Send a request to the token endpoint. Authentication will be added automatically. :param data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request. :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as [BearerToken][requests_oauth2client.tokens.BearerToken] instance. \"\"\" requests_kwargs = { key : value for key , value in requests_kwargs . items () if value is not None and value != \"\" } response = self . session . post ( self . token_endpoint , auth = self . auth , data = data , timeout = timeout , ** requests_kwargs , ) if response . ok : return self . parse_token_response ( response ) return self . on_token_error ( response ) def parse_token_response ( self , response : requests . Response ) -> BearerToken : \"\"\" Parse a Response returned by the Token Endpoint. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse responses returned by the Token Endpoint. Those response contain an `access_token` and additional attributes. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] based on the response contents. \"\"\" try : token_response = BearerToken ( ** response . json ()) return token_response except Exception as response_class_exc : try : return self . on_token_error ( response ) except Exception as token_error_exc : raise token_error_exc from response_class_exc def on_token_error ( self , response : requests . Response ) -> BearerToken : \"\"\" Error handler for [token_request][requests_oauth2client.client.OAuth2Client.token_request]. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the Token Endpoint returns an error. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: returns nothing and raises an exception instead. But a subclass may return a [BearerToken][requests_oauth2client.tokens.BearerToken] to implement a default behaviour if needed. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidTokenResponse ( \"token endpoint returned an HTTP error without error message\" , error_json , ) def client_credentials ( self , requests_kwargs : Optional [ Dict [ str , Any ]] = None , scope : Optional [ Union [ str , Iterable [ str ]]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint using the `client_credentials` grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters to pass that way include `scope`, `audience`, `resource`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc data = dict ( grant_type = \"client_credentials\" , scope = scope , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) def authorization_code ( self , code : Union [ str , AuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `authorization_code` grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" if isinstance ( code , AuthorizationResponse ): if not isinstance ( code . code , str ): raise ValueError ( \"This AuthorizationResponse doesn't contain an authorization code\" ) token_kwargs . setdefault ( \"code_verifer\" , code . code_verifier ) token_kwargs . setdefault ( \"redirect_uri\" , code . redirect_uri ) code = code . code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"authorization_code\" , code = code , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) def refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `refresh_token` grant. :param refresh_token: a refresh_token, as a string, or as a BearerToken. That BearerToken must have a `refresh_token`. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `refresh_token`, etc. :param requests_kwargs: additional parameters for the call to `requests` :return: a BearerToken \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"This BearerToken doesn't have a refresh_token\" ) refresh_token = refresh_token . refresh_token requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"refresh_token\" , refresh_token = refresh_token , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) def device_code ( self , device_code : Union [ str , DeviceAuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `urn:ietf:params:oauth:grant-type:device_code` grant. :param device_code: a device code, as received during the Device Authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc. :return: a BearerToken \"\"\" if isinstance ( device_code , DeviceAuthorizationResponse ): device_code = device_code . device_code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:device_code\" , device_code = device_code , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) def ciba ( self , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a CIBA request to the Token Endpoint. A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant. :param auth_req_id: an authentication request ID, as returned by the AS :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc. :return: \"\"\" if isinstance ( auth_req_id , BackChannelAuthenticationResponse ): auth_req_id = auth_req_id . auth_req_id requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:openid:params:grant-type:ciba\" , auth_req_id = auth_req_id , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) def token_exchange ( self , subject_token : Union [ str , BearerToken , IdToken ], subject_token_type : Optional [ str ] = None , actor_token : Union [ None , str , BearerToken , IdToken ] = None , actor_token_type : Optional [ str ] = None , requested_token_type : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a Token Exchange request. A Token Exchange request is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`. :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on `type(subject_token)`. :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on `type(actor_token)`. :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying `requests.post()` call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. \"\"\" requests_kwargs = requests_kwargs or {} try : subject_token_type = self . get_token_type ( subject_token_type , subject_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'subject_token' you provided. \" \"Please specify a 'subject_token_type'.\" ) if actor_token : # pragma: no branch try : actor_token_type = self . get_token_type ( actor_token_type , actor_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'actor_token' you provided. \" \"Please specify an 'actor_token_type'.\" ) data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:token-exchange\" , subject_token = subject_token , subject_token_type = subject_token_type , actor_token = actor_token , actor_token_type = actor_token_type , requested_token_type = requested_token_type , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) def pushed_authorization_request ( self , authorization_request : AuthorizationRequest ) -> RequestUriParameterAuthorizationRequest : \"\"\"Send a Pushed Authorization Request, return a RequestUriParameterAuthorizationRequest initialized with the AS response. :param authorization_request: the authorization request to send :return: the RequestUriParameterAuthorizationRequest initialized based on the AS response \"\"\" if not self . pushed_authorization_request_endpoint : raise AttributeError ( \"No 'pushed_authorization_request_endpoint' defined for this client.\" ) response = self . session . post ( self . pushed_authorization_request_endpoint , data = authorization_request . args , auth = self . auth , ) if not response . ok : return self . on_pushed_authorization_request_error ( response ) response_json = response . json () request_uri = response_json . get ( \"request_uri\" ) expires_in = response_json . get ( \"expires_in\" ) return RequestUriParameterAuthorizationRequest ( authorization_endpoint = authorization_request . authorization_endpoint , client_id = authorization_request . client_id , request_uri = request_uri , expires_in = expires_in , ) def on_pushed_authorization_request_error ( self , response : requests . Response ) -> RequestUriParameterAuthorizationRequest : \"\"\"Error Handler for Pushed Authorization Endpoint errors. :param response: the HTTP response as returned by the AS PAR endpoint. :return: a RequestUriParameterAuthorizationRequest, if the error is recoverable :raises: Exception \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidPushedAuthorizationResponse ( \"pushed authorization endpoint returned an HTTP error without error message\" , error_json , ) def userinfo ( self , access_token : Union [ BearerToken , str ]) -> Any : \"\"\" Call the UserInfo endpoint with the specified access_token and return the result. :param access_token: the access token to use :return: the [Response][requests.Response] returned by the userinfo endpoint. \"\"\" if not self . userinfo_endpoint : raise AttributeError ( \"No userinfo_endpoint defined for this client\" ) response = self . session . post ( self . userinfo_endpoint , auth = BearerAuth ( access_token ) ) return self . parse_userinfo_response ( response ) def parse_userinfo_response ( self , resp : requests . Response ) -> Any : \"\"\" Given a response obtained from the userinfo endpoint, extract its JSON content. :param resp: a [Response][requests.Response] returned from the UserInfo endpoint. :return: the parsed JSON content from this response. \"\"\" return resp . json () @classmethod def get_token_type ( cls , token_type : Optional [ str ] = None , token : Union [ None , str , BearerToken , IdToken ] = None , ) -> str : \"\"\" Return a standardised token type identifier, based on a short `token_type` hint and/or a token value. :param token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional) :param token: a token value, as an instance of BearerToken or IdToken, or as a `str`. :return: the token_type as defined in the Token Exchange RFC8693. \"\"\" if not ( token_type or token ): raise ValueError ( \"Cannot determine type of an empty token without a token_type hint\" ) if token_type is None : if isinstance ( token , str ): raise ValueError ( \"Cannot determine the type of provided token when it is a bare str. \" \"Please specify a token_type.\" ) elif isinstance ( token , BearerToken ): return \"urn:ietf:params:oauth:token-type:access_token\" elif isinstance ( token , IdToken ): return \"urn:ietf:params:oauth:token-type:id_token\" else : raise TypeError ( \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\" , type ( token ), ) elif token_type == \"access_token\" : if token is not None and not isinstance ( token , ( str , BearerToken )): raise TypeError ( \"The supplied token is not a BearerToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:access_token\" elif token_type == \"refresh_token\" : if ( token is not None and isinstance ( token , BearerToken ) and not token . refresh_token ): raise ValueError ( \"The supplied BearerToken doesn't have a refresh_token.\" ) return \"urn:ietf:params:oauth:token-type:refresh_token\" elif token_type == \"id_token\" : if token is not None and not isinstance ( token , ( str , IdToken )): raise TypeError ( \"The supplied token is not an IdToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:id_token\" else : return { \"saml1\" : \"urn:ietf:params:oauth:token-type:saml1\" , \"saml2\" : \"urn:ietf:params:oauth:token-type:saml2\" , \"jwt\" : \"urn:ietf:params:oauth:token-type:jwt\" , } . get ( token_type , token_type ) def revoke_access_token ( self , access_token : Union [ BearerToken , str ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint \"\"\" return self . revoke_token ( access_token , token_type_hint = \"access_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) def revoke_refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: `True` if the revocation request is successful, `False` if this client has no configured revocation endpoint. \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) refresh_token = refresh_token . refresh_token return self . revoke_token ( refresh_token , token_type_hint = \"refresh_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) def revoke_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a Token Revocation request. By default, authentication will be the same than the one used for the Token Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: `True` if the revocation succeeds, `False` if no revocation endpoint is present or a non-standardised error is returned. \"\"\" if not self . revocation_endpoint : return False requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( revoke_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . revocation_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return True return self . on_revocation_error ( response ) def on_revocation_error ( self , response : requests . Response ) -> bool : \"\"\" Error handler for [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token]. Invoked by :method:`revoke_token` when the revocation endpoint returns an error. :param response: the [Response][requests.Response] as returned by the Revocation Endpoint :return: returns `False` to signal that an error occurred. May raise exceptions instead depending on the revocation response. \"\"\" try : data = response . json () except ValueError : return False error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , RevocationError ) raise exception_class ( error , error_description , error_uri ) return False def introspect_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** introspect_kwargs : Any , ) -> Any : \"\"\" Send a request to the configured Introspection Endpoint. :param token: the token to introspect. :param token_type_hint: the token_type_hint to include in the request. :param requests_kwargs: additional parameters to the underling call to requests.post() :param introspect_kwargs: additional parameters to send to the introspection endpoint. :return: the response as returned by the Introspection Endpoint. \"\"\" if not self . introspection_endpoint : raise AttributeError ( \"No introspection endpoint defined for this client\" ) requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( introspect_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . introspection_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_introspection_response ( response ) return self . on_introspection_error ( response ) def parse_introspection_response ( self , response : requests . Response ) -> Any : \"\"\" Parse Token Introspection Responses received by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string. :param response: the [Response][requests.Response] as returned by the Introspection Endpoint. :return: the decoded JSON content, or a `str` with the content. \"\"\" try : return response . json () except ValueError : return response . text def on_introspection_error ( self , response : requests . Response ) -> Any : \"\"\" Error handler for [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response in the case an error is returned. :param response: the response as returned by the Introspection Endpoint. :return: raises exeptions. A subclass can return a default response instead. \"\"\" try : data = response . json () except ValueError : try : response . raise_for_status () except Exception as exc : raise UnknownIntrospectionError ( response ) from exc error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , IntrospectionError ) raise exception_class ( error , error_description , error_uri ) raise UnknownIntrospectionError ( response ) def backchannel_authentication_request ( self , scope : Union [ None , str , Iterable [ str ]] = \"openid\" , client_notification_token : Optional [ str ] = None , acr_values : Union [ None , str , Iterable [ str ]] = None , login_hint_token : Optional [ str ] = None , id_token_hint : Optional [ str ] = None , login_hint : Optional [ str ] = None , binding_message : Optional [ str ] = None , user_code : Optional [ str ] = None , requested_expiry : Optional [ int ] = None , private_jwk : Union [ Jwk , Dict [ str , Any ], None ] = None , alg : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** ciba_kwargs : Any , ) -> BackChannelAuthenticationResponse : \"\"\" Send a CIBA Authentication Request. :param scope: the scope to include in the request. :param client_notification_token: the Client Notification Token to include in the request. :param acr_values: the acr values to include in the request. :param login_hint_token: the Login Hint Token to include in the request. :param id_token_hint: the ID Token Hint to include in the request. :param login_hint: the Login Hint to include in the request. :param binding_message: the Binding Message to include in the request. :param user_code: the User Code to include in the request :param requested_expiry: the Requested Expiry, in seconds, to include in the request. :param private_jwk: the JWK to use to sign the request (optional) :param alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter. :param requests_kwargs: additional parameters for :param ciba_kwargs: additional parameters to include in the request. :return: a BackChannelAuthenticationResponse \"\"\" if not self . backchannel_authentication_endpoint : raise AttributeError ( \"No backchannel authentication endpoint defined for this client\" ) if not ( login_hint or login_hint_token or id_token_hint ): raise ValueError ( \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) if ( ( login_hint_token and id_token_hint ) or ( login_hint and id_token_hint ) or ( login_hint_token and login_hint ) ): raise ValueError ( \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported `scope` value\" ) from exc if acr_values is not None and not isinstance ( acr_values , str ): try : acr_values = \" \" . join ( acr_values ) except Exception as exc : raise ValueError ( \"Unsupported `acr_values`\" ) from exc data = dict ( ciba_kwargs , scope = scope , client_notification_token = client_notification_token , acr_values = acr_values , login_hint_token = login_hint_token , id_token_hint = id_token_hint , login_hint = login_hint , binding_message = binding_message , user_code = user_code , requested_expiry = requested_expiry , ) if private_jwk is not None : data = { \"request\" : str ( Jwt . sign ( data , jwk = private_jwk , alg = alg ))} response = self . session . post ( self . backchannel_authentication_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_backchannel_authentication_response ( response ) return self . on_backchannel_authentication_error ( response ) def parse_backchannel_authentication_response ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Parse a BackChannel Authentication Response received by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint. :param response: the response returned by the BackChannel Authentication Endpoint. :return: a :class:`BackChannelAuthenticationResponse` \"\"\" try : return BackChannelAuthenticationResponse ( ** response . json ()) except TypeError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc def on_backchannel_authentication_error ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Error handler for [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint, when it is an error. :param response: the response returned by the BackChannel Authentication Endpoint. :return: raises an exception. But a subclass can return a default response instead. \"\"\" try : error_json = response . json () except ValueError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , BackChannelAuthenticationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidBackChannelAuthenticationResponse ( response ) def authorize_device ( self , ** data : Any ) -> DeviceAuthorizationResponse : \"\"\" Send a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response \"\"\" if self . device_authorization_endpoint is None : raise AttributeError ( \"No device authorization endpoint defined for this client\" ) response = self . session . post ( self . device_authorization_endpoint , data = data , auth = self . auth ) if response . ok : return self . parse_device_authorization_response ( response ) return self . on_device_authorization_error ( response ) def parse_device_authorization_response ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Parse a Device Authorization Response received by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint. :param response: the response returned by the Device Authorization Endpoint. :return: a :class:`DeviceAuthorizationResponse` \"\"\" device_authorization_response = DeviceAuthorizationResponse ( ** response . json ()) return device_authorization_response def on_device_authorization_error ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Error handler for [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint, when that response is an error. :param response: the response returned by the Device Authorization Endpoint. :return: raises an Exception. But a subclass may return a default response instead. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , DeviceAuthorizationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidDeviceAuthorizationResponse ( \"device authorization endpoint returned an HTTP error without an error message\" , error_json , ) def get_public_jwks ( self ) -> JwkSet : \"\"\" Fetch and parse the public keys from the JWKS endpoint. :return: a JwkSet based on the retrieved keys. \"\"\" if not self . jwks_uri : raise ValueError ( \"No jwks uri defined for this client\" ) jwks = self . session . get ( self . jwks_uri , auth = None ) . json () return JwkSet ( jwks ) @classmethod def from_discovery_endpoint ( cls , url : str , issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, retrieving the endpoint uris from the server metadata exposed on a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client \"\"\" session = session or requests . Session () discovery = session . get ( url ) . json () return cls . from_discovery_document ( discovery , issuer = issuer , auth = auth , session = session ) @classmethod def from_discovery_document ( cls , discovery : Dict [ str , Any ], issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , https : bool = True , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, based on the server metadata from `discovery`. :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client \"\"\" if issuer : # pragma: no branch issuer_from_doc = discovery . get ( \"issuer\" ) if issuer_from_doc != issuer : raise ValueError ( \"issuer mismatch!\" , issuer_from_doc ) token_endpoint = discovery . get ( \"token_endpoint\" ) if token_endpoint is None : raise ValueError ( \"token_endpoint not found in that discovery document\" ) validate_endpoint_uri ( token_endpoint , https = https ) revocation_endpoint = discovery . get ( \"revocation_endpoint\" ) if revocation_endpoint is not None : validate_endpoint_uri ( revocation_endpoint , https = https ) introspection_endpoint = discovery . get ( \"introspection_endpoint\" ) if introspection_endpoint is not None : validate_endpoint_uri ( introspection_endpoint , https = https ) userinfo_endpoint = discovery . get ( \"userinfo_endpoint\" ) if userinfo_endpoint is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) jwks_uri = discovery . get ( \"jwks_uri\" ) if jwks_uri is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) return cls ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , introspection_endpoint = introspection_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , )","title":"OAuth2Client"},{"location":"api/#requests_oauth2client.client.OAuth2Client.__init__","text":"Initialize an OAuth2Client . :param token_endpoint: the Token Endpoint URI where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a requests.auth.AuthBase instance (which will be as-is), or a tuple of (client_id, client_secret) which will initialize an instance of ClientSecretPost , a (client_id, jwk) to initialize a PrivateKeyJwt , or a client_id which will use PublicApp authentication. :param revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens :param introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens :param userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user :param backchannel_authentication_endpoint: the BackChannel Authentication URI :param device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices :param jwks_uri: the JWKS URI to use to obtain the AS public keys :param session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS. Source code in requests_oauth2client/client.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def __init__ ( self , token_endpoint : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], Tuple [ str , Jwk ], str ], revocation_endpoint : Optional [ str ] = None , introspection_endpoint : Optional [ str ] = None , userinfo_endpoint : Optional [ str ] = None , backchannel_authentication_endpoint : Optional [ str ] = None , device_authorization_endpoint : Optional [ str ] = None , pushed_authorization_request_endpoint : Optional [ str ] = None , jwks_uri : Optional [ str ] = None , session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `OAuth2Client`. :param token_endpoint: the Token Endpoint URI where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a [requests.auth.AuthBase][] instance (which will be as-is), or a tuple of `(client_id, client_secret)` which will initialize an instance of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost], a `(client_id, jwk)` to initialize a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt], or a `client_id` which will use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication. :param revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens :param introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens :param userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user :param backchannel_authentication_endpoint: the BackChannel Authentication URI :param device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices :param jwks_uri: the JWKS URI to use to obtain the AS public keys :param session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS. \"\"\" self . token_endpoint = str ( token_endpoint ) self . revocation_endpoint = ( str ( revocation_endpoint ) if revocation_endpoint else None ) self . introspection_endpoint = ( str ( introspection_endpoint ) if introspection_endpoint else None ) self . userinfo_endpoint = str ( userinfo_endpoint ) if userinfo_endpoint else None self . backchannel_authentication_endpoint = ( str ( backchannel_authentication_endpoint ) if backchannel_authentication_endpoint else None ) self . device_authorization_endpoint = ( str ( device_authorization_endpoint ) if device_authorization_endpoint else None ) self . pushed_authorization_request_endpoint = ( str ( pushed_authorization_request_endpoint ) if pushed_authorization_request_endpoint else None ) self . jwks_uri = str ( jwks_uri ) if jwks_uri else None self . session = session or requests . Session () self . auth = client_auth_factory ( auth , ClientSecretPost )","title":"__init__()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code","text":"Send a request to the token endpoint with the authorization_code grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , code , etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse Source code in requests_oauth2client/client.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def authorization_code ( self , code : Union [ str , AuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `authorization_code` grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" if isinstance ( code , AuthorizationResponse ): if not isinstance ( code . code , str ): raise ValueError ( \"This AuthorizationResponse doesn't contain an authorization code\" ) token_kwargs . setdefault ( \"code_verifer\" , code . code_verifier ) token_kwargs . setdefault ( \"redirect_uri\" , code . redirect_uri ) code = code . code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"authorization_code\" , code = code , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs )","title":"authorization_code()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorize_device","text":"Send a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response Source code in requests_oauth2client/client.py 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 def authorize_device ( self , ** data : Any ) -> DeviceAuthorizationResponse : \"\"\" Send a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response \"\"\" if self . device_authorization_endpoint is None : raise AttributeError ( \"No device authorization endpoint defined for this client\" ) response = self . session . post ( self . device_authorization_endpoint , data = data , auth = self . auth ) if response . ok : return self . parse_device_authorization_response ( response ) return self . on_device_authorization_error ( response )","title":"authorize_device()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.backchannel_authentication_request","text":"Send a CIBA Authentication Request. :param scope: the scope to include in the request. :param client_notification_token: the Client Notification Token to include in the request. :param acr_values: the acr values to include in the request. :param login_hint_token: the Login Hint Token to include in the request. :param id_token_hint: the ID Token Hint to include in the request. :param login_hint: the Login Hint to include in the request. :param binding_message: the Binding Message to include in the request. :param user_code: the User Code to include in the request :param requested_expiry: the Requested Expiry, in seconds, to include in the request. :param private_jwk: the JWK to use to sign the request (optional) :param alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter. :param requests_kwargs: additional parameters for :param ciba_kwargs: additional parameters to include in the request. :return: a BackChannelAuthenticationResponse Source code in requests_oauth2client/client.py 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 def backchannel_authentication_request ( self , scope : Union [ None , str , Iterable [ str ]] = \"openid\" , client_notification_token : Optional [ str ] = None , acr_values : Union [ None , str , Iterable [ str ]] = None , login_hint_token : Optional [ str ] = None , id_token_hint : Optional [ str ] = None , login_hint : Optional [ str ] = None , binding_message : Optional [ str ] = None , user_code : Optional [ str ] = None , requested_expiry : Optional [ int ] = None , private_jwk : Union [ Jwk , Dict [ str , Any ], None ] = None , alg : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** ciba_kwargs : Any , ) -> BackChannelAuthenticationResponse : \"\"\" Send a CIBA Authentication Request. :param scope: the scope to include in the request. :param client_notification_token: the Client Notification Token to include in the request. :param acr_values: the acr values to include in the request. :param login_hint_token: the Login Hint Token to include in the request. :param id_token_hint: the ID Token Hint to include in the request. :param login_hint: the Login Hint to include in the request. :param binding_message: the Binding Message to include in the request. :param user_code: the User Code to include in the request :param requested_expiry: the Requested Expiry, in seconds, to include in the request. :param private_jwk: the JWK to use to sign the request (optional) :param alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter. :param requests_kwargs: additional parameters for :param ciba_kwargs: additional parameters to include in the request. :return: a BackChannelAuthenticationResponse \"\"\" if not self . backchannel_authentication_endpoint : raise AttributeError ( \"No backchannel authentication endpoint defined for this client\" ) if not ( login_hint or login_hint_token or id_token_hint ): raise ValueError ( \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) if ( ( login_hint_token and id_token_hint ) or ( login_hint and id_token_hint ) or ( login_hint_token and login_hint ) ): raise ValueError ( \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported `scope` value\" ) from exc if acr_values is not None and not isinstance ( acr_values , str ): try : acr_values = \" \" . join ( acr_values ) except Exception as exc : raise ValueError ( \"Unsupported `acr_values`\" ) from exc data = dict ( ciba_kwargs , scope = scope , client_notification_token = client_notification_token , acr_values = acr_values , login_hint_token = login_hint_token , id_token_hint = id_token_hint , login_hint = login_hint , binding_message = binding_message , user_code = user_code , requested_expiry = requested_expiry , ) if private_jwk is not None : data = { \"request\" : str ( Jwt . sign ( data , jwk = private_jwk , alg = alg ))} response = self . session . post ( self . backchannel_authentication_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_backchannel_authentication_response ( response ) return self . on_backchannel_authentication_error ( response )","title":"backchannel_authentication_request()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.ciba","text":"Send a CIBA request to the Token Endpoint. A CIBA request is a Token Request using the urn:openid:params:grant-type:ciba grant. :param auth_req_id: an authentication request ID, as returned by the AS :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , auth_req_id , etc. :return: Source code in requests_oauth2client/client.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def ciba ( self , auth_req_id : Union [ str , BackChannelAuthenticationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a CIBA request to the Token Endpoint. A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant. :param auth_req_id: an authentication request ID, as returned by the AS :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc. :return: \"\"\" if isinstance ( auth_req_id , BackChannelAuthenticationResponse ): auth_req_id = auth_req_id . auth_req_id requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:openid:params:grant-type:ciba\" , auth_req_id = auth_req_id , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs )","title":"ciba()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_credentials","text":"Send a request to the token endpoint using the client_credentials grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside grant_type . Common parameters to pass that way include scope , audience , resource , etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse Source code in requests_oauth2client/client.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def client_credentials ( self , requests_kwargs : Optional [ Dict [ str , Any ]] = None , scope : Optional [ Union [ str , Iterable [ str ]]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint using the `client_credentials` grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters to pass that way include `scope`, `audience`, `resource`, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc data = dict ( grant_type = \"client_credentials\" , scope = scope , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs )","title":"client_credentials()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.device_code","text":"Send a request to the token endpoint with the urn:ietf:params:oauth:grant-type:device_code grant. :param device_code: a device code, as received during the Device Authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , device_code , etc. :return: a BearerToken Source code in requests_oauth2client/client.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 def device_code ( self , device_code : Union [ str , DeviceAuthorizationResponse ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `urn:ietf:params:oauth:grant-type:device_code` grant. :param device_code: a device code, as received during the Device Authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc. :return: a BearerToken \"\"\" if isinstance ( device_code , DeviceAuthorizationResponse ): device_code = device_code . device_code requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:device_code\" , device_code = device_code , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs )","title":"device_code()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_document","text":"Initialise an OAuth2Client, based on the server metadata from discovery . :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client Source code in requests_oauth2client/client.py 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 @classmethod def from_discovery_document ( cls , discovery : Dict [ str , Any ], issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , https : bool = True , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, based on the server metadata from `discovery`. :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client \"\"\" if issuer : # pragma: no branch issuer_from_doc = discovery . get ( \"issuer\" ) if issuer_from_doc != issuer : raise ValueError ( \"issuer mismatch!\" , issuer_from_doc ) token_endpoint = discovery . get ( \"token_endpoint\" ) if token_endpoint is None : raise ValueError ( \"token_endpoint not found in that discovery document\" ) validate_endpoint_uri ( token_endpoint , https = https ) revocation_endpoint = discovery . get ( \"revocation_endpoint\" ) if revocation_endpoint is not None : validate_endpoint_uri ( revocation_endpoint , https = https ) introspection_endpoint = discovery . get ( \"introspection_endpoint\" ) if introspection_endpoint is not None : validate_endpoint_uri ( introspection_endpoint , https = https ) userinfo_endpoint = discovery . get ( \"userinfo_endpoint\" ) if userinfo_endpoint is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) jwks_uri = discovery . get ( \"jwks_uri\" ) if jwks_uri is not None : validate_endpoint_uri ( userinfo_endpoint , https = https ) return cls ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , introspection_endpoint = introspection_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , )","title":"from_discovery_document()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_endpoint","text":"Initialise an OAuth2Client, retrieving the endpoint uris from the server metadata exposed on a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client Source code in requests_oauth2client/client.py 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 @classmethod def from_discovery_endpoint ( cls , url : str , issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, retrieving the endpoint uris from the server metadata exposed on a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client \"\"\" session = session or requests . Session () discovery = session . get ( url ) . json () return cls . from_discovery_document ( discovery , issuer = issuer , auth = auth , session = session )","title":"from_discovery_endpoint()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.get_public_jwks","text":"Fetch and parse the public keys from the JWKS endpoint. :return: a JwkSet based on the retrieved keys. Source code in requests_oauth2client/client.py 928 929 930 931 932 933 934 935 936 937 def get_public_jwks ( self ) -> JwkSet : \"\"\" Fetch and parse the public keys from the JWKS endpoint. :return: a JwkSet based on the retrieved keys. \"\"\" if not self . jwks_uri : raise ValueError ( \"No jwks uri defined for this client\" ) jwks = self . session . get ( self . jwks_uri , auth = None ) . json () return JwkSet ( jwks )","title":"get_public_jwks()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.get_token_type","text":"Return a standardised token type identifier, based on a short token_type hint and/or a token value. :param token_type: a token_type hint, as str . May be \"access_token\", \"refresh_token\" or \"id_token\" (optional) :param token: a token value, as an instance of BearerToken or IdToken, or as a str . :return: the token_type as defined in the Token Exchange RFC8693. Source code in requests_oauth2client/client.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 @classmethod def get_token_type ( cls , token_type : Optional [ str ] = None , token : Union [ None , str , BearerToken , IdToken ] = None , ) -> str : \"\"\" Return a standardised token type identifier, based on a short `token_type` hint and/or a token value. :param token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional) :param token: a token value, as an instance of BearerToken or IdToken, or as a `str`. :return: the token_type as defined in the Token Exchange RFC8693. \"\"\" if not ( token_type or token ): raise ValueError ( \"Cannot determine type of an empty token without a token_type hint\" ) if token_type is None : if isinstance ( token , str ): raise ValueError ( \"Cannot determine the type of provided token when it is a bare str. \" \"Please specify a token_type.\" ) elif isinstance ( token , BearerToken ): return \"urn:ietf:params:oauth:token-type:access_token\" elif isinstance ( token , IdToken ): return \"urn:ietf:params:oauth:token-type:id_token\" else : raise TypeError ( \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\" , type ( token ), ) elif token_type == \"access_token\" : if token is not None and not isinstance ( token , ( str , BearerToken )): raise TypeError ( \"The supplied token is not a BearerToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:access_token\" elif token_type == \"refresh_token\" : if ( token is not None and isinstance ( token , BearerToken ) and not token . refresh_token ): raise ValueError ( \"The supplied BearerToken doesn't have a refresh_token.\" ) return \"urn:ietf:params:oauth:token-type:refresh_token\" elif token_type == \"id_token\" : if token is not None and not isinstance ( token , ( str , IdToken )): raise TypeError ( \"The supplied token is not an IdToken or a string representation of it.\" , type ( token ), ) return \"urn:ietf:params:oauth:token-type:id_token\" else : return { \"saml1\" : \"urn:ietf:params:oauth:token-type:saml1\" , \"saml2\" : \"urn:ietf:params:oauth:token-type:saml2\" , \"jwt\" : \"urn:ietf:params:oauth:token-type:jwt\" , } . get ( token_type , token_type )","title":"get_token_type()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.introspect_token","text":"Send a request to the configured Introspection Endpoint. :param token: the token to introspect. :param token_type_hint: the token_type_hint to include in the request. :param requests_kwargs: additional parameters to the underling call to requests.post() :param introspect_kwargs: additional parameters to send to the introspection endpoint. :return: the response as returned by the Introspection Endpoint. Source code in requests_oauth2client/client.py 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def introspect_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** introspect_kwargs : Any , ) -> Any : \"\"\" Send a request to the configured Introspection Endpoint. :param token: the token to introspect. :param token_type_hint: the token_type_hint to include in the request. :param requests_kwargs: additional parameters to the underling call to requests.post() :param introspect_kwargs: additional parameters to send to the introspection endpoint. :return: the response as returned by the Introspection Endpoint. \"\"\" if not self . introspection_endpoint : raise AttributeError ( \"No introspection endpoint defined for this client\" ) requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( introspect_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . introspection_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_introspection_response ( response ) return self . on_introspection_error ( response )","title":"introspect_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_backchannel_authentication_error","text":"Error handler for backchannel_authentication_request() . Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error. :param response: the response returned by the BackChannel Authentication Endpoint. :return: raises an exception. But a subclass can return a default response instead. Source code in requests_oauth2client/client.py 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 def on_backchannel_authentication_error ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Error handler for [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint, when it is an error. :param response: the response returned by the BackChannel Authentication Endpoint. :return: raises an exception. But a subclass can return a default response instead. \"\"\" try : error_json = response . json () except ValueError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , BackChannelAuthenticationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidBackChannelAuthenticationResponse ( response )","title":"on_backchannel_authentication_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_device_authorization_error","text":"Error handler for authorize_device() . Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error. :param response: the response returned by the Device Authorization Endpoint. :return: raises an Exception. But a subclass may return a default response instead. Source code in requests_oauth2client/client.py 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 def on_device_authorization_error ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Error handler for [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint, when that response is an error. :param response: the response returned by the Device Authorization Endpoint. :return: raises an Exception. But a subclass may return a default response instead. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , DeviceAuthorizationError ) raise exception_class ( error , error_description , error_uri ) raise InvalidDeviceAuthorizationResponse ( \"device authorization endpoint returned an HTTP error without an error message\" , error_json , )","title":"on_device_authorization_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_introspection_error","text":"Error handler for introspect_token() . Invoked by introspect_token() to parse the returned response in the case an error is returned. :param response: the response as returned by the Introspection Endpoint. :return: raises exeptions. A subclass can return a default response instead. Source code in requests_oauth2client/client.py 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 def on_introspection_error ( self , response : requests . Response ) -> Any : \"\"\" Error handler for [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response in the case an error is returned. :param response: the response as returned by the Introspection Endpoint. :return: raises exeptions. A subclass can return a default response instead. \"\"\" try : data = response . json () except ValueError : try : response . raise_for_status () except Exception as exc : raise UnknownIntrospectionError ( response ) from exc error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , IntrospectionError ) raise exception_class ( error , error_description , error_uri ) raise UnknownIntrospectionError ( response )","title":"on_introspection_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_pushed_authorization_request_error","text":"Error Handler for Pushed Authorization Endpoint errors. :param response: the HTTP response as returned by the AS PAR endpoint. :return: a RequestUriParameterAuthorizationRequest, if the error is recoverable :raises: Exception Source code in requests_oauth2client/client.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 def on_pushed_authorization_request_error ( self , response : requests . Response ) -> RequestUriParameterAuthorizationRequest : \"\"\"Error Handler for Pushed Authorization Endpoint errors. :param response: the HTTP response as returned by the AS PAR endpoint. :return: a RequestUriParameterAuthorizationRequest, if the error is recoverable :raises: Exception \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidPushedAuthorizationResponse ( \"pushed authorization endpoint returned an HTTP error without error message\" , error_json , )","title":"on_pushed_authorization_request_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_revocation_error","text":"Error handler for revoke_token() . Invoked by :method: revoke_token when the revocation endpoint returns an error. :param response: the Response as returned by the Revocation Endpoint :return: returns False to signal that an error occurred. May raise exceptions instead depending on the revocation response. Source code in requests_oauth2client/client.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 def on_revocation_error ( self , response : requests . Response ) -> bool : \"\"\" Error handler for [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token]. Invoked by :method:`revoke_token` when the revocation endpoint returns an error. :param response: the [Response][requests.Response] as returned by the Revocation Endpoint :return: returns `False` to signal that an error occurred. May raise exceptions instead depending on the revocation response. \"\"\" try : data = response . json () except ValueError : return False error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , RevocationError ) raise exception_class ( error , error_description , error_uri ) return False","title":"on_revocation_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_token_error","text":"Error handler for token_request . Invoked by token_request when the Token Endpoint returns an error. :param response: the Response returned by the Token Endpoint. :return: returns nothing and raises an exception instead. But a subclass may return a BearerToken to implement a default behaviour if needed. Source code in requests_oauth2client/client.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def on_token_error ( self , response : requests . Response ) -> BearerToken : \"\"\" Error handler for [token_request][requests_oauth2client.client.OAuth2Client.token_request]. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the Token Endpoint returns an error. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: returns nothing and raises an exception instead. But a subclass may return a [BearerToken][requests_oauth2client.tokens.BearerToken] to implement a default behaviour if needed. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidTokenResponse ( \"token endpoint returned an HTTP error without error message\" , error_json , )","title":"on_token_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_backchannel_authentication_response","text":"Parse a BackChannel Authentication Response received by backchannel_authentication_request() . Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint. :param response: the response returned by the BackChannel Authentication Endpoint. :return: a :class: BackChannelAuthenticationResponse Source code in requests_oauth2client/client.py 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 def parse_backchannel_authentication_response ( self , response : requests . Response ) -> BackChannelAuthenticationResponse : \"\"\" Parse a BackChannel Authentication Response received by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]. Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response returned by the BackChannel Authentication Endpoint. :param response: the response returned by the BackChannel Authentication Endpoint. :return: a :class:`BackChannelAuthenticationResponse` \"\"\" try : return BackChannelAuthenticationResponse ( ** response . json ()) except TypeError as exc : raise InvalidBackChannelAuthenticationResponse ( response ) from exc","title":"parse_backchannel_authentication_response()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_device_authorization_response","text":"Parse a Device Authorization Response received by authorize_device() . Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint. :param response: the response returned by the Device Authorization Endpoint. :return: a :class: DeviceAuthorizationResponse Source code in requests_oauth2client/client.py 889 890 891 892 893 894 895 896 897 898 899 900 def parse_device_authorization_response ( self , response : requests . Response ) -> DeviceAuthorizationResponse : \"\"\" Parse a Device Authorization Response received by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]. Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint. :param response: the response returned by the Device Authorization Endpoint. :return: a :class:`DeviceAuthorizationResponse` \"\"\" device_authorization_response = DeviceAuthorizationResponse ( ** response . json ()) return device_authorization_response","title":"parse_device_authorization_response()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_introspection_response","text":"Parse Token Introspection Responses received by introspect_token() . Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string. :param response: the Response as returned by the Introspection Endpoint. :return: the decoded JSON content, or a str with the content. Source code in requests_oauth2client/client.py 692 693 694 695 696 697 698 699 700 701 702 703 704 def parse_introspection_response ( self , response : requests . Response ) -> Any : \"\"\" Parse Token Introspection Responses received by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]. Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string. :param response: the [Response][requests.Response] as returned by the Introspection Endpoint. :return: the decoded JSON content, or a `str` with the content. \"\"\" try : return response . json () except ValueError : return response . text","title":"parse_introspection_response()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_token_response","text":"Parse a Response returned by the Token Endpoint. Invoked by token_request to parse responses returned by the Token Endpoint. Those response contain an access_token and additional attributes. :param response: the Response returned by the Token Endpoint. :return: a BearerToken based on the response contents. Source code in requests_oauth2client/client.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def parse_token_response ( self , response : requests . Response ) -> BearerToken : \"\"\" Parse a Response returned by the Token Endpoint. Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse responses returned by the Token Endpoint. Those response contain an `access_token` and additional attributes. :param response: the [Response][requests.Response] returned by the Token Endpoint. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] based on the response contents. \"\"\" try : token_response = BearerToken ( ** response . json ()) return token_response except Exception as response_class_exc : try : return self . on_token_error ( response ) except Exception as token_error_exc : raise token_error_exc from response_class_exc","title":"parse_token_response()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_userinfo_response","text":"Given a response obtained from the userinfo endpoint, extract its JSON content. :param resp: a Response returned from the UserInfo endpoint. :return: the parsed JSON content from this response. Source code in requests_oauth2client/client.py 460 461 462 463 464 465 466 467 def parse_userinfo_response ( self , resp : requests . Response ) -> Any : \"\"\" Given a response obtained from the userinfo endpoint, extract its JSON content. :param resp: a [Response][requests.Response] returned from the UserInfo endpoint. :return: the parsed JSON content from this response. \"\"\" return resp . json ()","title":"parse_userinfo_response()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.pushed_authorization_request","text":"Send a Pushed Authorization Request, return a RequestUriParameterAuthorizationRequest initialized with the AS response. :param authorization_request: the authorization request to send :return: the RequestUriParameterAuthorizationRequest initialized based on the AS response Source code in requests_oauth2client/client.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def pushed_authorization_request ( self , authorization_request : AuthorizationRequest ) -> RequestUriParameterAuthorizationRequest : \"\"\"Send a Pushed Authorization Request, return a RequestUriParameterAuthorizationRequest initialized with the AS response. :param authorization_request: the authorization request to send :return: the RequestUriParameterAuthorizationRequest initialized based on the AS response \"\"\" if not self . pushed_authorization_request_endpoint : raise AttributeError ( \"No 'pushed_authorization_request_endpoint' defined for this client.\" ) response = self . session . post ( self . pushed_authorization_request_endpoint , data = authorization_request . args , auth = self . auth , ) if not response . ok : return self . on_pushed_authorization_request_error ( response ) response_json = response . json () request_uri = response_json . get ( \"request_uri\" ) expires_in = response_json . get ( \"expires_in\" ) return RequestUriParameterAuthorizationRequest ( authorization_endpoint = authorization_request . authorization_endpoint , client_id = authorization_request . client_id , request_uri = request_uri , expires_in = expires_in , )","title":"pushed_authorization_request()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.refresh_token","text":"Send a request to the token endpoint with the refresh_token grant. :param refresh_token: a refresh_token, as a string, or as a BearerToken. That BearerToken must have a refresh_token . :param token_kwargs: additional parameters for the token endpoint, alongside grant_type , refresh_token , etc. :param requests_kwargs: additional parameters for the call to requests :return: a BearerToken Source code in requests_oauth2client/client.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a request to the token endpoint with the `refresh_token` grant. :param refresh_token: a refresh_token, as a string, or as a BearerToken. That BearerToken must have a `refresh_token`. :param token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `refresh_token`, etc. :param requests_kwargs: additional parameters for the call to `requests` :return: a BearerToken \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"This BearerToken doesn't have a refresh_token\" ) refresh_token = refresh_token . refresh_token requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"refresh_token\" , refresh_token = refresh_token , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs )","title":"refresh_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_access_token","text":"Send a request to the Revocation Endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint Source code in requests_oauth2client/client.py 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 def revoke_access_token ( self , access_token : Union [ BearerToken , str ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint \"\"\" return self . revoke_token ( access_token , token_type_hint = \"access_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , )","title":"revoke_access_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token","text":"Send a request to the Revocation Endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: True if the revocation request is successful, False if this client has no configured revocation endpoint. Source code in requests_oauth2client/client.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def revoke_refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a request to the Revocation Endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: `True` if the revocation request is successful, `False` if this client has no configured revocation endpoint. \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) refresh_token = refresh_token . refresh_token return self . revoke_token ( refresh_token , token_type_hint = \"refresh_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , )","title":"revoke_refresh_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_token","text":"Send a Token Revocation request. By default, authentication will be the same than the one used for the Token Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: True if the revocation succeeds, False if no revocation endpoint is present or a non-standardised error is returned. Source code in requests_oauth2client/client.py 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def revoke_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Send a Token Revocation request. By default, authentication will be the same than the one used for the Token Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: `True` if the revocation succeeds, `False` if no revocation endpoint is present or a non-standardised error is returned. \"\"\" if not self . revocation_endpoint : return False requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( revoke_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . revocation_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return True return self . on_revocation_error ( response )","title":"revoke_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_exchange","text":"Send a Token Exchange request. A Token Exchange request is actually a request to the Token Endpoint with a grant_type urn:ietf:params:oauth:grant-type:token-exchange . :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on type(subject_token) . :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on type(actor_token) . :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying requests.post() call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. Source code in requests_oauth2client/client.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def token_exchange ( self , subject_token : Union [ str , BearerToken , IdToken ], subject_token_type : Optional [ str ] = None , actor_token : Union [ None , str , BearerToken , IdToken ] = None , actor_token_type : Optional [ str ] = None , requested_token_type : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Send a Token Exchange request. A Token Exchange request is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`. :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on `type(subject_token)`. :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on `type(actor_token)`. :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying `requests.post()` call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. \"\"\" requests_kwargs = requests_kwargs or {} try : subject_token_type = self . get_token_type ( subject_token_type , subject_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'subject_token' you provided. \" \"Please specify a 'subject_token_type'.\" ) if actor_token : # pragma: no branch try : actor_token_type = self . get_token_type ( actor_token_type , actor_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of 'actor_token' you provided. \" \"Please specify an 'actor_token_type'.\" ) data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:token-exchange\" , subject_token = subject_token , subject_token_type = subject_token_type , actor_token = actor_token , actor_token_type = actor_token_type , requested_token_type = requested_token_type , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs )","title":"token_exchange()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_request","text":"Send a request to the token endpoint. Authentication will be added automatically. :param data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request. :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as BearerToken instance. Source code in requests_oauth2client/client.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def token_request ( self , data : Dict [ str , Any ], timeout : int = 10 , ** requests_kwargs : Any ) -> BearerToken : \"\"\" Send a request to the token endpoint. Authentication will be added automatically. :param data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request. :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as [BearerToken][requests_oauth2client.tokens.BearerToken] instance. \"\"\" requests_kwargs = { key : value for key , value in requests_kwargs . items () if value is not None and value != \"\" } response = self . session . post ( self . token_endpoint , auth = self . auth , data = data , timeout = timeout , ** requests_kwargs , ) if response . ok : return self . parse_token_response ( response ) return self . on_token_error ( response )","title":"token_request()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.userinfo","text":"Call the UserInfo endpoint with the specified access_token and return the result. :param access_token: the access token to use :return: the Response returned by the userinfo endpoint. Source code in requests_oauth2client/client.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 def userinfo ( self , access_token : Union [ BearerToken , str ]) -> Any : \"\"\" Call the UserInfo endpoint with the specified access_token and return the result. :param access_token: the access token to use :return: the [Response][requests.Response] returned by the userinfo endpoint. \"\"\" if not self . userinfo_endpoint : raise AttributeError ( \"No userinfo_endpoint defined for this client\" ) response = self . session . post ( self . userinfo_endpoint , auth = BearerAuth ( access_token ) ) return self . parse_userinfo_response ( response )","title":"userinfo()"},{"location":"api/#requests_oauth2client.client_authentication","text":"This modules implements multiple Client Authentication Methods for OAuth 2.0 client to authenticate to an AS.","title":"client_authentication"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAuthenticationMethod","text":"Bases: requests . auth . AuthBase Base class for all Client Authentication methods. This extends [requests.auth.AuthBase]. This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request. Source code in requests_oauth2client/client_authentication.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class BaseClientAuthenticationMethod ( requests . auth . AuthBase ): \"\"\" Base class for all Client Authentication methods. This extends [requests.auth.AuthBase]. This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request. \"\"\" def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Check that the request is suitable for Client Authentication. It checks: * that the method is `POST` * that the Content-Type is \"application/x-www-form-urlencoded\" or None :param request: a [requests.PreparedRequest][] :return: a [requests.PreparedRequest][], unmodified \"\"\" if request . method != \"POST\" or request . headers . get ( \"Content-Type\" ) not in ( \"application/x-www-form-urlencoded\" , None , ): raise RuntimeError ( \"This request is not suitable for OAuth 2.0 Client Authentication\" ) return request","title":"BaseClientAuthenticationMethod"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAuthenticationMethod.__call__","text":"Check that the request is suitable for Client Authentication. It checks: * that the method is POST * that the Content-Type is \"application/x-www-form-urlencoded\" or None :param request: a requests.PreparedRequest :return: a requests.PreparedRequest , unmodified Source code in requests_oauth2client/client_authentication.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Check that the request is suitable for Client Authentication. It checks: * that the method is `POST` * that the Content-Type is \"application/x-www-form-urlencoded\" or None :param request: a [requests.PreparedRequest][] :return: a [requests.PreparedRequest][], unmodified \"\"\" if request . method != \"POST\" or request . headers . get ( \"Content-Type\" ) not in ( \"application/x-www-form-urlencoded\" , None , ): raise RuntimeError ( \"This request is not suitable for OAuth 2.0 Client Authentication\" ) return request","title":"__call__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod","text":"Bases: BaseClientAuthenticationMethod Base class for assertion based client authentication methods. Source code in requests_oauth2client/client_authentication.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class ClientAssertionAuthenticationMethod ( BaseClientAuthenticationMethod ): \"\"\"Base class for assertion based client authentication methods.\"\"\" def __init__ ( self , client_id : str , alg : str , lifetime : int , jti_gen : Callable [[], str ] ): \"\"\" Initialize a `ClientAssertionAuthenticationMethod` Base Auth Handler. :param client_id: the client_id to use :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" self . client_id = str ( client_id ) self . alg = alg self . lifetime = lifetime self . jti_gen = jti_gen def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion for a specific audience. :param audience: the audience to use for the `aud` claim of the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" raise NotImplementedError () # pragma: no cover def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add a `client_assertion` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_assertion` field. \"\"\" request = super () . __call__ ( request ) token_endpoint = request . url assert token_endpoint is not None data = furl . Query ( request . body ) client_assertion = self . client_assertion ( token_endpoint ) data . set ( [ ( \"client_id\" , self . client_id ), ( \"client_assertion\" , client_assertion ), ( \"client_assertion_type\" , \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\" , ), ] ) request . prepare_body ( data . params , files = None ) return request","title":"ClientAssertionAuthenticationMethod"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod.__call__","text":"Add a client_assertion field in the request body. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added client_assertion field. Source code in requests_oauth2client/client_authentication.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add a `client_assertion` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_assertion` field. \"\"\" request = super () . __call__ ( request ) token_endpoint = request . url assert token_endpoint is not None data = furl . Query ( request . body ) client_assertion = self . client_assertion ( token_endpoint ) data . set ( [ ( \"client_id\" , self . client_id ), ( \"client_assertion\" , client_assertion ), ( \"client_assertion_type\" , \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\" , ), ] ) request . prepare_body ( data . params , files = None ) return request","title":"__call__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod.__init__","text":"Initialize a ClientAssertionAuthenticationMethod Base Auth Handler. :param client_id: the client_id to use :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids ( jti ) for generated Client Assertions. Source code in requests_oauth2client/client_authentication.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __init__ ( self , client_id : str , alg : str , lifetime : int , jti_gen : Callable [[], str ] ): \"\"\" Initialize a `ClientAssertionAuthenticationMethod` Base Auth Handler. :param client_id: the client_id to use :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" self . client_id = str ( client_id ) self . alg = alg self . lifetime = lifetime self . jti_gen = jti_gen","title":"__init__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod.client_assertion","text":"Generate a Client Assertion for a specific audience. :param audience: the audience to use for the aud claim of the generated Client Assertion. :return: a Client Assertion, as str . Source code in requests_oauth2client/client_authentication.py 115 116 117 118 119 120 121 122 def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion for a specific audience. :param audience: the audience to use for the `aud` claim of the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" raise NotImplementedError () # pragma: no cover","title":"client_assertion()"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic","text":"Bases: BaseClientAuthenticationMethod Implement client_secret_basic authentication (client_id and client_secret passed as Basic authentication). Source code in requests_oauth2client/client_authentication.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class ClientSecretBasic ( BaseClientAuthenticationMethod ): \"\"\"Implement `client_secret_basic` authentication (client_id and client_secret passed as Basic authentication).\"\"\" def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretBasic` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret ) def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the appropriate `Authorization: Basic` header with `client_id` as username and `client_secret` as password. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added Authorization header. \"\"\" request = super () . __call__ ( request ) b64encoded_credentials = ( BinaPy ( f \" { self . client_id } : { self . client_secret } \" ) . to ( \"b64\" ) . ascii () ) request . headers [ \"Authorization\" ] = f \"Basic { b64encoded_credentials } \" return request","title":"ClientSecretBasic"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic.__call__","text":"Add the appropriate Authorization: Basic header with client_id as username and client_secret as password. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added Authorization header. Source code in requests_oauth2client/client_authentication.py 54 55 56 57 58 59 60 61 62 63 64 65 66 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the appropriate `Authorization: Basic` header with `client_id` as username and `client_secret` as password. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added Authorization header. \"\"\" request = super () . __call__ ( request ) b64encoded_credentials = ( BinaPy ( f \" { self . client_id } : { self . client_secret } \" ) . to ( \"b64\" ) . ascii () ) request . headers [ \"Authorization\" ] = f \"Basic { b64encoded_credentials } \" return request","title":"__call__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic.__init__","text":"Initialize a ClientSecretBasic Auth Handler. :param client_id: client_id to use. :param client_secret: client_secret to use. Source code in requests_oauth2client/client_authentication.py 44 45 46 47 48 49 50 51 52 def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretBasic` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret )","title":"__init__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt","text":"Bases: ClientAssertionAuthenticationMethod Implement client_secret_jwt client authentication method (using a client_assertion field, symmetrically signed with the client_secret). Source code in requests_oauth2client/client_authentication.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 class ClientSecretJwt ( ClientAssertionAuthenticationMethod ): \"\"\"Implement `client_secret_jwt` client authentication method (using a `client_assertion` field, symmetrically signed with the client_secret).\"\"\" def __init__ ( self , client_id : str , client_secret : str , alg : str = \"HS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `ClientSecretJwt` Auth Handler. :param client_id: the `client_id` to use. :param client_secret: the `client_secret` to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . client_secret = str ( client_secret ) def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, symmetrically signed with the `client_secret` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwk = SymmetricJwk . from_bytes ( self . client_secret . encode ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = jwk , alg = self . alg , ) return str ( jwt )","title":"ClientSecretJwt"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt.__init__","text":"Initialize a ClientSecretJwt Auth Handler. :param client_id: the client_id to use. :param client_secret: the client_secret to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids ( jti ) for generated Client Assertions. Source code in requests_oauth2client/client_authentication.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , client_id : str , client_secret : str , alg : str = \"HS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `ClientSecretJwt` Auth Handler. :param client_id: the `client_id` to use. :param client_secret: the `client_secret` to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . client_secret = str ( client_secret )","title":"__init__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt.client_assertion","text":"Generate a Client Assertion, symmetrically signed with the client_secret as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion, as str . Source code in requests_oauth2client/client_authentication.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, symmetrically signed with the `client_secret` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion, as `str`. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwk = SymmetricJwk . from_bytes ( self . client_secret . encode ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = jwk , alg = self . alg , ) return str ( jwt )","title":"client_assertion()"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost","text":"Bases: BaseClientAuthenticationMethod Implement client_secret_post client authentication method (client_id and client_secret passed as part of the request form data). Source code in requests_oauth2client/client_authentication.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class ClientSecretPost ( BaseClientAuthenticationMethod ): \"\"\"Implement `client_secret_post` client authentication method (client_id and client_secret passed as part of the request form data).\"\"\" def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretPost` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret ) def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` and `client_secret` parameters in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added client credentials fields. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id ), ( \"client_secret\" , self . client_secret )]) request . prepare_body ( data . params , files = None ) return request","title":"ClientSecretPost"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost.__call__","text":"Add the client_id and client_secret parameters in the request body. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added client credentials fields. Source code in requests_oauth2client/client_authentication.py 82 83 84 85 86 87 88 89 90 91 92 93 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` and `client_secret` parameters in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added client credentials fields. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id ), ( \"client_secret\" , self . client_secret )]) request . prepare_body ( data . params , files = None ) return request","title":"__call__()"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost.__init__","text":"Initialize a ClientSecretPost Auth Handler. :param client_id: client_id to use. :param client_secret: client_secret to use. Source code in requests_oauth2client/client_authentication.py 72 73 74 75 76 77 78 79 80 def __init__ ( self , client_id : str , client_secret : str ): \"\"\" Initialize a `ClientSecretPost` Auth Handler. :param client_id: `client_id` to use. :param client_secret: `client_secret` to use. \"\"\" self . client_id = str ( client_id ) self . client_secret = str ( client_secret )","title":"__init__()"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt","text":"Bases: ClientAssertionAuthenticationMethod Implement private_key_jwt client authentication method (client_assertion asymmetrically signed with a private key). Source code in requests_oauth2client/client_authentication.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 class PrivateKeyJwt ( ClientAssertionAuthenticationMethod ): \"\"\"Implement `private_key_jwt` client authentication method (client_assertion asymmetrically signed with a private key).\"\"\" def __init__ ( self , client_id : str , private_jwk : Union [ Jwk , Dict [ str , Any ]], alg : str = \"RS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `PrivateKeyJwt` Auth Handler. :param client_id: the `client_id` to use. :param private_jwk: the private JWK to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" if not isinstance ( private_jwk , Jwk ): private_jwk = Jwk ( private_jwk ) alg = private_jwk . alg or alg if not alg : raise ValueError ( \"Asymmetric signing requires an alg, either as part of the private JWK, or passed as parameter\" ) kid = private_jwk . get ( \"kid\" ) if not kid : raise ValueError ( \"Asymmetric signing requires a kid, either as part of the private JWK, or passed as parameter\" ) super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . private_jwk = private_jwk def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, asumetrically signed with `private_jwk` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = self . private_jwk , alg = self . alg , ) return str ( jwt )","title":"PrivateKeyJwt"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt.__init__","text":"Initialize a PrivateKeyJwt Auth Handler. :param client_id: the client_id to use. :param private_jwk: the private JWK to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids ( jti ) for generated Client Assertions. Source code in requests_oauth2client/client_authentication.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def __init__ ( self , client_id : str , private_jwk : Union [ Jwk , Dict [ str , Any ]], alg : str = \"RS256\" , lifetime : int = 60 , jti_gen : Callable [[], Any ] = lambda : uuid4 (), ) -> None : \"\"\" Initialize a `PrivateKeyJwt` Auth Handler. :param client_id: the `client_id` to use. :param private_jwk: the private JWK to use to sign generated Client Assertions. :param alg: the alg to use to sign generated Client Assertions. :param lifetime: the lifetime to use for generated Client Assertions. :param jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions. \"\"\" if not isinstance ( private_jwk , Jwk ): private_jwk = Jwk ( private_jwk ) alg = private_jwk . alg or alg if not alg : raise ValueError ( \"Asymmetric signing requires an alg, either as part of the private JWK, or passed as parameter\" ) kid = private_jwk . get ( \"kid\" ) if not kid : raise ValueError ( \"Asymmetric signing requires a kid, either as part of the private JWK, or passed as parameter\" ) super () . __init__ ( client_id , alg , lifetime , jti_gen ) self . private_jwk = private_jwk","title":"__init__()"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt.client_assertion","text":"Generate a Client Assertion, asumetrically signed with private_jwk as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion. Source code in requests_oauth2client/client_authentication.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def client_assertion ( self , audience : str ) -> str : \"\"\" Generate a Client Assertion, asumetrically signed with `private_jwk` as key. :param audience: the audience to use for the generated Client Assertion. :return: a Client Assertion. \"\"\" iat = int ( datetime . now () . timestamp ()) exp = iat + self . lifetime jti = str ( self . jti_gen ()) jwt = Jwt . sign ( claims = { \"iss\" : self . client_id , \"sub\" : self . client_id , \"aud\" : audience , \"iat\" : iat , \"exp\" : exp , \"jti\" : jti , }, jwk = self . private_jwk , alg = self . alg , ) return str ( jwt )","title":"client_assertion()"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp","text":"Bases: BaseClientAuthenticationMethod Implement the none authentication method for public apps (where the client only sends its client_id). Source code in requests_oauth2client/client_authentication.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 class PublicApp ( BaseClientAuthenticationMethod ): \"\"\"Implement the `none` authentication method for public apps (where the client only sends its client_id).\"\"\" def __init__ ( self , client_id : str ) -> None : \"\"\" Initialize a `PublicApp` Auth Handler. :param client_id: the client_id to use. \"\"\" self . client_id = client_id def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_id` field. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id )]) request . prepare_body ( data . params , files = None ) return request","title":"PublicApp"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp.__call__","text":"Add the client_id field in the request body. :param request: a requests.PreparedRequest . :return: a requests.PreparedRequest with the added client_id field. Source code in requests_oauth2client/client_authentication.py 275 276 277 278 279 280 281 282 283 284 285 286 def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Add the `client_id` field in the request body. :param request: a [requests.PreparedRequest][]. :return: a [requests.PreparedRequest][] with the added `client_id` field. \"\"\" request = super () . __call__ ( request ) data = furl . Query ( request . body ) data . set ([( \"client_id\" , self . client_id )]) request . prepare_body ( data . params , files = None ) return request","title":"__call__()"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp.__init__","text":"Initialize a PublicApp Auth Handler. :param client_id: the client_id to use. Source code in requests_oauth2client/client_authentication.py 267 268 269 270 271 272 273 def __init__ ( self , client_id : str ) -> None : \"\"\" Initialize a `PublicApp` Auth Handler. :param client_id: the client_id to use. \"\"\" self . client_id = client_id","title":"__init__()"},{"location":"api/#requests_oauth2client.client_authentication.client_auth_factory","text":"Initialize the appropriate Auth Handler based on the provided parameters. This initializes a ClientAuthenticationMethod subclass based on the provided parameters. :param auth: Can be a :class: requests.auth.AuthBase instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize, by default, an instance of default_auth_handler , a (client_id, jwk) to initialize a :class: PrivateKeyJWK , or a client_id which will use :class: PublicApp authentication. :param default_auth_handler: if auth is a tuple of two string, consider that they are a client_id and client_secret, and initialize an instance of this class with those 2 parameters. :return: an Auth Handler that will manage client authentication to the AS Token Endpoint or other backend endpoints. Source code in requests_oauth2client/client_authentication.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def client_auth_factory ( auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], Tuple [ str , Jwk ], str ], default_auth_handler : Union [ Type [ ClientSecretPost ], Type [ ClientSecretBasic ], Type [ ClientSecretJwt ] ] = ClientSecretPost , ) -> requests . auth . AuthBase : \"\"\" Initialize the appropriate Auth Handler based on the provided parameters. This initializes a `ClientAuthenticationMethod` subclass based on the provided parameters. :param auth: Can be a :class:`requests.auth.AuthBase` instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize, by default, an instance of `default_auth_handler`, a (client_id, jwk) to initialize a :class:`PrivateKeyJWK`, or a `client_id` which will use :class:`PublicApp` authentication. :param default_auth_handler: if auth is a tuple of two string, consider that they are a client_id and client_secret, and initialize an instance of this class with those 2 parameters. :return: an Auth Handler that will manage client authentication to the AS Token Endpoint or other backend endpoints. \"\"\" if isinstance ( auth , requests . auth . AuthBase ): return auth elif isinstance ( auth , tuple ) and len ( auth ) == 2 : client_id , credential = auth if isinstance ( credential , Jwk ): private_jwk = credential return PrivateKeyJwt ( str ( client_id ), private_jwk ) else : return default_auth_handler ( str ( client_id ), credential ) elif isinstance ( auth , str ): client_id = auth return PublicApp ( client_id ) else : raise ValueError ( \"\"\"Parameter 'auth' is required to define the Authentication Method that this Client will use when sending requests to the Token Endpoint. 'auth' can be: - an instance of a requests.auth.AuthBase subclass, including ClientSecretPost, ClientSecretBasic, ClientSecretJwt, PrivateKeyJwt, PublicApp, - a (client_id, client_secret) tuple, both as str, for ClientSecretPost, - a (client_id, private_key) tuple, with client_id as str and private_key as a dict in JWK format, for PrivateKeyJwt, - a client_id, as str, for PublicApp. \"\"\" )","title":"client_auth_factory()"},{"location":"api/#requests_oauth2client.device_authorization","text":"Implements the Device Authorization Flow as defined in RFC8628 .","title":"device_authorization"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob","text":"Bases: TokenEndpointPoolingJob A pooling job for checking if the user has finished with his authorization in a Device Authorization flow. Usage: 1 2 3 4 5 6 7 8 client = OAuth2Client ( token_endpoint = \"https://my.as.local/token\" , auth = ( \"client_id\" , \"client_secret\" ) ) pool_job = DeviceAuthorizationPoolingJob ( client = client , device_code = \"my_device_code\" ) token = None while token is None : token = pool_job () Source code in requests_oauth2client/device_authorization.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class DeviceAuthorizationPoolingJob ( TokenEndpointPoolingJob ): \"\"\" A pooling job for checking if the user has finished with his authorization in a Device Authorization flow. Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\") ) pool_job = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\") token = None while token is None: token = pool_job() ``` \"\"\" def __init__ ( self , client : \"OAuth2Client\" , device_code : Union [ str , DeviceAuthorizationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `DeviceAuthorizationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . device_code = device_code def token_request ( self ) -> BearerToken : \"\"\" Implement the Device Code token request. This actually calls [OAuth2Client.device_code(device_code)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . device_code ( self . device_code , requests_kwargs = self . requests_kwargs , ** self . token_kwargs )","title":"DeviceAuthorizationPoolingJob"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob.__init__","text":"Initialize a DeviceAuthorizationPoolingJob . :param client: an OAuth2Client that will be used to pool the token endpoint. :param device_code: a device_code as str or a DeviceAuthorizationResponse . :param interval: The pooling interval to use. This overrides the one in auth_req_id if it is a BackChannelAuthenticationResponse . :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to requests.request . :param token_kwargs: Additional parameters for the token request. Source code in requests_oauth2client/device_authorization.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , client : \"OAuth2Client\" , device_code : Union [ str , DeviceAuthorizationResponse ], interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `DeviceAuthorizationPoolingJob`. :param client: an OAuth2Client that will be used to pool the token endpoint. :param device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`. :param interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`. :param slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request. :param requests_kwargs: Additional parameters for the underlying calls to [requests.request][]. :param token_kwargs: Additional parameters for the token request. \"\"\" super () . __init__ ( client = client , interval = interval , slow_down_interval = slow_down_interval , requests_kwargs = requests_kwargs , ** token_kwargs , ) self . device_code = device_code","title":"__init__()"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob.token_request","text":"Implement the Device Code token request. This actually calls [OAuth2Client.device_code(device_code)] on client . :return: a BearerToken Source code in requests_oauth2client/device_authorization.py 105 106 107 108 109 110 111 112 113 114 def token_request ( self ) -> BearerToken : \"\"\" Implement the Device Code token request. This actually calls [OAuth2Client.device_code(device_code)] on `client`. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" return self . client . device_code ( self . device_code , requests_kwargs = self . requests_kwargs , ** self . token_kwargs )","title":"token_request()"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse","text":"Represent a response returned by the device Authorization Endpoint. Source code in requests_oauth2client/device_authorization.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class DeviceAuthorizationResponse : \"\"\"Represent a response returned by the device Authorization Endpoint.\"\"\" @accepts_expires_in def __init__ ( self , device_code : str , user_code : str , verification_uri : str , verification_uri_complete : Optional [ str ] = None , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = None , ** kwargs : Any , ): \"\"\" Initialize a DeviceAuthorizationResponse. All parameters are those returned by the AS as response to a Device Authorization Request. :param device_code: the `device_code` as returned by the AS. :param user_code: the `device_code` as returned by the AS. :param verification_uri: the `device_code` as returned by the AS. :param verification_uri_complete: the `device_code` as returned by the AS. :param expires_at: the expiration date for the device_code. This method also accepts an `expires_in` parameter, as a number of seconds in the future. :param interval: the pooling `interval` as returned by the AS. :param kwargs: additional parameters as returned by the AS. \"\"\" self . device_code = device_code self . user_code = user_code self . verification_uri = verification_uri self . verification_uri_complete = verification_uri_complete self . expires_at = expires_at self . interval = interval self . other = kwargs def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the `device_code` within this response is expired at the time of the call. :return: `True` if the device_code is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None","title":"DeviceAuthorizationResponse"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.__init__","text":"Initialize a DeviceAuthorizationResponse. All parameters are those returned by the AS as response to a Device Authorization Request. :param device_code: the device_code as returned by the AS. :param user_code: the device_code as returned by the AS. :param verification_uri: the device_code as returned by the AS. :param verification_uri_complete: the device_code as returned by the AS. :param expires_at: the expiration date for the device_code. This method also accepts an expires_in parameter, as a number of seconds in the future. :param interval: the pooling interval as returned by the AS. :param kwargs: additional parameters as returned by the AS. Source code in requests_oauth2client/device_authorization.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @accepts_expires_in def __init__ ( self , device_code : str , user_code : str , verification_uri : str , verification_uri_complete : Optional [ str ] = None , expires_at : Optional [ datetime ] = None , interval : Optional [ int ] = None , ** kwargs : Any , ): \"\"\" Initialize a DeviceAuthorizationResponse. All parameters are those returned by the AS as response to a Device Authorization Request. :param device_code: the `device_code` as returned by the AS. :param user_code: the `device_code` as returned by the AS. :param verification_uri: the `device_code` as returned by the AS. :param verification_uri_complete: the `device_code` as returned by the AS. :param expires_at: the expiration date for the device_code. This method also accepts an `expires_in` parameter, as a number of seconds in the future. :param interval: the pooling `interval` as returned by the AS. :param kwargs: additional parameters as returned by the AS. \"\"\" self . device_code = device_code self . user_code = user_code self . verification_uri = verification_uri self . verification_uri_complete = verification_uri_complete self . expires_at = expires_at self . interval = interval self . other = kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.is_expired","text":"Check if the device_code within this response is expired at the time of the call. :return: True if the device_code is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client/device_authorization.py 49 50 51 52 53 54 55 56 57 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the `device_code` within this response is expired at the time of the call. :return: `True` if the device_code is expired, `False` if it is still valid, `None` if there is no `expires_in` hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None","title":"is_expired()"},{"location":"api/#requests_oauth2client.discovery","text":"Implements Metadata discovery documents, as specified in RFC8615 and OpenID Connect Discovery 1.0 .","title":"discovery"},{"location":"api/#requests_oauth2client.discovery.oauth2_discovery_document_url","text":"Given an issuer identifier, return the standardised URL where the OAuth20 server metadata can be retrieved. The returned URL is built as specified in RFC8414 . :param issuer: an OAuth20 Authentication Server issuer :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client/discovery.py 35 36 37 38 39 40 41 42 43 def oauth2_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OAuth20 server metadata can be retrieved. The returned URL is built as specified in [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). :param issuer: an OAuth20 Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"oauth-authorization-server\" , at_root = True )","title":"oauth2_discovery_document_url()"},{"location":"api/#requests_oauth2client.discovery.oidc_discovery_document_url","text":"Given an issuer identifier, return the standardised URL where the OIDC discovery document can be retrieved. The returned URL is biuilt as specified in OpenID Connect Discovery 1.0 . :param issuer: an OIDC Authentication Server issuer :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client/discovery.py 24 25 26 27 28 29 30 31 32 def oidc_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can be retrieved. The returned URL is biuilt as specified in [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). :param issuer: an OIDC Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"openid-configuration\" , at_root = False )","title":"oidc_discovery_document_url()"},{"location":"api/#requests_oauth2client.discovery.well_known_uri","text":"Return the location of a well-known document on an origin, according to RFC8615 . :param origin: origin to use to build the well-known uri. :param name: document name to use to build the well-known uri. :param at_root: if True , assume the well-known document is at root level (as defined in RFC8615 ). If False , assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0 . :return: the well-know uri, relative to origin, where the well-known document named name should be found. Source code in requests_oauth2client/discovery.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def well_known_uri ( origin : str , name : str , at_root : bool = True ) -> str : \"\"\" Return the location of a well-known document on an origin, according to [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615). :param origin: origin to use to build the well-known uri. :param name: document name to use to build the well-known uri. :param at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)). If `False`, assume the well-known location is per-directory, as defined in [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). :return: the well-know uri, relative to origin, where the well-known document named `name` should be found. \"\"\" url = furl ( origin ) if at_root : url . path = Path ( \".well-known\" ) / url . path / name else : url . path . add ( Path ( \".well-known\" ) / name ) return str ( url )","title":"well_known_uri()"},{"location":"api/#requests_oauth2client.exceptions","text":"This module contains all exceptions that can be raised by methods from requests_oauth2client .","title":"exceptions"},{"location":"api/#requests_oauth2client.exceptions.AccessDenied","text":"Bases: EndpointError Raised when the Authorization Server returns error = access_denied . Source code in requests_oauth2client/exceptions.py 64 65 class AccessDenied ( EndpointError ): \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"","title":"AccessDenied"},{"location":"api/#requests_oauth2client.exceptions.AccountSelectionRequired","text":"Bases: InteractionRequired Raised when the Authorization Endpoint returns error = account_selection_required . Source code in requests_oauth2client/exceptions.py 140 141 class AccountSelectionRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"","title":"AccountSelectionRequired"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationPending","text":"Bases: TokenEndpointError Raised when the Token Endpoint returns error = authorization_pending . Source code in requests_oauth2client/exceptions.py 92 93 class AuthorizationPending ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"","title":"AuthorizationPending"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError","text":"Bases: Exception Base class for error responses returned by the Authorization endpoint. Source code in requests_oauth2client/exceptions.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class AuthorizationResponseError ( Exception ): \"\"\"Base class for error responses returned by the Authorization endpoint.\"\"\" def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `AuthorizationResponseError`. An `AuthorizationResponseError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri","title":"AuthorizationResponseError"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError.__init__","text":"Initialize an AuthorizationResponseError . An AuthorizationResponseError contains the error message, description and uri that are returned by the AS. :param error: the error identifier as returned by the AS :param description: the error_description as returned by the AS :param uri: the error_uri as returned by the AS Source code in requests_oauth2client/exceptions.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `AuthorizationResponseError`. An `AuthorizationResponseError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri","title":"__init__()"},{"location":"api/#requests_oauth2client.exceptions.BackChannelAuthenticationError","text":"Bases: EndpointError Base class for errors returned by the BackChannel Authentication endpoint. Source code in requests_oauth2client/exceptions.py 168 169 class BackChannelAuthenticationError ( EndpointError ): \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"","title":"BackChannelAuthenticationError"},{"location":"api/#requests_oauth2client.exceptions.ConsentRequired","text":"Bases: InteractionRequired Raised when the Authorization Endpoint returns error = consent_required . Source code in requests_oauth2client/exceptions.py 148 149 class ConsentRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"","title":"ConsentRequired"},{"location":"api/#requests_oauth2client.exceptions.DeviceAuthorizationError","text":"Bases: EndpointError Base class for Device Authorization Endpoint errors. Source code in requests_oauth2client/exceptions.py 88 89 class DeviceAuthorizationError ( EndpointError ): \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"","title":"DeviceAuthorizationError"},{"location":"api/#requests_oauth2client.exceptions.EndpointError","text":"Bases: OAuth2Error Base class for exceptions raised when a token endpoint returns a standardised error. Source code in requests_oauth2client/exceptions.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class EndpointError ( OAuth2Error ): \"\"\"Base class for exceptions raised when a token endpoint returns a standardised error.\"\"\" def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `EndpointError`. An `EndpointError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri","title":"EndpointError"},{"location":"api/#requests_oauth2client.exceptions.EndpointError.__init__","text":"Initialize an EndpointError . An EndpointError contains the error message, description and uri that are returned by the AS. :param error: the error identifier as returned by the AS :param description: the error_description as returned by the AS :param uri: the error_uri as returned by the AS Source code in requests_oauth2client/exceptions.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , error : str , description : Optional [ str ] = None , uri : Optional [ str ] = None ): \"\"\" Initialize an `EndpointError`. An `EndpointError` contains the error message, description and uri that are returned by the AS. :param error: the `error` identifier as returned by the AS :param description: the `error_description` as returned by the AS :param uri: the `error_uri` as returned by the AS \"\"\" self . error = error self . description = description self . uri = uri","title":"__init__()"},{"location":"api/#requests_oauth2client.exceptions.ExpiredAccessToken","text":"Bases: OAuth2Error Raised when an expired access token is used. Source code in requests_oauth2client/exceptions.py 36 37 class ExpiredAccessToken ( OAuth2Error ): \"\"\"Raised when an expired access token is used.\"\"\"","title":"ExpiredAccessToken"},{"location":"api/#requests_oauth2client.exceptions.ExpiredToken","text":"Bases: TokenEndpointError Raised when the Token Endpoint returns error = expired_token . Source code in requests_oauth2client/exceptions.py 100 101 class ExpiredToken ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"","title":"ExpiredToken"},{"location":"api/#requests_oauth2client.exceptions.InteractionRequired","text":"Bases: AuthorizationResponseError Raised when the Authorization Endpoint returns error = interaction_required . Source code in requests_oauth2client/exceptions.py 132 133 class InteractionRequired ( AuthorizationResponseError ): \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"","title":"InteractionRequired"},{"location":"api/#requests_oauth2client.exceptions.IntrospectionError","text":"Bases: EndpointError Base class for Introspection Endpoint errors. Source code in requests_oauth2client/exceptions.py 80 81 class IntrospectionError ( EndpointError ): \"\"\"Base class for Introspection Endpoint errors.\"\"\"","title":"IntrospectionError"},{"location":"api/#requests_oauth2client.exceptions.InvalidAuthResponse","text":"Bases: OAuth2Error Base class for errors due to Auth Responses that don't obey the standard (e.g. missing mandatory params). Source code in requests_oauth2client/exceptions.py 152 153 class InvalidAuthResponse ( OAuth2Error ): \"\"\"Base class for errors due to Auth Responses that don't obey the standard (e.g. missing mandatory params).\"\"\"","title":"InvalidAuthResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidBackChannelAuthenticationResponse","text":"Bases: OAuth2Error Raised when the BackChannel Authentication endpoint returns non-standardised errors. Source code in requests_oauth2client/exceptions.py 172 173 class InvalidBackChannelAuthenticationResponse ( OAuth2Error ): \"\"\"Raised when the BackChannel Authentication endpoint returns non-standardised errors.\"\"\"","title":"InvalidBackChannelAuthenticationResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidDeviceAuthorizationResponse","text":"Bases: OAuth2Error Raised when the Device Authorization Endpoint returns a non-standard error response. Source code in requests_oauth2client/exceptions.py 104 105 class InvalidDeviceAuthorizationResponse ( OAuth2Error ): \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"","title":"InvalidDeviceAuthorizationResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidGrant","text":"Bases: TokenEndpointError Raised when the Token Endpoint returns error = invalid_grant . Source code in requests_oauth2client/exceptions.py 60 61 class InvalidGrant ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"","title":"InvalidGrant"},{"location":"api/#requests_oauth2client.exceptions.InvalidIdToken","text":"Bases: InvalidJwt Raised when trying to validate an invalid Id Token value. Source code in requests_oauth2client/exceptions.py 108 109 class InvalidIdToken ( InvalidJwt ): \"\"\"Raised when trying to validate an invalid Id Token value.\"\"\"","title":"InvalidIdToken"},{"location":"api/#requests_oauth2client.exceptions.InvalidPushedAuthorizationResponse","text":"Bases: OAuth2Error Raised when the Pushed Authorization Endpoint returns an error. Source code in requests_oauth2client/exceptions.py 176 177 class InvalidPushedAuthorizationResponse ( OAuth2Error ): \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"","title":"InvalidPushedAuthorizationResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidScope","text":"Bases: TokenEndpointError Raised when the Token Endpoint returns error = invalid_scope . Source code in requests_oauth2client/exceptions.py 52 53 class InvalidScope ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"","title":"InvalidScope"},{"location":"api/#requests_oauth2client.exceptions.InvalidTarget","text":"Bases: TokenEndpointError Raised when the Token Endpoint returns error = invalid_target . Source code in requests_oauth2client/exceptions.py 56 57 class InvalidTarget ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"","title":"InvalidTarget"},{"location":"api/#requests_oauth2client.exceptions.InvalidTokenResponse","text":"Bases: OAuth2Error Base class for exceptions raised when a token endpoint returns a non-standardised response. Source code in requests_oauth2client/exceptions.py 32 33 class InvalidTokenResponse ( OAuth2Error ): \"\"\"Base class for exceptions raised when a token endpoint returns a non-standardised response.\"\"\"","title":"InvalidTokenResponse"},{"location":"api/#requests_oauth2client.exceptions.LoginRequired","text":"Bases: InteractionRequired Raised when the Authorization Endpoint returns error = login_required . Source code in requests_oauth2client/exceptions.py 136 137 class LoginRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"","title":"LoginRequired"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIssuer","text":"Bases: InvalidAuthResponse Raised when an auth response contains an 'iss' parameter that doesn't match the expected value. Source code in requests_oauth2client/exceptions.py 164 165 class MismatchingIssuer ( InvalidAuthResponse ): \"\"\"Raised when an auth response contains an 'iss' parameter that doesn't match the expected value.\"\"\"","title":"MismatchingIssuer"},{"location":"api/#requests_oauth2client.exceptions.MismatchingState","text":"Bases: InvalidAuthResponse Raised when an auth response contains a 'state' parameter that doesn't match the expected value. Source code in requests_oauth2client/exceptions.py 160 161 class MismatchingState ( InvalidAuthResponse ): \"\"\"Raised when an auth response contains a 'state' parameter that doesn't match the expected value.\"\"\"","title":"MismatchingState"},{"location":"api/#requests_oauth2client.exceptions.MissingAuthCode","text":"Bases: InvalidAuthResponse Raised when the authorization code is missing from the auth response and no error is returned. Source code in requests_oauth2client/exceptions.py 156 157 class MissingAuthCode ( InvalidAuthResponse ): \"\"\"Raised when the authorization code is missing from the auth response and no error is returned.\"\"\"","title":"MissingAuthCode"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error","text":"Bases: Exception Base class for Exceptions raised by requests_oauth2client. Source code in requests_oauth2client/exceptions.py 8 9 class OAuth2Error ( Exception ): \"\"\"Base class for Exceptions raised by requests_oauth2client.\"\"\"","title":"OAuth2Error"},{"location":"api/#requests_oauth2client.exceptions.RevocationError","text":"Bases: EndpointError Base class for Revocation Endpoint errors. Source code in requests_oauth2client/exceptions.py 72 73 class RevocationError ( EndpointError ): \"\"\"Base class for Revocation Endpoint errors.\"\"\"","title":"RevocationError"},{"location":"api/#requests_oauth2client.exceptions.ServerError","text":"Bases: EndpointError Raised when the token endpoint returns error = server_error . Source code in requests_oauth2client/exceptions.py 44 45 class ServerError ( EndpointError ): \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"","title":"ServerError"},{"location":"api/#requests_oauth2client.exceptions.SessionSelectionRequired","text":"Bases: InteractionRequired Raised when the Authorization Endpoint returns error = session_selection_required . Source code in requests_oauth2client/exceptions.py 144 145 class SessionSelectionRequired ( InteractionRequired ): \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"","title":"SessionSelectionRequired"},{"location":"api/#requests_oauth2client.exceptions.SlowDown","text":"Bases: TokenEndpointError Raised when the Token Endpoint returns error = slow_down . Source code in requests_oauth2client/exceptions.py 96 97 class SlowDown ( TokenEndpointError ): \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"","title":"SlowDown"},{"location":"api/#requests_oauth2client.exceptions.TokenEndpointError","text":"Bases: EndpointError Base class for errors that are specific to the token endpoint. Source code in requests_oauth2client/exceptions.py 48 49 class TokenEndpointError ( EndpointError ): \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"","title":"TokenEndpointError"},{"location":"api/#requests_oauth2client.exceptions.UnauthorizedClient","text":"Bases: EndpointError Raised when the Authorization Server returns error = unauthorized_client . Source code in requests_oauth2client/exceptions.py 68 69 class UnauthorizedClient ( EndpointError ): \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"","title":"UnauthorizedClient"},{"location":"api/#requests_oauth2client.exceptions.UnknownIntrospectionError","text":"Bases: OAuth2Error Raised when the Introspection Endpoint retuns a non-standard error. Source code in requests_oauth2client/exceptions.py 84 85 class UnknownIntrospectionError ( OAuth2Error ): \"\"\"Raised when the Introspection Endpoint retuns a non-standard error.\"\"\"","title":"UnknownIntrospectionError"},{"location":"api/#requests_oauth2client.exceptions.UnknownTokenEndpointError","text":"Bases: EndpointError Raised when an otherwise unknown error is returned by the token endpoint. Source code in requests_oauth2client/exceptions.py 40 41 class UnknownTokenEndpointError ( EndpointError ): \"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\"","title":"UnknownTokenEndpointError"},{"location":"api/#requests_oauth2client.exceptions.UnsupportedTokenType","text":"Bases: RevocationError Raised when the Revocation endpoint returns error = unsupported_token_type . Source code in requests_oauth2client/exceptions.py 76 77 class UnsupportedTokenType ( RevocationError ): \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"","title":"UnsupportedTokenType"},{"location":"api/#requests_oauth2client.flask","text":"This modules contains helper classes for the Flask framework.","title":"flask"},{"location":"api/#requests_oauth2client.flask.auth","text":"Helper classes for the Flask framework.","title":"auth"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth","text":"Bases: FlaskSessionAuthMixin , OAuth2ClientCredentialsAuth A Flask-specific requests Authentication handler that fetches Access Tokens using the Client Credentials Grant. It will automatically gets access tokens from an OAuth 2.x Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask session , so that each user has a different access token. Source code in requests_oauth2client/flask/auth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class FlaskOAuth2ClientCredentialsAuth ( FlaskSessionAuthMixin , OAuth2ClientCredentialsAuth ): \"\"\" A Flask-specific `requests` Authentication handler that fetches Access Tokens using the Client Credentials Grant. It will automatically gets access tokens from an OAuth 2.x Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask `session`, so that each user has a different access token. \"\"\" def __init__ ( self , client : OAuth2Client , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize a `FlaskOAuth2ClientCredentialsAuth`. :param client: an OAuth2Client that will be used to retrieve tokens. :param session_key: the key that will be used to store the access token in Flask session :param serializer: a serializer that will be used to serialize the access token in Flask session :param token_kwargs: additional kwargs for the Token Request \"\"\" super () . __init__ ( session_key , serializer ) self . client = client self . token_kwargs = token_kwargs","title":"FlaskOAuth2ClientCredentialsAuth"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth.__init__","text":"Initialize a FlaskOAuth2ClientCredentialsAuth . :param client: an OAuth2Client that will be used to retrieve tokens. :param session_key: the key that will be used to store the access token in Flask session :param serializer: a serializer that will be used to serialize the access token in Flask session :param token_kwargs: additional kwargs for the Token Request Source code in requests_oauth2client/flask/auth.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , client : OAuth2Client , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initialize a `FlaskOAuth2ClientCredentialsAuth`. :param client: an OAuth2Client that will be used to retrieve tokens. :param session_key: the key that will be used to store the access token in Flask session :param serializer: a serializer that will be used to serialize the access token in Flask session :param token_kwargs: additional kwargs for the Token Request \"\"\" super () . __init__ ( session_key , serializer ) self . client = client self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin","text":"A Mixin for auth handlers to store their tokens in Flask session. Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens will be persisted between multiple requests to the front-end Flask app. Source code in requests_oauth2client/flask/auth.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class FlaskSessionAuthMixin : \"\"\" A Mixin for auth handlers to store their tokens in Flask session. Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens will be persisted between multiple requests to the front-end Flask app. \"\"\" def __init__ ( self , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None ): \"\"\" Initialize a FlaskSessionAuthMixin. :param session_key: the key that will be used to store the access token in session. :param serializer: the serializer that will be used to store the access token in session. \"\"\" self . serializer = serializer or BearerTokenSerializer () self . session_key = session_key @property def token ( self ) -> Optional [ BearerToken ]: \"\"\"Return the Access Token stored in session.\"\"\" serialized_token = session . get ( self . session_key ) if serialized_token is None : return None return self . serializer . loads ( serialized_token ) @token . setter def token ( self , token : Optional [ BearerToken ]) -> None : \"\"\" Store an Access Token in session. :param token: the token to store \"\"\" if token : serialized_token = self . serializer . dumps ( token ) session [ self . session_key ] = serialized_token else : session . pop ( self . session_key , None )","title":"FlaskSessionAuthMixin"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin.__init__","text":"Initialize a FlaskSessionAuthMixin. :param session_key: the key that will be used to store the access token in session. :param serializer: the serializer that will be used to store the access token in session. Source code in requests_oauth2client/flask/auth.py 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , session_key : str , serializer : Optional [ BearerTokenSerializer ] = None ): \"\"\" Initialize a FlaskSessionAuthMixin. :param session_key: the key that will be used to store the access token in session. :param serializer: the serializer that will be used to store the access token in session. \"\"\" self . serializer = serializer or BearerTokenSerializer () self . session_key = session_key","title":"__init__()"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin.token","text":"Return the Access Token stored in session. Source code in requests_oauth2client/flask/auth.py 31 32 33 34 35 36 37 @property def token ( self ) -> Optional [ BearerToken ]: \"\"\"Return the Access Token stored in session.\"\"\" serialized_token = session . get ( self . session_key ) if serialized_token is None : return None return self . serializer . loads ( serialized_token )","title":"token()"},{"location":"api/#requests_oauth2client.pooling","text":"Base classes for pooling jobs, that call an endpoint at regular interval to obtain some response.","title":"pooling"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob","text":"Bases: ABC Base class for Token Endpoint pooling jobs on decoupled flows like CIBA or Device Authorization. This class must be subclassed to implement actual BackChannel flows. Source code in requests_oauth2client/pooling.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class TokenEndpointPoolingJob ( ABC ): \"\"\" Base class for Token Endpoint pooling jobs on decoupled flows like CIBA or Device Authorization. This class must be subclassed to implement actual BackChannel flows. \"\"\" def __init__ ( self , client : \"OAuth2Client\" , interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `TokenEndpointPoolingJob`. This needs an [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. The initial pooling `interval` is configurable. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. :param interval: initial pooling interval, in seconds. If `None`, default to `5`. :param slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is received, this number of seconds will be added to the pooling interval. :param requests_kwargs: additional parameters for the underlying calls to [requests.request][] :param token_kwargs: additional parameters for the token request \"\"\" self . client = client self . interval = interval or 5 self . slow_down_interval = slow_down_interval self . requests_kwargs = requests_kwargs self . token_kwargs = token_kwargs def __call__ ( self ) -> Optional [ BearerToken ]: \"\"\" Wrap the actual Token Endpoint call with a pooling interval. Everytime this method is called, it will wait for the entire duration of the pooling interval before calling [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So you can call it immediately after initiating the BackChannel flow, and it will wait before initiating the first call. This implements the logic to handle [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or `None` if the Authorization is still pending. \"\"\" time . sleep ( self . interval ) try : return self . token_request () except SlowDown : self . interval += self . slow_down_interval except AuthorizationPending : pass return None @abstractmethod def token_request ( self ) -> BearerToken : \"\"\" Abstract method for the token endpoint call. This must be implemented by subclasses. This method must Must raise [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase the pooling interval by `slow_down_interval` seconds. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" raise NotImplementedError # pragma: no cover","title":"TokenEndpointPoolingJob"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob.__call__","text":"Wrap the actual Token Endpoint call with a pooling interval. Everytime this method is called, it will wait for the entire duration of the pooling interval before calling token_request() . So you can call it immediately after initiating the BackChannel flow, and it will wait before initiating the first call. This implements the logic to handle AuthorizationPending or SlowDown requests by the AS. :return: a BearerToken if the AS returns one, or None if the Authorization is still pending. Source code in requests_oauth2client/pooling.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __call__ ( self ) -> Optional [ BearerToken ]: \"\"\" Wrap the actual Token Endpoint call with a pooling interval. Everytime this method is called, it will wait for the entire duration of the pooling interval before calling [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So you can call it immediately after initiating the BackChannel flow, and it will wait before initiating the first call. This implements the logic to handle [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or `None` if the Authorization is still pending. \"\"\" time . sleep ( self . interval ) try : return self . token_request () except SlowDown : self . interval += self . slow_down_interval except AuthorizationPending : pass return None","title":"__call__()"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob.__init__","text":"Initialize a TokenEndpointPoolingJob . This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling interval is configurable. :param client: the OAuth2Client that will be used to pool the token endpoint. :param interval: initial pooling interval, in seconds. If None , default to 5 . :param slow_down_interval: when a SlowDown is received, this number of seconds will be added to the pooling interval. :param requests_kwargs: additional parameters for the underlying calls to requests.request :param token_kwargs: additional parameters for the token request Source code in requests_oauth2client/pooling.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , client : \"OAuth2Client\" , interval : Optional [ int ] = None , slow_down_interval : int = 5 , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ): \"\"\" Initialize a `TokenEndpointPoolingJob`. This needs an [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. The initial pooling `interval` is configurable. :param client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint. :param interval: initial pooling interval, in seconds. If `None`, default to `5`. :param slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is received, this number of seconds will be added to the pooling interval. :param requests_kwargs: additional parameters for the underlying calls to [requests.request][] :param token_kwargs: additional parameters for the token request \"\"\" self . client = client self . interval = interval or 5 self . slow_down_interval = slow_down_interval self . requests_kwargs = requests_kwargs self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request","text":"Abstract method for the token endpoint call. This must be implemented by subclasses. This method must Must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by slow_down_interval seconds. :return: a BearerToken Source code in requests_oauth2client/pooling.py 68 69 70 71 72 73 74 75 76 77 78 79 @abstractmethod def token_request ( self ) -> BearerToken : \"\"\" Abstract method for the token endpoint call. This must be implemented by subclasses. This method must Must raise [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase the pooling interval by `slow_down_interval` seconds. :return: a [BearerToken][requests_oauth2client.tokens.BearerToken] \"\"\" raise NotImplementedError # pragma: no cover","title":"token_request()"},{"location":"api/#requests_oauth2client.tokens","text":"This modules contain classes that represent Tokens used in OAuth2.0 / OIDC.","title":"tokens"},{"location":"api/#requests_oauth2client.tokens.BearerToken","text":"Represents a Bearer Token and its associated parameters as returned by a Token Endpoint. This is a wrapper around a Bearer Token and associated expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint. Source code in requests_oauth2client/tokens.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class BearerToken : \"\"\" Represents a Bearer Token and its associated parameters as returned by a Token Endpoint. This is a wrapper around a Bearer Token and associated expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint. \"\"\" @accepts_expires_in def __init__ ( self , access_token : str , * , expires_at : Optional [ datetime ] = None , scope : Optional [ str ] = None , refresh_token : Optional [ str ] = None , token_type : str = \"Bearer\" , id_token : Optional [ str ] = None , ** kwargs : Any , ): \"\"\" Initialize a BearerToken. All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in the future, can be passed instead. :param access_token: an `access_token`, as returned by the AS. :param expires_at: an expiration date. This method also accepts an `expires_in` hint as returned by the AS, if any. :param scope: a `scope`, as returned by the AS, if any. :param refresh_token: a `refresh_token`, as returned by the AS, if any. :param token_type: a `token_type`, as returned by the AS. :param id_token: an `id_token`, as returned by the AS, if any. :param kwargs: additional parameters as returned by the AS, if any. \"\"\" if token_type . title () != \"Bearer\" : raise ValueError ( \"This is not a Bearer Token!\" , token_type ) self . access_token = access_token self . expires_at = expires_at self . scope = scope self . refresh_token = refresh_token self . id_token = IdToken ( id_token ) if id_token else None self . other = kwargs def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the access token is expired. Returns `True` if the access token is expired at the time of the call. :param leeway: If the token expires in the next given number of seconds, then consider it expired already. :return: `True` if the access token is expired, `False` if it is still valid, `None` if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None def authorization_header ( self ) -> str : \"\"\" Return the Authorization Header value containing this access token, correctly formatted according to RFC6750. :return: the value to use in a HTTP Authorization Header \"\"\" return f \"Bearer { self . access_token } \" def __str__ ( self ) -> str : \"\"\" Return the access token value, as a string. :return: the access token string \"\"\" return self . access_token def __contains__ ( self , key : str ) -> bool : \"\"\" Check existence of a key in the token response. Allows testing like `assert \"refresh_token\" in token_response`. :param key: a key :return: True if the key exists in the token response, False otherwise \"\"\" if key == \"access_token\" : return True elif key == \"refresh_token\" : return self . refresh_token is not None elif key == \"scope\" : return self . scope is not None elif key == \"token_type\" : return True elif key == \"expires_in\" : return self . expires_at is not None else : return key in self . other def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this BearerToken. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not found in this response. \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) elif key == \"token_type\" : return \"Bearer\" return self . other . get ( key ) or super () . __getattribute__ ( key ) def as_dict ( self , expires_at : bool = False ) -> Dict [ str , Any ]: \"\"\" Return all the attributes from this BearerToken as a `dict`. :param expires_at: if `True`, the dict will contain an extra `expires_at` field with the token expiration date. :return: a `dict` containing this BearerToken attributes. \"\"\" r : Dict [ str , Any ] = { \"access_token\" : self . access_token , \"token_type\" : \"Bearer\" , } if self . expires_at : r [ \"expires_in\" ] = self . expires_in if expires_at : r [ \"expires_at\" ] = self . expires_at if self . scope : r [ \"scope\" ] = self . scope if self . refresh_token : r [ \"refresh_token\" ] = self . refresh_token if self . other : r . update ( self . other ) return r def __repr__ ( self ) -> str : \"\"\" Return a representation of this BearerToken. This representation is a pretty formatted `dict` that looks like a Token Endpoint response. :return: a `str` representation of this BearerToken. \"\"\" return pprint . pformat ( self . as_dict ()) def __eq__ ( self , other : object ) -> bool : \"\"\" Check if this BearerToken is equal to another. It supports comparison with another BearerToken, or with an `access_token` as `str`. :param other: another token to compare to :return: `True` if equal, `False` otherwise \"\"\" if isinstance ( other , BearerToken ): return ( self . access_token == other . access_token and self . refresh_token == other . refresh_token and self . expires_at == other . expires_at and self . token_type == other . token_type ) elif isinstance ( other , str ): return self . access_token == other return super () . __eq__ ( other )","title":"BearerToken"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__contains__","text":"Check existence of a key in the token response. Allows testing like assert \"refresh_token\" in token_response . :param key: a key :return: True if the key exists in the token response, False otherwise Source code in requests_oauth2client/tokens.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def __contains__ ( self , key : str ) -> bool : \"\"\" Check existence of a key in the token response. Allows testing like `assert \"refresh_token\" in token_response`. :param key: a key :return: True if the key exists in the token response, False otherwise \"\"\" if key == \"access_token\" : return True elif key == \"refresh_token\" : return self . refresh_token is not None elif key == \"scope\" : return self . scope is not None elif key == \"token_type\" : return True elif key == \"expires_in\" : return self . expires_at is not None else : return key in self . other","title":"__contains__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__eq__","text":"Check if this BearerToken is equal to another. It supports comparison with another BearerToken, or with an access_token as str . :param other: another token to compare to :return: True if equal, False otherwise Source code in requests_oauth2client/tokens.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def __eq__ ( self , other : object ) -> bool : \"\"\" Check if this BearerToken is equal to another. It supports comparison with another BearerToken, or with an `access_token` as `str`. :param other: another token to compare to :return: `True` if equal, `False` otherwise \"\"\" if isinstance ( other , BearerToken ): return ( self . access_token == other . access_token and self . refresh_token == other . refresh_token and self . expires_at == other . expires_at and self . token_type == other . token_type ) elif isinstance ( other , str ): return self . access_token == other return super () . __eq__ ( other )","title":"__eq__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__getattr__","text":"Return attributes from this BearerToken. Allows token_response.expires_in or token_response.any_custom_attribute :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not found in this response. Source code in requests_oauth2client/tokens.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __getattr__ ( self , key : str ) -> Any : \"\"\" Return attributes from this BearerToken. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises AttributeError: if the attribute is not found in this response. \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) elif key == \"token_type\" : return \"Bearer\" return self . other . get ( key ) or super () . __getattribute__ ( key )","title":"__getattr__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__init__","text":"Initialize a BearerToken. All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the expires_at parameter, or an expires_in parameter, as number of seconds in the future, can be passed instead. :param access_token: an access_token , as returned by the AS. :param expires_at: an expiration date. This method also accepts an expires_in hint as returned by the AS, if any. :param scope: a scope , as returned by the AS, if any. :param refresh_token: a refresh_token , as returned by the AS, if any. :param token_type: a token_type , as returned by the AS. :param id_token: an id_token , as returned by the AS, if any. :param kwargs: additional parameters as returned by the AS, if any. Source code in requests_oauth2client/tokens.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @accepts_expires_in def __init__ ( self , access_token : str , * , expires_at : Optional [ datetime ] = None , scope : Optional [ str ] = None , refresh_token : Optional [ str ] = None , token_type : str = \"Bearer\" , id_token : Optional [ str ] = None , ** kwargs : Any , ): \"\"\" Initialize a BearerToken. All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in the future, can be passed instead. :param access_token: an `access_token`, as returned by the AS. :param expires_at: an expiration date. This method also accepts an `expires_in` hint as returned by the AS, if any. :param scope: a `scope`, as returned by the AS, if any. :param refresh_token: a `refresh_token`, as returned by the AS, if any. :param token_type: a `token_type`, as returned by the AS. :param id_token: an `id_token`, as returned by the AS, if any. :param kwargs: additional parameters as returned by the AS, if any. \"\"\" if token_type . title () != \"Bearer\" : raise ValueError ( \"This is not a Bearer Token!\" , token_type ) self . access_token = access_token self . expires_at = expires_at self . scope = scope self . refresh_token = refresh_token self . id_token = IdToken ( id_token ) if id_token else None self . other = kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__repr__","text":"Return a representation of this BearerToken. This representation is a pretty formatted dict that looks like a Token Endpoint response. :return: a str representation of this BearerToken. Source code in requests_oauth2client/tokens.py 146 147 148 149 150 151 152 153 154 def __repr__ ( self ) -> str : \"\"\" Return a representation of this BearerToken. This representation is a pretty formatted `dict` that looks like a Token Endpoint response. :return: a `str` representation of this BearerToken. \"\"\" return pprint . pformat ( self . as_dict ())","title":"__repr__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__str__","text":"Return the access token value, as a string. :return: the access token string Source code in requests_oauth2client/tokens.py 77 78 79 80 81 82 83 def __str__ ( self ) -> str : \"\"\" Return the access token value, as a string. :return: the access token string \"\"\" return self . access_token","title":"__str__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.as_dict","text":"Return all the attributes from this BearerToken as a dict . :param expires_at: if True , the dict will contain an extra expires_at field with the token expiration date. :return: a dict containing this BearerToken attributes. Source code in requests_oauth2client/tokens.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def as_dict ( self , expires_at : bool = False ) -> Dict [ str , Any ]: \"\"\" Return all the attributes from this BearerToken as a `dict`. :param expires_at: if `True`, the dict will contain an extra `expires_at` field with the token expiration date. :return: a `dict` containing this BearerToken attributes. \"\"\" r : Dict [ str , Any ] = { \"access_token\" : self . access_token , \"token_type\" : \"Bearer\" , } if self . expires_at : r [ \"expires_in\" ] = self . expires_in if expires_at : r [ \"expires_at\" ] = self . expires_at if self . scope : r [ \"scope\" ] = self . scope if self . refresh_token : r [ \"refresh_token\" ] = self . refresh_token if self . other : r . update ( self . other ) return r","title":"as_dict()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.authorization_header","text":"Return the Authorization Header value containing this access token, correctly formatted according to RFC6750. :return: the value to use in a HTTP Authorization Header Source code in requests_oauth2client/tokens.py 69 70 71 72 73 74 75 def authorization_header ( self ) -> str : \"\"\" Return the Authorization Header value containing this access token, correctly formatted according to RFC6750. :return: the value to use in a HTTP Authorization Header \"\"\" return f \"Bearer { self . access_token } \"","title":"authorization_header()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.is_expired","text":"Check if the access token is expired. Returns True if the access token is expired at the time of the call. :param leeway: If the token expires in the next given number of seconds, then consider it expired already. :return: True if the access token is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client/tokens.py 56 57 58 59 60 61 62 63 64 65 66 67 def is_expired ( self , leeway : int = 0 ) -> Optional [ bool ]: \"\"\" Check if the access token is expired. Returns `True` if the access token is expired at the time of the call. :param leeway: If the token expires in the next given number of seconds, then consider it expired already. :return: `True` if the access token is expired, `False` if it is still valid, `None` if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () - timedelta ( seconds = leeway ) > self . expires_at return None","title":"is_expired()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer","text":"An helper class to serialize Tokens. This may be used to store BearerTokens in session or cookies. Source code in requests_oauth2client/tokens.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 class BearerTokenSerializer : \"\"\"An helper class to serialize Tokens. This may be used to store BearerTokens in session or cookies.\"\"\" def __init__ ( self , dumper : Optional [ Callable [[ BearerToken ], str ]] = None , loader : Optional [ Callable [[ str ], BearerToken ]] = None , ): \"\"\" Initialize a `BearerTokenSerializer`. This needs a `dumper` and a `loader` functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided. :param dumper: a function to serialize a token into a `str`. :param loader: a function do deserialize a serialized token representation. \"\"\" self . dumper = dumper or self . default_dumper self . loader = loader or self . default_loader @staticmethod def default_dumper ( token : BearerToken ) -> str : \"\"\" Serialize a token as JSON, then gzip compress, then encodes as base64url. :param token: the :class:`BearerToken` to serialize :return: the serialized value \"\"\" return ( BinaPy . serialize_to ( \"json\" , token . as_dict ( True )) . to ( \"gzip\" ) . to ( \"b64u\" ) . ascii () ) def default_loader ( self , serialized : str , token_class : Type [ BearerToken ] = BearerToken ) -> BearerToken : \"\"\" Deserialize a BearerToken. Does the opposite operations than `default_dumper`. :param serialized: the serialized token :return: a BearerToken \"\"\" attrs = ( BinaPy ( serialized ) . decode_from ( \"b64u\" ) . decode_from ( \"gzip\" ) . parse_from ( \"json\" ) ) expires_at = attrs . get ( \"expires_at\" ) if expires_at : attrs [ \"expires_at\" ] = datetime . fromtimestamp ( expires_at ) return token_class ( ** attrs ) def dumps ( self , token : BearerToken ) -> str : \"\"\" Serialize and compress a given token for easier storage. :param token: a BearerToken to serialize :return: the serialized token, as a str \"\"\" return self . dumper ( token ) def loads ( self , serialized : str ) -> BearerToken : \"\"\" Deserialize a serialized token. :param serialized: the serialized token :return: the deserialized token \"\"\" return self . loader ( serialized )","title":"BearerTokenSerializer"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.__init__","text":"Initialize a BearerTokenSerializer . This needs a dumper and a loader functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided. :param dumper: a function to serialize a token into a str . :param loader: a function do deserialize a serialized token representation. Source code in requests_oauth2client/tokens.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def __init__ ( self , dumper : Optional [ Callable [[ BearerToken ], str ]] = None , loader : Optional [ Callable [[ str ], BearerToken ]] = None , ): \"\"\" Initialize a `BearerTokenSerializer`. This needs a `dumper` and a `loader` functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided. :param dumper: a function to serialize a token into a `str`. :param loader: a function do deserialize a serialized token representation. \"\"\" self . dumper = dumper or self . default_dumper self . loader = loader or self . default_loader","title":"__init__()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_dumper","text":"Serialize a token as JSON, then gzip compress, then encodes as base64url. :param token: the :class: BearerToken to serialize :return: the serialized value Source code in requests_oauth2client/tokens.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @staticmethod def default_dumper ( token : BearerToken ) -> str : \"\"\" Serialize a token as JSON, then gzip compress, then encodes as base64url. :param token: the :class:`BearerToken` to serialize :return: the serialized value \"\"\" return ( BinaPy . serialize_to ( \"json\" , token . as_dict ( True )) . to ( \"gzip\" ) . to ( \"b64u\" ) . ascii () )","title":"default_dumper()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_loader","text":"Deserialize a BearerToken. Does the opposite operations than default_dumper . :param serialized: the serialized token :return: a BearerToken Source code in requests_oauth2client/tokens.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def default_loader ( self , serialized : str , token_class : Type [ BearerToken ] = BearerToken ) -> BearerToken : \"\"\" Deserialize a BearerToken. Does the opposite operations than `default_dumper`. :param serialized: the serialized token :return: a BearerToken \"\"\" attrs = ( BinaPy ( serialized ) . decode_from ( \"b64u\" ) . decode_from ( \"gzip\" ) . parse_from ( \"json\" ) ) expires_at = attrs . get ( \"expires_at\" ) if expires_at : attrs [ \"expires_at\" ] = datetime . fromtimestamp ( expires_at ) return token_class ( ** attrs )","title":"default_loader()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.dumps","text":"Serialize and compress a given token for easier storage. :param token: a BearerToken to serialize :return: the serialized token, as a str Source code in requests_oauth2client/tokens.py 230 231 232 233 234 235 236 237 def dumps ( self , token : BearerToken ) -> str : \"\"\" Serialize and compress a given token for easier storage. :param token: a BearerToken to serialize :return: the serialized token, as a str \"\"\" return self . dumper ( token )","title":"dumps()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.loads","text":"Deserialize a serialized token. :param serialized: the serialized token :return: the deserialized token Source code in requests_oauth2client/tokens.py 239 240 241 242 243 244 245 246 def loads ( self , serialized : str ) -> BearerToken : \"\"\" Deserialize a serialized token. :param serialized: the serialized token :return: the deserialized token \"\"\" return self . loader ( serialized )","title":"loads()"},{"location":"api/#requests_oauth2client.tokens.IdToken","text":"Bases: SignedJwt Represent an ID Token. An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be prealably decoded. Source code in requests_oauth2client/tokens.py 249 250 251 252 253 254 class IdToken ( SignedJwt ): \"\"\" Represent an ID Token. An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be prealably decoded. \"\"\"","title":"IdToken"},{"location":"api/#requests_oauth2client.utils","text":"This module contains helper methods that are used in multiple places within requests_oauth2client .","title":"utils"},{"location":"api/#requests_oauth2client.utils.accepts_expires_in","text":"Decorate methods that accept an expires_at datetime parameter, to also allow an expires_in parameter in seconds. If supplied, expires_in will be converted to a datetime expires_in seconds in the future, and passed as expires_at in the decorated method. :param f: the method to decorate, with an expires_at parameter :return: a decorated method that accepts either expires_in or expires_at . Source code in requests_oauth2client/utils.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def accepts_expires_in ( f : Callable [ ... , Any ]) -> Callable [ ... , Any ]: \"\"\" Decorate methods that accept an `expires_at` datetime parameter, to also allow an `expires_in` parameter in seconds. If supplied, `expires_in` will be converted to a datetime `expires_in` seconds in the future, and passed as `expires_at` in the decorated method. :param f: the method to decorate, with an `expires_at` parameter :return: a decorated method that accepts either `expires_in` or `expires_at`. \"\"\" @wraps ( f ) def decorator ( * args : Any , expires_in : Optional [ int ] = None , expires_at : Optional [ datetime ] = None , ** kwargs : Any , ) -> Any : if expires_in is None and expires_at is None : return f ( * args , ** kwargs ) if expires_in and isinstance ( expires_in , int ) and expires_in >= 1 : expires_at = datetime . now () + timedelta ( seconds = expires_in ) return f ( * args , expires_at = expires_at , ** kwargs ) return decorator","title":"accepts_expires_in()"},{"location":"api/#requests_oauth2client.utils.validate_endpoint_uri","text":"Validate that an URI is suitable as an endpoint URI. It checks: that the scheme is https that no fragment is included that a path is present Those check can be individually disabled using the parameters https , no_fragment and path . :param uri: the uri :param https: if True , check that the uri is https :param no_fragment: if True , check that the uri contains no fragment :param path: if True , check that the uri contains a path component :return: Source code in requests_oauth2client/utils.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def validate_endpoint_uri ( uri : str , https : bool = True , no_fragment : bool = True , path : bool = True ) -> None : \"\"\" Validate that an URI is suitable as an endpoint URI. It checks: - that the scheme is `https` - that no fragment is included - that a path is present Those check can be individually disabled using the parameters `https`, `no_fragment` and `path`. :param uri: the uri :param https: if `True`, check that the uri is https :param no_fragment: if `True`, check that the uri contains no fragment :param path: if `True`, check that the uri contains a path component :return: \"\"\" url = furl ( uri ) if https and url . scheme != \"https\" : raise ValueError ( \"url must use https\" ) if no_fragment and url . fragment : raise ValueError ( \"url must not contain a fragment\" ) if path and ( not url . path or url . path == \"/\" ): raise ValueError ( \"url has no path\" )","title":"validate_endpoint_uri()"},{"location":"api/#requests_oauth2client.vendor_specific","text":"This module contains vendor-specific subclasses of [requests_oauth2client] classes, that make it easier to work with specific OAuth 2.x providers and/or fix compatibility issues.","title":"vendor_specific"},{"location":"api/#requests_oauth2client.vendor_specific.auth0","text":"Implements subclasses for Auth0 .","title":"auth0"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0Client","text":"Bases: OAuth2Client A OAuth2Client for an Auth0 tenant. You only have to provide a tenant name and all endpoints will be initialized to work with your tenant. Source code in requests_oauth2client/vendor_specific/auth0.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Auth0Client ( OAuth2Client ): \"\"\" A OAuth2Client for an Auth0 tenant. You only have to provide a tenant name and all endpoints will be initialized to work with your tenant. \"\"\" def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `Auth0Client`. :param tenant: the tenant name or FQDN. If it doesn't contain a `.` or it ends with `.eu`, `.us`, or `.au`, then `.auth0.com` will automatically be suffixed to the provided tenant name. :param auth: the client credentials, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] :param session: the session to use, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] \"\"\" if ( \".\" not in tenant or tenant . endswith ( \".eu\" ) or tenant . endswith ( \".us\" ) or tenant . endswith ( \".au\" ) ): tenant = f \" { tenant } .auth0.com\" self . tenant = tenant token_endpoint = f \"https:// { tenant } /oauth/token\" revocation_endpoint = f \"https:// { tenant } /oauth/revoke\" userinfo_endpoint = f \"https:// { tenant } /userinfo\" jwks_uri = f \"https:// { tenant } /.well-known/jwks.json\" super () . __init__ ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , )","title":"Auth0Client"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0Client.__init__","text":"Initialize an Auth0Client . :param tenant: the tenant name or FQDN. If it doesn't contain a . or it ends with .eu , .us , or .au , then .auth0.com will automatically be suffixed to the provided tenant name. :param auth: the client credentials, same definition as for OAuth2Client :param session: the session to use, same definition as for OAuth2Client Source code in requests_oauth2client/vendor_specific/auth0.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ): \"\"\" Initialize an `Auth0Client`. :param tenant: the tenant name or FQDN. If it doesn't contain a `.` or it ends with `.eu`, `.us`, or `.au`, then `.auth0.com` will automatically be suffixed to the provided tenant name. :param auth: the client credentials, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] :param session: the session to use, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client.__init__] \"\"\" if ( \".\" not in tenant or tenant . endswith ( \".eu\" ) or tenant . endswith ( \".us\" ) or tenant . endswith ( \".au\" ) ): tenant = f \" { tenant } .auth0.com\" self . tenant = tenant token_endpoint = f \"https:// { tenant } /oauth/token\" revocation_endpoint = f \"https:// { tenant } /oauth/revoke\" userinfo_endpoint = f \"https:// { tenant } /userinfo\" jwks_uri = f \"https:// { tenant } /.well-known/jwks.json\" super () . __init__ ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , )","title":"__init__()"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0ManagementApiClient","text":"Bases: ApiClient A wrapper around Auth0 Management API v2 , for a given Auth0 tenant. Usage: 1 2 a0mgmt = Auth0ManagementApiClient ( \"mytenant.eu\" , ( client_id , client_secret )) users = a0mgmt . get ( \"users\" , params = { \"page\" : 0 , \"per_page\" : 100 }) Source code in requests_oauth2client/vendor_specific/auth0.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Auth0ManagementApiClient ( ApiClient ): \"\"\" A wrapper around [Auth0 Management API v2](https://auth0.com/docs/api/management/v2), for a given Auth0 tenant. Usage: ```python a0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (client_id, client_secret)) users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100}) ``` \"\"\" def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an Auth0ManagementApiClient against a given Auth0 tenant. :param tenant: the tenant name. Same definition as for [Auth0Client][requests_oauth2client.vendor_specific.auth0.Auth0Client] :param auth: client credentials. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param session: requests session. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param kwargs: additional kwargs to pass to the ApiClient base class \"\"\" client = Auth0Client ( tenant , auth , session = session ) audience = f \"https:// { client . tenant } /api/v2/\" api_auth = OAuth2ClientCredentialsAuth ( client , audience = audience ) super () . __init__ ( url = audience , auth = api_auth , session = session , ** kwargs , )","title":"Auth0ManagementApiClient"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0ManagementApiClient.__init__","text":"Initialize an Auth0ManagementApiClient against a given Auth0 tenant. :param tenant: the tenant name. Same definition as for Auth0Client :param auth: client credentials. Same definition as for OAuth2Client :param session: requests session. Same definition as for OAuth2Client :param kwargs: additional kwargs to pass to the ApiClient base class Source code in requests_oauth2client/vendor_specific/auth0.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , tenant : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ** kwargs : Any , ): \"\"\" Initialize an Auth0ManagementApiClient against a given Auth0 tenant. :param tenant: the tenant name. Same definition as for [Auth0Client][requests_oauth2client.vendor_specific.auth0.Auth0Client] :param auth: client credentials. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param session: requests session. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client] :param kwargs: additional kwargs to pass to the ApiClient base class \"\"\" client = Auth0Client ( tenant , auth , session = session ) audience = f \"https:// { client . tenant } /api/v2/\" api_auth = OAuth2ClientCredentialsAuth ( client , audience = audience ) super () . __init__ ( url = audience , auth = api_auth , session = session , ** kwargs , ) selection: docstring_style: restructured-text filters: - \"!^_\" - \"^ init \" - \"!^utils\" rendering: members_order: source show_root_heading: true","title":"__init__()"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Guillaume Pujol guill.p.linux@gmail.com Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Guillaume Pujol guill.p.linux@gmail.com","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/guillp/requests_oauth2client/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 requests_oauth2client could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up requests_oauth2client for local development. Fork the requests_oauth2client repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/requests_oauth2client.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/requests_oauth2client/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 1 $ pytest tests.test_client_credentials To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/guillp/requests_oauth2client/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"requests_oauth2client could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up requests_oauth2client for local development. Fork the requests_oauth2client repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/requests_oauth2client.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/requests_oauth2client/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_client_credentials To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 1.0.0 (to be released) \u00b6 First properly documented version. Migrated from pipenv to poetry Added pre-commit checks requests is now automatically imported with from requests_oauth2client import * ApiClient is now a wrapper around requests.Session instead of a subclass ApiClient.__init__() now accepts extra kwargs which will be used to configure the Session . Add __getitem__ and __getattr_ to ApiClient AuthorizationRequest.validate_callback() now returns an AuthorizationResponse which contains all returned response attributes instead of just a code. To access the authorization code, get the code attribute from that response. OAuth2Client.authorization_code() now accepts an AuthorizationResponse as parameter, and will use it to include all necessary parameters for the Authorization Code Grant. removed OAuth2Client.authorization_code_pkce() Renamed ClientSecretJWT and PrivateKeyJWT to ClientSecretJwt and PrivateKeyJwt , for consistency with jwskate . Methods from requests_oauth2client.utils are no longer exposed in top-level module. Renamed base class ClientAuthenticationMethod to BaseClientAuthenticationMethod . Introduced a default timeout in ApiClient Splitted jwskate into its own independant module Use BinaPy for binary data manipulation Add support for Pushed Authorization Requests \\<= 0.18 \u00b6 Draft versions","title":"Changelog"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#100-to-be-released","text":"First properly documented version. Migrated from pipenv to poetry Added pre-commit checks requests is now automatically imported with from requests_oauth2client import * ApiClient is now a wrapper around requests.Session instead of a subclass ApiClient.__init__() now accepts extra kwargs which will be used to configure the Session . Add __getitem__ and __getattr_ to ApiClient AuthorizationRequest.validate_callback() now returns an AuthorizationResponse which contains all returned response attributes instead of just a code. To access the authorization code, get the code attribute from that response. OAuth2Client.authorization_code() now accepts an AuthorizationResponse as parameter, and will use it to include all necessary parameters for the Authorization Code Grant. removed OAuth2Client.authorization_code_pkce() Renamed ClientSecretJWT and PrivateKeyJWT to ClientSecretJwt and PrivateKeyJwt , for consistency with jwskate . Methods from requests_oauth2client.utils are no longer exposed in top-level module. Renamed base class ClientAuthenticationMethod to BaseClientAuthenticationMethod . Introduced a default timeout in ApiClient Splitted jwskate into its own independant module Use BinaPy for binary data manipulation Add support for Pushed Authorization Requests","title":"1.0.0 (to be released)"},{"location":"history/#-018","text":"Draft versions","title":"\\&lt;= 0.18"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install requests_oauth2client, run this command in your terminal: 1 $ pip install requests_oauth2client This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for requests_oauth2client can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/requests_oauth2client Or download the tarball : 1 $ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install requests_oauth2client, run this command in your terminal: 1 $ pip install requests_oauth2client This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for requests_oauth2client can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/requests_oauth2client Or download the tarball : 1 $ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use requests_oauth2client in a project 1 from requests_oauth2client import * Alternatively, you can import only the required components one by one instead of * . You usually also have to use requests for your actual API calls: 1 import requests That is unless you use the ApiClient class as a wrapper around requests.Session . In that case, you don't need to import requests at all!","title":"Usage"},{"location":"usage/#usage","text":"To use requests_oauth2client in a project 1 from requests_oauth2client import * Alternatively, you can import only the required components one by one instead of * . You usually also have to use requests for your actual API calls: 1 import requests That is unless you use the ApiClient class as a wrapper around requests.Session . In that case, you don't need to import requests at all!","title":"Usage"}]}