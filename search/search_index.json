{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Python OAuth 2.x client, able to obtain, refresh and revoke tokens from any OAuth2.x/OIDC compliant Authorization Server. It can act as an OAuth 2.0/2.1 client, to automatically get and renew access tokens, based on the Client Credentials, Authorization Code, Refresh token, Device Authorization, or CIBA grants. It comes with a requests add-on to handle OAuth 2.0 Bearer Token based authorization when accessing APIs. It also supports OpenID Connect, PKCE, Client Assertions, Token Revocation, Exchange, and Introspection, Backchannel Authentication requests, as well as using custom params to any endpoint, and other important features that are often overlooked in other client libraries. And it also includes a wrapper around requests.Session that makes it super easy to use REST-style APIs, with or without OAuth 2.0. Installation \u00b6 As easy as: 1 pip install requests_oauth2client Usage \u00b6 Import it like this: 1 from requests_oauth2client import * Calling APIs with an access token \u00b6 If you already managed to obtain an access token, you can simply use the BearerAuth Auth Handler for requests : 1 2 token = \"an_access_token\" resp = requests.get(\"https://my.protected.api/endpoint\", auth=BearerAuth(token)) This authentication handler will add a properly formatted Authorization header in the request, with your access token according to RFC6750. Using an OAuth2Client \u00b6 OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints. To initialize an OAuth2Client , you only need a Token Endpoint URI, and the credentials for your application, which are often a client_id and a client_secret : 1 oauth2client = OAuth2Client(\"https://myas.local/token_endpoint\", (\"client_id\", \"client_secret\")) The Token Endpoint is the only Endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by OAuth2Client is Client Secret Post , but other standardised methods such as Client Secret Basic , Client Secret JWT or Private Key JWT are supported as well. See below. Obtaining tokens \u00b6 OAuth2Client has methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the token endpoint and authentication method are already declared for the client, the only required parameters are those that will be sent in the request to the Token Endpoint. Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken will manage the token expiration, will contain the eventual refresh token that matches the access token, and will keep track of other associated metadata as well. You can create such a BearerToken yourself if you need: 1 2 3 4 5 bearer_token = BearerToken(access_token=\"an_access_token\", expires_in=60) print(bearer_token) > {'access_token': 'an_access_token', 'expires_in': 55, 'token_type': 'Bearer'} print(bearer_token.expires_at) > datetime.datetime(2021, 8, 20, 9, 56, 59, 498793) Note that the expires_in indicator here is not static. It keeps track of the token lifetime and is calculated as the time flies. You can check if a token is expired with bearer_token.is_expired() . You can use a BearerToken instance everywhere you can supply an access_token as string. Using OAuth2Client as a requests Auth Handler \u00b6 While using OAuth2Client directly is great for testing or debugging OAuth2.0 flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. requests_oauth2client contains several requests compatible Auth Handler (subclasses of requests.auth.AuthBase , that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a [requests.Session], or an ApiClient which is a Session Subclass with a few enhancements as described below. Client Credentials grant \u00b6 To send a request using the Client Credentials grant, use the aptly named .client_credentials() method: 1 2 3 4 5 token = oauth2client.client_credentials( scope=\"myscope\", resource=\"https://myapi.local\" # you may pass additional kw params such as audience, or whatever your AS needs ) As Auth Handler \u00b6 You can use the OAuth2ClientCredentials auth handler. It takes an OAuth2Client as parameter, and the additional kwargs to pass to the token endpoint: 1 2 3 4 5 6 api_client = ApiClient( 'https://myapi.local/resource', auth=OAuth2ClientCredentials(oauth2client, scope='myscope', resource=\"https://myapi.local\") ) resp = api_client.get() # when you send your first request to the API, it will fetch an access token first. Authorization Code Grant \u00b6 Obtaining tokens with the Authorization code grant is made in 3 steps: your application must open specific url called the Authentication Request in a browser. your application must obtain and validate the Authorization Response , which is a redirection back to your application that contains an Authorization Code as parameter. your application must then exchange this Authorization Code for an Access Token , with a request to the Token Endpoint. OAuth2Client doesn't implement anything that is related to the Authorization Request or Response. It is only able to exchange the Authorization Code for a Token in step 3. But requests_oauth2client has other classes to help you with steps 1 and 2, as described below: Generating Authorization Requests \u00b6 You can generate valid authorization requests with the AuthorizationRequest class: 1 2 3 4 5 6 7 8 auth_request = AuthorizationRequest( authorization_endpoint, client_id, redirect_uri=redirect_uri, scope=scope, resource=resource, # not mandatory ) # add any other param that needs to be sent to your AS print(auth_request) # redirect the user to that URL to get a code This request will look like this (with line breaks for display purposes only): 1 2 3 4 5 6 7 8 9 10 https://myas.local/authorize ?client_id=my_client_id &redirect_uri=http%3A%2F%2Flocalhost%2Fcallback &response_type=code &state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc &nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc &scope=openid+email+profile &code_challenge=Dk11ttaDb_Hyq1dObMqQcTIlfYYRVblFMC9lFM3UWW8 &code_challenge_method=S256 &resource=https%3A%2F%2Fmy.resource.local%2Fapi [AuthorizationRequest] supports PKCE and uses it by default. You can avoid it by passing code_challenge_method=None to [AuthenticationRequest]. You can obtain the generated code_verifier from auth_request.code_verifier . Redirecting or otherwise sending the user to this url is your application responsibility, as well as obtaining the Authorization Response url. Validating the Authorization Response \u00b6 Once the user is successfully authenticated and authorized, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response . It contains several parameters that must be retrieved by your client. The authorization code is one of those parameters, but you must also validate that the state matches your request. You can do this with: 1 2 params = input(\"Please enter the full url and/or params obtained on the redirect_uri: \") code = auth_request.validate_callback(params) Exchanging code for tokens \u00b6 To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method: 1 2 3 4 token = oauth2client.authorization_code( code=code, code_verifier=auth_request.code_verifier, redirect_uri=redirect_uri) # redirect_uri is not always mandatory, but some AS still requires it As Auth Handler \u00b6 The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server: 1 2 3 4 5 6 7 api_client = ApiClient( \"https://your.protected.api/endpoint\", auth=OAuth2AuthorizationCodeAuth( client, code, code_verifier=auth_request.code_verifier, redirect_uri=redirect_uri) resp = api_client.post(data={...}) # first call will exchange the code for an initial access/refresh tokens OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available. Device Authorization Grant \u00b6 Helpers for the Device Authorization Grant are also included. To get device and user codes: 1 2 3 4 5 6 7 client = OAuth2Client( token_endpoint=\"https://myas.local/token\", device_authorization_endpoint=\"https://myas.local/device\", auth=(client_id, client_secret), ) da_resp = client.authorize_device() da_resp contains the Device Code, User Code, Verification URI and other info returned by the AS: 1 2 3 4 5 6 da_resp.device_code da_resp.user_code da_resp.verification_uri da_resp.verification_uri_complete da_resp.expires_at # just like for BearerToken, expiration is tracked by requests_oauth2client da_resp.interval Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and input the User Code. You can then request the Token endpoint to check if the user successfully authorized you using an `OAuth2Client`: 1 token = client.device_code(da_resp.device_code) This will raise an exception, either AuthorizationPending , SlowDown , ExpiredToken , or AccessDenied if the user did not yet finish authorizing your device, if you should increase your pooling period, or if the device code is no longer valid, or the user finally denied your access, respectively. Other exceptions may be raised depending on the error code that the AS responds with. If the user did finish authorizing successfully, token will contain your access token. To make pooling easier, you can use a DeviceAuthorizationPoolingJob like this: 1 2 3 4 5 6 7 8 9 10 11 pool_job = DeviceAuthorizationPoolingJob( client, device_auth_resp.device_code, interval=device_auth_resp.interval ) resp = None while resp is None: resp = pool_job() assert isinstance(resp, BearerToken) DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call pool_job(), it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests. As Auth Handler \u00b6 Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token: 1 2 3 4 5 6 7 8 api_client = ApiClient( \"https://your.protected.api/endpoint\", auth=OAuth2DeviceCodeAuth( client, device_auth_resp.device_code, interval=device_auth_resp.interval, expires_in=device_auth_resp.expires_in ) resp = api_client.post(data={...}) # first call will hang until the user authorizes your app and the token endpoint returns a token. Client-Initiated Backchannel Authentication (CIBA) \u00b6 To initiate a BackChannel Authentication against the dedicated endpoint: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client( token_endpoint=\"https://myas.local/token\", backchannel_authentication_endpoint=\"https://myas.local/backchannel_authorize\", auth=(client_id, client_secret) ) ba_resp = client.backchannel_authentication_request( scope=\"openid email profile\", login_hint=\"user@example.net\", ) ba_resp will contain the response attributes as returned by the AS, including an auth_req_id : 1 2 3 4 5 ba_resp.auth_req_id ba_resp.expires_in # decreases as times fly ba_resp.expires_at # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS ba_resp.interval # the pooling interval indicated by the AS ba_resp.custom # if the AS respond with additional attributes, they are also accessible To pool the Token Endpoint until the end-user successfully authenticates: 1 2 3 4 5 6 7 8 9 10 11 pool_job = BackChannelAuthenticationPoolingJob( client=client, auth_req_id=ba_resp.auth_req_id, interval=bca_resp.interval, ) resp = None while resp is None: resp = pool_job() assert isinstance(resp, BearerToken) Supported Client Authentication Methods \u00b6 requests_oauth2client supports multiple client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client , with the auth parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards. client_secret_basic : client_id and client_secret are included in clear-text in the Authorization header. To use it, just pass a ClientSecretBasic(client_id, client_secret) } as auth parameter: 1 client = OAuth2Client(token_endpoint, auth=ClientSecretBasic(client_id, client_secret)) client_secret_post : client_id and client_secret are included as part of the body form data. To use it, pass a ClientSecretPost(client_id, client_secret) as auth parameter. This also what is being used as default when you pass a tuple (client_id, client_secret) as auth : 1 2 3 client = OAuth2Client(token_endpoint, auth=ClientSecretPost(client_id, client_secret)) # or client = OAuth2Client(token_endpoint, auth=(client_id, client_secret)) client_secret_jwt : client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and expiration date. To use it, pass a ClientSecretJWT(client_id, client_secret) as auth parameter. Assertion generation is entirely automatic, you don't have anything to do: 1 client = OAuth2Client(token_endpoint, auth=ClientSecretJWT(client_id, client_secret)) private_key_jwt : client uses a JWT assertion like client_secret_jwt , but it is signed with an asymmetric key. To use it, you need a private signing key, in a dict that matches the JWK format. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is as simple with the PrivateKeyJWT(client_id, private_jwk) auth handler: 1 2 3 4 5 6 7 8 9 10 11 private_jwk = { \"kid\": \"mykid\", \"kty\": \"RSA\", \"e\": \"AQAB\", \"n\": \"...\", \"d\": \"...\", \"p\": \"...\", \"q\": \"...\", \"dp\": \"...\", \"dq\": \"...\", \"qi\": \"...\", } client = OAuth2Client( \"https://myas.local/token\", auth=PrivateKeyJWT(client_id, private_jwk) ) none : client only presents its client_id in body form data to the AS, without any authentication credentials. Use PublicApp(client_id) : 1 client = OAuth2Client(token_endpoint, auth=PublicApp(client_id, client_secret)) Token Exchange \u00b6 To send a token exchange request, use the OAuth2Client.token_exchange() method: 1 2 3 4 5 client = OAuth2Client(token_endpoint, auth=...) token = client.token_exchange( subject_token='your_token_value', subject_token_type=\"urn:ietf:params:oauth:token-type:access_token\" ) As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like actor_token or actor_token_type , or any custom parameter. There are short names for token types, that will be automatically translated to standardised types: 1 2 3 4 5 6 token = client.token_exchange( subject_token='your_token_value', subject_token_type=\"access_token\", # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\" actor_token='your_actor_token', actor_token_type='id_token', # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\" ) Or to make it even easier, types can be guessed based on the supplied subject or actor token: 1 2 3 4 token = client.token_exchange( subject_token=BearerToken('your_token_value'), # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\" actor_token=IdToken('your_actor_token'), # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\" ) Token Revocation \u00b6 OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the `OAuth2Client`: 1 2 3 4 oauth2client = OAuth2Client( token_endpoint, revocation_endpoint=revocation_endpoint, auth=ClientSecretJWT(\"client_id\", \"client_secret\")) The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available: 1 2 3 oauth2client.revoke_token(\"mytoken\", token_type_hint=\"access_token\") oauth2client.revoke_access_token(\"mytoken\") # will automatically add token_type_hint=access_token oauth2client.revoke_refresh_token(\"mytoken\") # will automatically add token_type_hint=refresh_token Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server actually returns a standardised error, an exception will be raised instead. Token Introspection \u00b6 OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the OAuth2Client : 1 2 3 4 oauth2client = OAuth2Client( token_endpoint, introspection_endpoint=introspection_endpoint, auth=ClientSecretJWT(\"client_id\", \"client_secret\")) The OAuth2Client.introspect_token() method is then available: 1 resp = oauth2client.introspect_token(\"mytoken\", token_type_hint=\"access_token\") It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded). UserInfo Requests \u00b6 OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the OAuth2Client : 1 2 3 4 oauth2client = OAuth2Client( token_endpoint, userinfo_endpoint=userinfo_endpoint, auth=ClientSecretJWT(\"client_id\", \"client_secret\")) The OAuth2Client.userinfo() ) method is then available: 1 resp = oauth2client.userinfo(\"mytoken\") It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded). Initializing an OAuth2Client from a discovery document \u00b6 You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method: 1 oauth2client = OAuth2Client.from_discovery_endpoint(\"https://myas.local/.well-known/openid-configuration\") This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs. Specialized API Client \u00b6 Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, requests_oauth2client includes a specialized [requests.Session] subclass called ApiClient, which takes a root url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an auth parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests -compatible Authentication Handler . Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant: 1 2 3 oauth2client = OAuth2Client(\"https://myas.local/token\", (client_id, client_secret)) api = ApiClient(\"https://myapi.local/root\", auth=OAuth2ClientCredentialsAuth(oauth2client)) resp = api.get(\"/resource/foo\") # will actually send a GET to https://myapi.local/root/resource/foo Note that ApiClient will never send requests \"outside\" its configured root url, unless you specifically give it full url at request time. The leading / in /resource above is optional. A leading / will not \"reset\" the url path to root, which means that you can also write the relative path without the / and it will automatically be included: 1 api.get(\"resource/foo\") # will actually send a GET to https://myapi.local/root/resource/foo You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a / and appended to the url path: 1 2 api.get([\"resource\", \"foo\"]) # will actually send a GET to https://myapi.local/root/resource/foo api.get([\"users\", 1234, \"details\"]) # will actually send a GET to https://myapi.local/root/users/1234/details ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing raise_for_status=False when initializing your ApiClient : 1 2 3 4 5 api = ApiClient( \"http://httpstat.us\", raise_for_status=False # this defaults to True ) resp = api.get(\"500\") # without raise_for_status=False, this would raise a requests.exceptions.HTTPError You may override this at request time: 1 resp = api.get(\"500\", raise_for_status=True) # raise_for_status at request-time overrides raise_for_status defined at init-time Vendor-Specific clients \u00b6 requests_oauth2client being flexible enough to handle most use cases, you should be able to use any AS by any vendor as long as it supports OAuth 2.0. You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. The sub-module requests_oauth2client.vendor_specific includes such classes for Auth0: 1 2 3 4 5 6 7 8 9 10 from requests_oauth2client.vendor_specific import Auth0Client a0client = Auth0Client(\"mytenant.eu\", (client_id, client_secret)) # this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token # so you can use it directly token = a0client.client_credentials(audience=\"audience\") # this is a wrapper around Auth0 Management API a0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (client_id, client_secret)) myusers = a0mgmt.get(\"users\")","title":"Home"},{"location":"#installation","text":"As easy as: 1 pip install requests_oauth2client","title":"Installation"},{"location":"#usage","text":"Import it like this: 1 from requests_oauth2client import *","title":"Usage"},{"location":"#calling-apis-with-an-access-token","text":"If you already managed to obtain an access token, you can simply use the BearerAuth Auth Handler for requests : 1 2 token = \"an_access_token\" resp = requests.get(\"https://my.protected.api/endpoint\", auth=BearerAuth(token)) This authentication handler will add a properly formatted Authorization header in the request, with your access token according to RFC6750.","title":"Calling APIs with an access token"},{"location":"#using-an-oauth2client","text":"OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints. To initialize an OAuth2Client , you only need a Token Endpoint URI, and the credentials for your application, which are often a client_id and a client_secret : 1 oauth2client = OAuth2Client(\"https://myas.local/token_endpoint\", (\"client_id\", \"client_secret\")) The Token Endpoint is the only Endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by OAuth2Client is Client Secret Post , but other standardised methods such as Client Secret Basic , Client Secret JWT or Private Key JWT are supported as well. See below.","title":"Using an OAuth2Client"},{"location":"#obtaining-tokens","text":"OAuth2Client has methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the token endpoint and authentication method are already declared for the client, the only required parameters are those that will be sent in the request to the Token Endpoint. Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken will manage the token expiration, will contain the eventual refresh token that matches the access token, and will keep track of other associated metadata as well. You can create such a BearerToken yourself if you need: 1 2 3 4 5 bearer_token = BearerToken(access_token=\"an_access_token\", expires_in=60) print(bearer_token) > {'access_token': 'an_access_token', 'expires_in': 55, 'token_type': 'Bearer'} print(bearer_token.expires_at) > datetime.datetime(2021, 8, 20, 9, 56, 59, 498793) Note that the expires_in indicator here is not static. It keeps track of the token lifetime and is calculated as the time flies. You can check if a token is expired with bearer_token.is_expired() . You can use a BearerToken instance everywhere you can supply an access_token as string.","title":"Obtaining tokens"},{"location":"#using-oauth2client-as-a-requests-auth-handler","text":"While using OAuth2Client directly is great for testing or debugging OAuth2.0 flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. requests_oauth2client contains several requests compatible Auth Handler (subclasses of requests.auth.AuthBase , that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a [requests.Session], or an ApiClient which is a Session Subclass with a few enhancements as described below.","title":"Using OAuth2Client as a requests Auth Handler"},{"location":"#client-credentials-grant","text":"To send a request using the Client Credentials grant, use the aptly named .client_credentials() method: 1 2 3 4 5 token = oauth2client.client_credentials( scope=\"myscope\", resource=\"https://myapi.local\" # you may pass additional kw params such as audience, or whatever your AS needs )","title":"Client Credentials grant"},{"location":"#as-auth-handler","text":"You can use the OAuth2ClientCredentials auth handler. It takes an OAuth2Client as parameter, and the additional kwargs to pass to the token endpoint: 1 2 3 4 5 6 api_client = ApiClient( 'https://myapi.local/resource', auth=OAuth2ClientCredentials(oauth2client, scope='myscope', resource=\"https://myapi.local\") ) resp = api_client.get() # when you send your first request to the API, it will fetch an access token first.","title":"As Auth Handler"},{"location":"#authorization-code-grant","text":"Obtaining tokens with the Authorization code grant is made in 3 steps: your application must open specific url called the Authentication Request in a browser. your application must obtain and validate the Authorization Response , which is a redirection back to your application that contains an Authorization Code as parameter. your application must then exchange this Authorization Code for an Access Token , with a request to the Token Endpoint. OAuth2Client doesn't implement anything that is related to the Authorization Request or Response. It is only able to exchange the Authorization Code for a Token in step 3. But requests_oauth2client has other classes to help you with steps 1 and 2, as described below:","title":"Authorization Code Grant"},{"location":"#generating-authorization-requests","text":"You can generate valid authorization requests with the AuthorizationRequest class: 1 2 3 4 5 6 7 8 auth_request = AuthorizationRequest( authorization_endpoint, client_id, redirect_uri=redirect_uri, scope=scope, resource=resource, # not mandatory ) # add any other param that needs to be sent to your AS print(auth_request) # redirect the user to that URL to get a code This request will look like this (with line breaks for display purposes only): 1 2 3 4 5 6 7 8 9 10 https://myas.local/authorize ?client_id=my_client_id &redirect_uri=http%3A%2F%2Flocalhost%2Fcallback &response_type=code &state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc &nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc &scope=openid+email+profile &code_challenge=Dk11ttaDb_Hyq1dObMqQcTIlfYYRVblFMC9lFM3UWW8 &code_challenge_method=S256 &resource=https%3A%2F%2Fmy.resource.local%2Fapi [AuthorizationRequest] supports PKCE and uses it by default. You can avoid it by passing code_challenge_method=None to [AuthenticationRequest]. You can obtain the generated code_verifier from auth_request.code_verifier . Redirecting or otherwise sending the user to this url is your application responsibility, as well as obtaining the Authorization Response url.","title":"Generating Authorization Requests"},{"location":"#validating-the-authorization-response","text":"Once the user is successfully authenticated and authorized, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response . It contains several parameters that must be retrieved by your client. The authorization code is one of those parameters, but you must also validate that the state matches your request. You can do this with: 1 2 params = input(\"Please enter the full url and/or params obtained on the redirect_uri: \") code = auth_request.validate_callback(params)","title":"Validating the Authorization Response"},{"location":"#exchanging-code-for-tokens","text":"To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method: 1 2 3 4 token = oauth2client.authorization_code( code=code, code_verifier=auth_request.code_verifier, redirect_uri=redirect_uri) # redirect_uri is not always mandatory, but some AS still requires it","title":"Exchanging code for tokens"},{"location":"#as-auth-handler_1","text":"The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server: 1 2 3 4 5 6 7 api_client = ApiClient( \"https://your.protected.api/endpoint\", auth=OAuth2AuthorizationCodeAuth( client, code, code_verifier=auth_request.code_verifier, redirect_uri=redirect_uri) resp = api_client.post(data={...}) # first call will exchange the code for an initial access/refresh tokens OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available.","title":"As Auth Handler"},{"location":"#device-authorization-grant","text":"Helpers for the Device Authorization Grant are also included. To get device and user codes: 1 2 3 4 5 6 7 client = OAuth2Client( token_endpoint=\"https://myas.local/token\", device_authorization_endpoint=\"https://myas.local/device\", auth=(client_id, client_secret), ) da_resp = client.authorize_device() da_resp contains the Device Code, User Code, Verification URI and other info returned by the AS: 1 2 3 4 5 6 da_resp.device_code da_resp.user_code da_resp.verification_uri da_resp.verification_uri_complete da_resp.expires_at # just like for BearerToken, expiration is tracked by requests_oauth2client da_resp.interval Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and input the User Code. You can then request the Token endpoint to check if the user successfully authorized you using an `OAuth2Client`: 1 token = client.device_code(da_resp.device_code) This will raise an exception, either AuthorizationPending , SlowDown , ExpiredToken , or AccessDenied if the user did not yet finish authorizing your device, if you should increase your pooling period, or if the device code is no longer valid, or the user finally denied your access, respectively. Other exceptions may be raised depending on the error code that the AS responds with. If the user did finish authorizing successfully, token will contain your access token. To make pooling easier, you can use a DeviceAuthorizationPoolingJob like this: 1 2 3 4 5 6 7 8 9 10 11 pool_job = DeviceAuthorizationPoolingJob( client, device_auth_resp.device_code, interval=device_auth_resp.interval ) resp = None while resp is None: resp = pool_job() assert isinstance(resp, BearerToken) DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call pool_job(), it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests.","title":"Device Authorization Grant"},{"location":"#as-auth-handler_2","text":"Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token: 1 2 3 4 5 6 7 8 api_client = ApiClient( \"https://your.protected.api/endpoint\", auth=OAuth2DeviceCodeAuth( client, device_auth_resp.device_code, interval=device_auth_resp.interval, expires_in=device_auth_resp.expires_in ) resp = api_client.post(data={...}) # first call will hang until the user authorizes your app and the token endpoint returns a token.","title":"As Auth Handler"},{"location":"#client-initiated-backchannel-authentication-ciba","text":"To initiate a BackChannel Authentication against the dedicated endpoint: 1 2 3 4 5 6 7 8 9 10 client = OAuth2Client( token_endpoint=\"https://myas.local/token\", backchannel_authentication_endpoint=\"https://myas.local/backchannel_authorize\", auth=(client_id, client_secret) ) ba_resp = client.backchannel_authentication_request( scope=\"openid email profile\", login_hint=\"user@example.net\", ) ba_resp will contain the response attributes as returned by the AS, including an auth_req_id : 1 2 3 4 5 ba_resp.auth_req_id ba_resp.expires_in # decreases as times fly ba_resp.expires_at # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS ba_resp.interval # the pooling interval indicated by the AS ba_resp.custom # if the AS respond with additional attributes, they are also accessible To pool the Token Endpoint until the end-user successfully authenticates: 1 2 3 4 5 6 7 8 9 10 11 pool_job = BackChannelAuthenticationPoolingJob( client=client, auth_req_id=ba_resp.auth_req_id, interval=bca_resp.interval, ) resp = None while resp is None: resp = pool_job() assert isinstance(resp, BearerToken)","title":"Client-Initiated Backchannel Authentication (CIBA)"},{"location":"#supported-client-authentication-methods","text":"requests_oauth2client supports multiple client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client , with the auth parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards. client_secret_basic : client_id and client_secret are included in clear-text in the Authorization header. To use it, just pass a ClientSecretBasic(client_id, client_secret) } as auth parameter: 1 client = OAuth2Client(token_endpoint, auth=ClientSecretBasic(client_id, client_secret)) client_secret_post : client_id and client_secret are included as part of the body form data. To use it, pass a ClientSecretPost(client_id, client_secret) as auth parameter. This also what is being used as default when you pass a tuple (client_id, client_secret) as auth : 1 2 3 client = OAuth2Client(token_endpoint, auth=ClientSecretPost(client_id, client_secret)) # or client = OAuth2Client(token_endpoint, auth=(client_id, client_secret)) client_secret_jwt : client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and expiration date. To use it, pass a ClientSecretJWT(client_id, client_secret) as auth parameter. Assertion generation is entirely automatic, you don't have anything to do: 1 client = OAuth2Client(token_endpoint, auth=ClientSecretJWT(client_id, client_secret)) private_key_jwt : client uses a JWT assertion like client_secret_jwt , but it is signed with an asymmetric key. To use it, you need a private signing key, in a dict that matches the JWK format. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is as simple with the PrivateKeyJWT(client_id, private_jwk) auth handler: 1 2 3 4 5 6 7 8 9 10 11 private_jwk = { \"kid\": \"mykid\", \"kty\": \"RSA\", \"e\": \"AQAB\", \"n\": \"...\", \"d\": \"...\", \"p\": \"...\", \"q\": \"...\", \"dp\": \"...\", \"dq\": \"...\", \"qi\": \"...\", } client = OAuth2Client( \"https://myas.local/token\", auth=PrivateKeyJWT(client_id, private_jwk) ) none : client only presents its client_id in body form data to the AS, without any authentication credentials. Use PublicApp(client_id) : 1 client = OAuth2Client(token_endpoint, auth=PublicApp(client_id, client_secret))","title":"Supported Client Authentication Methods"},{"location":"#token-exchange","text":"To send a token exchange request, use the OAuth2Client.token_exchange() method: 1 2 3 4 5 client = OAuth2Client(token_endpoint, auth=...) token = client.token_exchange( subject_token='your_token_value', subject_token_type=\"urn:ietf:params:oauth:token-type:access_token\" ) As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like actor_token or actor_token_type , or any custom parameter. There are short names for token types, that will be automatically translated to standardised types: 1 2 3 4 5 6 token = client.token_exchange( subject_token='your_token_value', subject_token_type=\"access_token\", # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\" actor_token='your_actor_token', actor_token_type='id_token', # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\" ) Or to make it even easier, types can be guessed based on the supplied subject or actor token: 1 2 3 4 token = client.token_exchange( subject_token=BearerToken('your_token_value'), # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\" actor_token=IdToken('your_actor_token'), # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\" )","title":"Token Exchange"},{"location":"#token-revocation","text":"OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the `OAuth2Client`: 1 2 3 4 oauth2client = OAuth2Client( token_endpoint, revocation_endpoint=revocation_endpoint, auth=ClientSecretJWT(\"client_id\", \"client_secret\")) The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available: 1 2 3 oauth2client.revoke_token(\"mytoken\", token_type_hint=\"access_token\") oauth2client.revoke_access_token(\"mytoken\") # will automatically add token_type_hint=access_token oauth2client.revoke_refresh_token(\"mytoken\") # will automatically add token_type_hint=refresh_token Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server actually returns a standardised error, an exception will be raised instead.","title":"Token Revocation"},{"location":"#token-introspection","text":"OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the OAuth2Client : 1 2 3 4 oauth2client = OAuth2Client( token_endpoint, introspection_endpoint=introspection_endpoint, auth=ClientSecretJWT(\"client_id\", \"client_secret\")) The OAuth2Client.introspect_token() method is then available: 1 resp = oauth2client.introspect_token(\"mytoken\", token_type_hint=\"access_token\") It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded).","title":"Token Introspection"},{"location":"#userinfo-requests","text":"OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the OAuth2Client : 1 2 3 4 oauth2client = OAuth2Client( token_endpoint, userinfo_endpoint=userinfo_endpoint, auth=ClientSecretJWT(\"client_id\", \"client_secret\")) The OAuth2Client.userinfo() ) method is then available: 1 resp = oauth2client.userinfo(\"mytoken\") It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded).","title":"UserInfo Requests"},{"location":"#initializing-an-oauth2client-from-a-discovery-document","text":"You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method: 1 oauth2client = OAuth2Client.from_discovery_endpoint(\"https://myas.local/.well-known/openid-configuration\") This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs.","title":"Initializing an OAuth2Client from a discovery document"},{"location":"#specialized-api-client","text":"Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, requests_oauth2client includes a specialized [requests.Session] subclass called ApiClient, which takes a root url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an auth parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests -compatible Authentication Handler . Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant: 1 2 3 oauth2client = OAuth2Client(\"https://myas.local/token\", (client_id, client_secret)) api = ApiClient(\"https://myapi.local/root\", auth=OAuth2ClientCredentialsAuth(oauth2client)) resp = api.get(\"/resource/foo\") # will actually send a GET to https://myapi.local/root/resource/foo Note that ApiClient will never send requests \"outside\" its configured root url, unless you specifically give it full url at request time. The leading / in /resource above is optional. A leading / will not \"reset\" the url path to root, which means that you can also write the relative path without the / and it will automatically be included: 1 api.get(\"resource/foo\") # will actually send a GET to https://myapi.local/root/resource/foo You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a / and appended to the url path: 1 2 api.get([\"resource\", \"foo\"]) # will actually send a GET to https://myapi.local/root/resource/foo api.get([\"users\", 1234, \"details\"]) # will actually send a GET to https://myapi.local/root/users/1234/details ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing raise_for_status=False when initializing your ApiClient : 1 2 3 4 5 api = ApiClient( \"http://httpstat.us\", raise_for_status=False # this defaults to True ) resp = api.get(\"500\") # without raise_for_status=False, this would raise a requests.exceptions.HTTPError You may override this at request time: 1 resp = api.get(\"500\", raise_for_status=True) # raise_for_status at request-time overrides raise_for_status defined at init-time","title":"Specialized API Client"},{"location":"#vendor-specific-clients","text":"requests_oauth2client being flexible enough to handle most use cases, you should be able to use any AS by any vendor as long as it supports OAuth 2.0. You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. The sub-module requests_oauth2client.vendor_specific includes such classes for Auth0: 1 2 3 4 5 6 7 8 9 10 from requests_oauth2client.vendor_specific import Auth0Client a0client = Auth0Client(\"mytenant.eu\", (client_id, client_secret)) # this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token # so you can use it directly token = a0client.client_credentials(audience=\"audience\") # this is a wrapper around Auth0 Management API a0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (client_id, client_secret)) myusers = a0mgmt.get(\"users\")","title":"Vendor-Specific clients"},{"location":"api/","text":"api_client \u00b6 ApiClient \u00b6 A Wrapper around :class: requests.Session to simplify Rest API calls. This allows setting a root url at creation time, then passing relative urls at request time. It may also raise exceptions instead of returning error responses. Basic usage: 1 2 3 from requests_oauth2client import ApiClient api = ApiClient(\"https://myapi.local/resource\") resp = api.get(\"/myid\") # this will send a GET request to https://myapi.local/resource/myid __init__ ( self , url = None , auth = None , raise_for_status = True ) special \u00b6 Parameters: Name Type Description Default url Optional[str] the base api url. This url will serve as root for relative urls passed to :method: ApiClient.request() , :method: ApiClient.get() , etc. None auth Optional[requests.auth.AuthBase] the :class: requests.auth.AuthBase to use as authentication handler. None raise_for_status bool if True , exceptions will be raised everytime a request returns an error code (>= 400). This parameter may be overridden at request time. True Source code in requests_oauth2client\\api_client.py def __init__ ( self , url : Optional [ str ] = None , auth : Optional [ requests . auth . AuthBase ] = None , raise_for_status : bool = True , ): \"\"\" :param url: the base api url. This url will serve as root for relative urls passed to :method:`ApiClient.request()`, :method:`ApiClient.get()`, etc. :param auth: the :class:`requests.auth.AuthBase` to use as authentication handler. :param raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (>= 400). This parameter may be overridden at request time. \"\"\" super ( ApiClient , self ) . __init__ () self . url = url self . auth = auth self . raise_for_status = raise_for_status delete ( self , url = None , raise_for_status = None , ** kwargs ) \u00b6 Sends a DELETE request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def delete ( # type: ignore self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Sends a DELETE request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"DELETE\" , url , raise_for_status = raise_for_status , ** kwargs ) get ( self , url = None , raise_for_status = None , ** kwargs ) \u00b6 Sends a GET request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def get ( # type: ignore self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Sends a GET request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raise_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"GET\" , url , raise_for_status = raise_for_status , ** kwargs ) patch ( self , url = None , raise_for_status = None , ** kwargs ) \u00b6 Sends a PATCH request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def patch ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any ) -> requests . Response : # type: ignore \"\"\" Sends a PATCH request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PATCH\" , url , raise_for_status = raise_for_status , ** kwargs ) post ( self , url = None , raise_for_status = None , ** kwargs ) \u00b6 Sends a POST request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def post ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any ) -> requests . Response : # type: ignore \"\"\" Sends a POST request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"POST\" , url , raise_for_status = raise_for_status , ** kwargs ) put ( self , url = None , raise_for_status = None , ** kwargs ) \u00b6 Sends a PUT request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def put ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any ) -> requests . Response : # type: ignore \"\"\" Sends a PUT request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PUT\" , url , raise_for_status = raise_for_status , ** kwargs ) request ( self , method , url = None , params = None , data = None , headers = None , cookies = None , files = None , auth = None , timeout = None , allow_redirects = True , proxies = None , hooks = None , stream = None , verify = None , cert = None , json = None , raise_for_status = None ) \u00b6 A customized request method to handle a path instead of a full url. Parameters: Name Type Description Default method str the HTTP method to use required url Union[str, bytes, Iterable[Union[str, bytes]]] the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. None Returns: Type Description Response a :class: requests.Response as returned by requests Source code in requests_oauth2client\\api_client.py def request ( # type: ignore self , method : str , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , params : Union [ None , bytes , MutableMapping [ str , str ]] = None , data : Union [ None , str , bytes , MutableMapping [ str , Any ], Iterable [ Tuple [ str , Optional [ str ]]], IO [ Any ], ] = None , headers : Optional [ MutableMapping [ str , str ]] = None , cookies : Union [ None , RequestsCookieJar , MutableMapping [ str , str ]] = None , files : Optional [ MutableMapping [ str , IO [ Any ]]] = None , auth : Union [ None , Tuple [ str , str ], requests . auth . AuthBase , Callable [[ requests . PreparedRequest ], requests . PreparedRequest ], ] = None , timeout : Union [ None , float , Tuple [ float , float ], Tuple [ float , None ]] = None , allow_redirects : Optional [ bool ] = True , proxies : Optional [ MutableMapping [ str , str ]] = None , hooks : Optional [ MutableMapping [ str , Union [ Iterable [ Callable [[ requests . Response ], Any ]], Callable [[ requests . Response ], Any ], ], ] ] = None , stream : Optional [ bool ] = None , verify : Optional [ Union [ str , bool ]] = None , cert : Optional [ Union [ str , Tuple [ str , str ]]] = None , json : Optional [ Mapping [ str , Any ]] = None , raise_for_status : Optional [ bool ] = None , ) -> requests . Response : \"\"\" A customized request method to handle a path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. :return: a :class:`requests.Response` as returned by requests \"\"\" if self . url : if url is not None : if not isinstance ( url , ( str , bytes )): try : url = \"/\" . join ( [ part . decode () if isinstance ( part , bytes ) else str ( part ) for part in url if part ] ) except TypeError : raise TypeError ( \"Unexpected url type, please pass a relative path as string or bytes, \" \"or an iterable of string-able objects\" , type ( url ), ) if isinstance ( url , bytes ): url = url . decode () url = urljoin ( self . url + \"/\" , url . lstrip ( \"/\" )) else : url = self . url if url is None or not isinstance ( url , str ): raise ValueError ( \"No url to send the request to\" ) response = super ( ApiClient , self ) . request ( method , url , params = params , data = data , headers = headers , cookies = cookies , files = files , auth = auth , timeout = timeout , allow_redirects = allow_redirects , proxies = proxies , hooks = hooks , stream = stream , verify = verify , cert = cert , json = json , ) if raise_for_status is None : raise_for_status = self . raise_for_status if raise_for_status : response . raise_for_status () return response auth \u00b6 BearerAuth \u00b6 A Requests compatible Authentication helper for API protected with Bearer tokens. Using this AuthBase, you have to obtain an access token manually. token : Optional [ requests_oauth2client . tokens . BearerToken ] property writable \u00b6 The token that is used for authorization against the API. Returns: Type Description Optional[requests_oauth2client.tokens.BearerToken] OAuth2AccessTokenAuth \u00b6 A Requests Authentication handler using a Bearer access token, and can automatically refreshes it when expired. __call__ ( self , request ) special \u00b6 Adds the Parameters: Name Type Description Default request PreparedRequest required Returns: Type Description PreparedRequest Source code in requests_oauth2client\\auth.py def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Adds the :param request: :return: \"\"\" token = self . token if ( token is not None and token . is_expired () and token . refresh_token and self . client is not None ): self . token = self . client . refresh_token ( refresh_token = token . refresh_token , ** self . token_kwargs ) return super () . __call__ ( request ) __init__ ( self , client , token = None , ** token_kwargs ) special \u00b6 Initializes an Authorization handler (RFC6750), with an (optional) initial token. Parameters: Name Type Description Default client OAuth2Client an OAuth2Client configured to talk to the token endpoint. required token Union[str, requests_oauth2client.tokens.BearerToken] a BearerToken that has been retrieved from the token endpoint manually None token_kwargs Any additional kwargs to pass to the token endpoint {} Source code in requests_oauth2client\\auth.py def __init__ ( self , client : \"OAuth2Client\" , token : Optional [ Union [ str , BearerToken ]] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initializes an Authorization handler (RFC6750), with an (optional) initial token. :param client: an `OAuth2Client` configured to talk to the token endpoint. :param token: a BearerToken that has been retrieved from the token endpoint manually :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( token ) self . client = client self . token_kwargs = token_kwargs OAuth2AuthorizationCodeAuth \u00b6 A Requests Auth handler that exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired. OAuth2ClientCredentialsAuth \u00b6 A Requests Authentication handler that automatically gets access tokens from an OAuth20 Token Endpoint with the Client Credentials grant (and can get a new one once it is expired). OAuth2DeviceCodeAuth \u00b6 A Requests Auth handler that exchanges a Device Code for an access token, then automatically refreshes it once it is expired. authorization_request \u00b6 AuthorizationRequest \u00b6 Represents an Authorization Request. It generates a valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), stores all parameters, and may validate that the callback authorization response matches the state. default_exception_class \u00b6 Base class for error responses returned by the Authorization endpoint. __init__ ( self , authorization_endpoint , client_id , redirect_uri , scope , response_type = 'code' , state = True , nonce = True , code_verifier = None , code_challenge_method = 'S256' , ** kwargs ) special \u00b6 Creates an AuthorizationRequest. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: state: if True (default), a random state parameter will be generated for you. You may pass your own state as str, or set it to None so that the state parameter will not be included in the request. You may access that state in the state attribute from this request. nonce: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the nonce attribute from this request. code_verifier: if None, and code_challenge_method is 'S256' or 'plain', a valid code_challenge and code_verifier for PKCE will be automatically generated, and the code_challenge will be included in the request. You may pass your own code_verifier as a str parameter, in which case the appropriate code_challenge will be included in the request. Parameters: Name Type Description Default authorization_endpoint str the uri for the authorization endpoint required client_id str the client_id to include in the request required redirect_uri str the redirect_uri to include in the request required scope Union[str, Iterable[str]] the scope to include in the request, as an iterable of string, or a space-separated str required response_type str the response type to include in the request. 'code' state Union[str, bool] the state to include in the request, or True to autogenerate one (default). True nonce Union[str, bool] the nonce to include in the request, or True to autogenerate one (default). True code_verifier Optional[str] the state to include in the request, or True to autogenerate one (default). None code_challenge_method Optional[str] the method to use to derive the code_challenge from the code_verifier. 'S256' kwargs Any extra parameters to include in the request, as-is. {} Source code in requests_oauth2client\\authorization_request.py def __init__ ( self , authorization_endpoint : str , client_id : str , redirect_uri : str , scope : Union [ str , Iterable [ str ]], response_type : str = \"code\" , state : Union [ str , bool , None ] = True , nonce : Union [ str , bool , None ] = True , code_verifier : Optional [ str ] = None , code_challenge_method : Optional [ str ] = \"S256\" , ** kwargs : Any , ) -> None : \"\"\" Creates an AuthorizationRequest. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: * state: if True (default), a random state parameter will be generated for you. You may pass your own state as str, or set it to `None` so that the state parameter will not be included in the request. You may access that state in the `state` attribute from this request. * nonce: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the `nonce` attribute from this request. * code_verifier: if None, and `code_challenge_method` is 'S256' or 'plain', a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated, and the code_challenge will be included in the request. You may pass your own code_verifier as a str parameter, in which case the appropriate `code_challenge` will be included in the request. :param authorization_endpoint: the uri for the authorization endpoint :param client_id: the client_id to include in the request :param redirect_uri: the redirect_uri to include in the request :param scope: the scope to include in the request, as an iterable of string, or a space-separated str :param response_type: the response type to include in the request. :param state: the state to include in the request, or True to autogenerate one (default). :param nonce: the nonce to include in the request, or True to autogenerate one (default). :param code_verifier: the state to include in the request, or True to autogenerate one (default). :param code_challenge_method: the method to use to derive the code_challenge from the code_verifier. :param kwargs: extra parameters to include in the request, as-is. \"\"\" if state is True : state = secrets . token_urlsafe ( 32 ) elif state is False : state = None if scope is not None and isinstance ( scope , str ): scope = scope . split ( \" \" ) if nonce is True and scope is not None and \"openid\" in scope : nonce = secrets . token_urlsafe ( 32 ) elif nonce is False : nonce = None if scope is not None and not isinstance ( scope , str ): scope = \" \" . join ( str ( s ) for s in scope ) if \"code_challenge\" in kwargs : raise ValueError ( \"A code_challenge must not be passed as parameter. \" \"Pass the code_verifier instead, and the appropriate code_challenge \" \"will automatically be derived from it and included in the request, \" \"based on code_challenge_method.\" ) if not code_challenge_method : code_verifier = code_challenge = code_challenge_method = None else : if not code_verifier : code_verifier = PkceUtils . generate_code_verifier () code_challenge = PkceUtils . derive_challenge ( code_verifier , code_challenge_method ) self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . redirect_uri = redirect_uri self . response_type = response_type self . scope = scope self . state = state self . nonce = nonce self . code_verifier = code_verifier self . code_challenge = code_challenge self . code_challenge_method = code_challenge_method self . kwargs = kwargs self . args = dict ( client_id = client_id , redirect_uri = redirect_uri , response_type = response_type , scope = scope , state = state , nonce = nonce , code_challenge = code_challenge , code_challenge_method = code_challenge_method , ** kwargs , ) PkceUtils \u00b6 Contains helper methods for PKCE, as described in RFC7636 . derive_challenge ( verifier , method = 'S256' ) classmethod \u00b6 Derives the code_challenge from a given code_verifier . Parameters: Name Type Description Default verifier Union[str, bytes] a code verifier required method str the method to use for deriving the challenge. Accepts 'S256' or 'plain'. 'S256' Returns: Type Description str a code_challenge derived from the given verifier Source code in requests_oauth2client\\authorization_request.py @classmethod def derive_challenge ( cls , verifier : Union [ str , bytes ], method : str = \"S256\" ) -> str : \"\"\" Derives the `code_challenge` from a given `code_verifier`. :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier \"\"\" if isinstance ( verifier , bytes ): verifier = verifier . decode () if not cls . code_verifier_re . match ( verifier ): raise ValueError ( f \"Invalid code verifier, does not match { cls . code_verifier_re } \" , verifier , ) if method == \"S256\" : return b64u_encode ( hashlib . sha256 ( verifier . encode ()) . digest ()) elif method == \"plain\" : return verifier else : raise ValueError ( \"Unsupported code_challenge_method\" , method ) generate_code_verifier () classmethod \u00b6 Generates a valid code_verifier . Returns: Type Description str a code_verifier ready to use for PKCE Source code in requests_oauth2client\\authorization_request.py @classmethod def generate_code_verifier ( cls ) -> str : \"\"\" Generates a valid `code_verifier`. :return: a code_verifier ready to use for PKCE \"\"\" return secrets . token_urlsafe ( 96 ) generate_code_verifier_and_challenge ( method = 'S256' ) classmethod \u00b6 Generate a valid code_verifier and derives its code_challenge . Parameters: Name Type Description Default method str the method to use for deriving the challenge. Accepts 'S256' or 'plain'. 'S256' Returns: Type Description Tuple[str, str] a (code_verifier, code_challenge) tuple. Source code in requests_oauth2client\\authorization_request.py @classmethod def generate_code_verifier_and_challenge ( cls , method : str = \"S256\" ) -> Tuple [ str , str ]: \"\"\" Generate a valid `code_verifier` and derives its `code_challenge`. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. \"\"\" verifier = cls . generate_code_verifier () challenge = cls . derive_challenge ( verifier , method ) return verifier , challenge validate_code_verifier ( verifier , challenge , method = 'S256' ) classmethod \u00b6 Validates a code_verifier against a code_challenge . Parameters: Name Type Description Default verifier str the code_verifier , exactly as submitted by the client on token request. required challenge str the code_challenge , exactly as submitted by the client on authorization request. required method str the method to use for deriving the challenge. Accepts 'S256' or 'plain'. 'S256' Returns: Type Description bool True if verifier is valid, or False otherwise Source code in requests_oauth2client\\authorization_request.py @classmethod def validate_code_verifier ( cls , verifier : str , challenge : str , method : str = \"S256\" ) -> bool : \"\"\" Validates a `code_verifier` against a `code_challenge`. :param verifier: the `code_verifier`, exactly as submitted by the client on token request. :param challenge: the `code_challenge`, exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise \"\"\" return ( cls . code_verifier_re . match ( verifier ) is not None and cls . derive_challenge ( verifier , method ) == challenge ) backchannel_authentication \u00b6 BackChannelAuthenticationPoolingJob \u00b6 A pooling job for checking if the user has finished with his authorization in a Device Authorization flow. BackChannelAuthenticationResponse \u00b6 __getattr__ ( self , key ) special \u00b6 Returns items from this Token Response. Allows token_response.expires_in or token_response.any_custom_attribute Parameters: Name Type Description Default key str a key required Returns: Type Description Any the associated value in this token response Source code in requests_oauth2client\\backchannel_authentication.py def __getattr__ ( self , key : str ) -> Any : \"\"\" Returns items from this Token Response. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises: \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) return self . other . get ( key ) or super () . __getattribute__ ( key ) is_expired ( self ) \u00b6 Returns True if the auth_req_id within this response is expired at the time of the call. Returns: Type Description Optional[bool] True if the auth_req_id is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client\\backchannel_authentication.py def is_expired ( self ) -> Optional [ bool ]: \"\"\" Returns True if the auth_req_id within this response is expired at the time of the call. :return: True if the auth_req_id is expired, False if it is still valid, None if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () > self . expires_at return None client \u00b6 OAuth2Client \u00b6 An OAuth 2.0 client, able to obtain tokens from the Token Endpoint using one of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint. This class doesn't implement anything related to the end-user authentication or any request that goes in a browser. For authentication requests, see :class AuthorizationRequest . __init__ ( self , token_endpoint , auth , revocation_endpoint = None , introspection_endpoint = None , userinfo_endpoint = None , backchannel_authentication_endpoint = None , device_authorization_endpoint = None , jwks_uri = None , session = None ) special \u00b6 Parameters: Name Type Description Default token_endpoint str the token endpoint where this client will get access tokens required auth Union[requests.auth.AuthBase, Tuple[str, str], str] the authentication handler to use for client authentication on the token endpoint. Can be a requests.auth.AuthBase instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize an instance of default_auth_handler , or a client_id which will use PublicApp authentication. required revocation_endpoint Optional[str] the revocation endpoint url to use for revoking tokens, if any None introspection_endpoint Optional[str] the introspection endpoint url to get info about tokens, if any None session Optional[requests.sessions.Session] a requests Session to use when sending HTTP requests None Source code in requests_oauth2client\\client.py def __init__ ( self , token_endpoint : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], revocation_endpoint : Optional [ str ] = None , introspection_endpoint : Optional [ str ] = None , userinfo_endpoint : Optional [ str ] = None , backchannel_authentication_endpoint : Optional [ str ] = None , device_authorization_endpoint : Optional [ str ] = None , jwks_uri : Optional [ str ] = None , session : Optional [ requests . Session ] = None , ): \"\"\" :param token_endpoint: the token endpoint where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a `requests.auth.AuthBase` instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize an instance of `default_auth_handler`, or a client_id which will use PublicApp authentication. :param revocation_endpoint: the revocation endpoint url to use for revoking tokens, if any :param introspection_endpoint: the introspection endpoint url to get info about tokens, if any :param session: a requests Session to use when sending HTTP requests \"\"\" self . token_endpoint = str ( token_endpoint ) self . revocation_endpoint = ( str ( revocation_endpoint ) if revocation_endpoint else None ) self . introspection_endpoint = ( str ( introspection_endpoint ) if introspection_endpoint else None ) self . userinfo_endpoint = str ( userinfo_endpoint ) if userinfo_endpoint else None self . backchannel_authentication_endpoint = ( str ( backchannel_authentication_endpoint ) if backchannel_authentication_endpoint else None ) self . device_authorization_endpoint = ( str ( device_authorization_endpoint ) if device_authorization_endpoint else None ) self . jwks_uri = str ( jwks_uri ) if jwks_uri else None self . session = session or requests . Session () self . auth = client_auth_factory ( auth , ClientSecretPost ) authorization_code ( self , code , requests_kwargs = None , ** token_kwargs ) \u00b6 Sends a request to the token endpoint with the authorization_code grant. Parameters: Name Type Description Default code str an authorization code to exchange for tokens required token_kwargs Any additional parameters for the token endpoint, alongside grant_type, code, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a TokenResponse Source code in requests_oauth2client\\client.py def authorization_code ( self , code : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the authorization_code grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, code, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"authorization_code\" , code = code , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) authorization_code_pkce ( self , code , code_verifier , requests_kwargs = None , ** token_kwargs ) \u00b6 Sends a request to the token endpoint with the authorization_code grant, and This is just an alias to authorization_code() with code_verifier as mandatory parameter. Parameters: Name Type Description Default code str an authorization code to exchange for tokens required code_verifier str the code verifier that matches the authorization code required token_kwargs Any additional parameters for the token endpoint, alongside grant_type, code, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\client.py def authorization_code_pkce ( self , code : str , code_verifier : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the authorization_code grant, and This is just an alias to `authorization_code()` with code_verifier as mandatory parameter. :param code: an authorization code to exchange for tokens :param code_verifier: the code verifier that matches the authorization code :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, code, etc. :param requests_kwargs: additional parameters for the call to requests :return: a BearerToken \"\"\" return self . authorization_code ( code = code , code_verifier = code_verifier , requests_kwargs = requests_kwargs , ** token_kwargs , ) authorize_device ( self , ** data ) \u00b6 Sends a Device Authorization Request. Parameters: Name Type Description Default data Any additional data to send to the Device Authorization Endpoint {} Returns: Type Description DeviceAuthorizationResponse a Device Authorization Response Source code in requests_oauth2client\\client.py def authorize_device ( self , ** data : Any ) -> DeviceAuthorizationResponse : \"\"\" Sends a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response \"\"\" if self . device_authorization_endpoint is None : raise AttributeError ( \"No device authorization endpoint defined for this client\" ) response = self . session . post ( self . device_authorization_endpoint , data = data , auth = self . auth ) if response . ok : return self . parse_device_authorization_response ( response ) return self . on_device_authorization_error ( response ) backchannel_authentication_request ( self , scope , client_notification_token = None , acr_values = None , login_hint_token = None , id_token_hint = None , login_hint = None , binding_message = None , user_code = None , requested_expiry = None , requests_kwargs = None , private_jwk = None , alg = None , ** ciba_kwargs ) \u00b6 Sends a CIBA Authentication Request. Returns: Type Description BackChannelAuthenticationResponse a BackChannelAuthenticationResponse Source code in requests_oauth2client\\client.py def backchannel_authentication_request ( self , scope : Union [ str , Iterable [ str ]], client_notification_token : Optional [ str ] = None , acr_values : Optional [ str ] = None , login_hint_token : Optional [ str ] = None , id_token_hint : Optional [ str ] = None , login_hint : Optional [ str ] = None , binding_message : Optional [ str ] = None , user_code : Optional [ str ] = None , requested_expiry : Optional [ int ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , private_jwk : Union [ Jwk , Dict [ str , Any ], None ] = None , alg : Optional [ str ] = None , ** ciba_kwargs : Any , ) -> BackChannelAuthenticationResponse : \"\"\" Sends a CIBA Authentication Request. :return: a BackChannelAuthenticationResponse \"\"\" if not self . backchannel_authentication_endpoint : raise AttributeError ( \"No backchannel authentication endpoint defined for this client\" ) requests_kwargs = requests_kwargs or {} if not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc if not ( login_hint or login_hint_token or id_token_hint ): raise ValueError ( \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) if ( ( login_hint_token and id_token_hint ) or ( login_hint and id_token_hint ) or ( login_hint_token and login_hint ) ): raise ValueError ( \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) data = dict ( ciba_kwargs , scope = scope , client_notification_token = client_notification_token , acr_values = acr_values , login_hint_token = login_hint_token , id_token_hint = id_token_hint , login_hint = login_hint , binding_message = binding_message , user_code = user_code , requested_expiry = requested_expiry , ) if private_jwk is not None : data = { \"request\" : str ( Jwt . sign ( data , jwk = private_jwk , alg = alg ))} response = self . session . post ( self . backchannel_authentication_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_backchannel_authentication_response ( response ) return self . on_backchannel_authentication_error ( response ) client_credentials ( self , requests_kwargs = None , scope = None , ** token_kwargs ) \u00b6 Sends a request to the token endpoint with the client_credentials grant. Parameters: Name Type Description Default scope Union[str, Iterable[str]] the scope to send with the request. Can be a str, or an iterable of str. None token_kwargs Any additional parameters for the token endpoint, alongside grant_type. Common parameters to pass that way include scope, audience, resource, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a TokenResponse Source code in requests_oauth2client\\client.py def client_credentials ( self , requests_kwargs : Optional [ Dict [ str , Any ]] = None , scope : Optional [ Union [ str , Iterable [ str ]]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the client_credentials grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside grant_type. Common parameters to pass that way include scope, audience, resource, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc data = dict ( grant_type = \"client_credentials\" , scope = scope , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) device_code ( self , device_code , requests_kwargs = None , ** token_kwargs ) \u00b6 Sends a request to the token endpoint with the urn:ietf:params:oauth:grant-type:device_code grant. Parameters: Name Type Description Default device_code str a device code as received during the device authorization request required requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None token_kwargs Any additional parameters for the token endpoint, alongside grant_type, device_code, etc. {} Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\client.py def device_code ( self , device_code : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the urn:ietf:params:oauth:grant-type:device_code grant. :param device_code: a device code as received during the device authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, device_code, etc. :return: a BearerToken \"\"\" requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:device_code\" , device_code = device_code , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) from_discovery_document ( discovery , issuer , auth , session = None , https = True ) classmethod \u00b6 Initialise an OAuth2Client, based on the server metadata from discovery . Parameters: Name Type Description Default discovery Dict[str, Any] a dict of server metadata, in the same format as retrieved from a discovery endpoint. required issuer Optional[str] if an issuer is given, check that it matches the one mentioned in the document required auth Union[requests.auth.AuthBase, Tuple[str, str], str] the authentication handler to use for client authentication required session Optional[requests.sessions.Session] a requests Session to use to retrieve the document and initialise the client with None https bool if True, validates that urls in the discovery document use the https scheme True Returns: Type Description OAuth2Client an OAuth2Client Source code in requests_oauth2client\\client.py @classmethod def from_discovery_document ( cls , discovery : Dict [ str , Any ], issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , https : bool = True , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, based on the server metadata from `discovery`. :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client \"\"\" if issuer : # pragma: no branch issuer_from_doc = discovery . get ( \"issuer\" ) if issuer_from_doc != issuer : raise ValueError ( \"issuer mismatch!\" , issuer_from_doc ) token_endpoint = discovery . get ( \"token_endpoint\" ) if token_endpoint is None : raise ValueError ( \"token_endpoint not found in that discovery document\" ) validate_uri ( token_endpoint , https = https ) revocation_endpoint = discovery . get ( \"revocation_endpoint\" ) if revocation_endpoint is not None : validate_uri ( revocation_endpoint , https = https ) introspection_endpoint = discovery . get ( \"introspection_endpoint\" ) if introspection_endpoint is not None : validate_uri ( introspection_endpoint , https = https ) userinfo_endpoint = discovery . get ( \"userinfo_endpoint\" ) if userinfo_endpoint is not None : validate_uri ( userinfo_endpoint , https = https ) jwks_uri = discovery . get ( \"jwks_uri\" ) if jwks_uri is not None : validate_uri ( userinfo_endpoint , https = https ) return cls ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , introspection_endpoint = introspection_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , ) from_discovery_endpoint ( url , issuer , auth , session = None ) classmethod \u00b6 Initialise an OAuth2Client, retrieving server metadata from a discovery document. Parameters: Name Type Description Default url str the url where the server metadata will be retrieved required auth Union[requests.auth.AuthBase, Tuple[str, str], str] the authentication handler to use for client authentication required session Optional[requests.sessions.Session] a requests Session to use to retrieve the document and initialise the client with None issuer Optional[str] if an issuer is given, check that it matches the one from the retrieved document required Returns: Type Description OAuth2Client a OAuth2Client Source code in requests_oauth2client\\client.py @classmethod def from_discovery_endpoint ( cls , url : str , issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, retrieving server metadata from a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client \"\"\" session = session or requests . Session () discovery = session . get ( url ) . json () return cls . from_discovery_document ( discovery , issuer = issuer , auth = auth , session = session ) on_revocation_error ( self , response ) \u00b6 Executed when the revocation endpoint return an error. Parameters: Name Type Description Default response Response the revocation response required Returns: Type Description bool returns False to signal that an error occurred. May raise exceptions instead depending on the revocation response. Source code in requests_oauth2client\\client.py def on_revocation_error ( self , response : requests . Response ) -> bool : \"\"\" Executed when the revocation endpoint return an error. :param response: the revocation response :return: returns False to signal that an error occurred. May raise exceptions instead depending on the revocation response. \"\"\" try : data = response . json () except ValueError : return False error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , RevocationError ) raise exception_class ( error , error_description , error_uri ) return False on_token_error ( self , response ) \u00b6 Executed when the token endpoint returns an error. Parameters: Name Type Description Default response Response the token response required Returns: Type Description BearerToken should return nothing and raise an exception instead. But a subclass can return a BearerToken to implement a default behaviour if needed. Source code in requests_oauth2client\\client.py def on_token_error ( self , response : requests . Response ) -> BearerToken : \"\"\" Executed when the token endpoint returns an error. :param response: the token response :return: should return nothing and raise an exception instead. But a subclass can return a BearerToken to implement a default behaviour if needed. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidTokenResponse ( \"token endpoint returned an HTTP error without error message\" , error_json , ) parse_userinfo_response ( self , resp ) \u00b6 Given a response obtained from the userinfo endpoint, extracts its JSON content. A subclass may implement the signature validation and/or decryption of a userinfo JWT response. Parameters: Name Type Description Default resp Response a response obtained from the userinfo endpoint required Returns: Type Description Any the parsed JSON content from this response Source code in requests_oauth2client\\client.py def parse_userinfo_response ( self , resp : requests . Response ) -> Any : \"\"\" Given a response obtained from the userinfo endpoint, extracts its JSON content. A subclass may implement the signature validation and/or decryption of a userinfo JWT response. :param resp: a response obtained from the userinfo endpoint :return: the parsed JSON content from this response \"\"\" try : return resp . json () except ValueError : return resp . text refresh_token ( self , refresh_token , requests_kwargs = None , ** token_kwargs ) \u00b6 Sends a request to the token endpoint with the refresh_token grant. Parameters: Name Type Description Default refresh_token str a refresh_token required token_kwargs Any additional parameters for the token endpoint, alongside grant_type, refresh_token, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\client.py def refresh_token ( self , refresh_token : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the refresh_token grant. :param refresh_token: a refresh_token :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, refresh_token, etc. :param requests_kwargs: additional parameters for the call to requests :return: a BearerToken \"\"\" requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"refresh_token\" , refresh_token = refresh_token , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs ) revoke_access_token ( self , access_token , requests_kwargs = None , ** revoke_kwargs ) \u00b6 Sends a request to the revocation endpoint to revoke an access token. Parameters: Name Type Description Default access_token Union[requests_oauth2client.tokens.BearerToken, str] the access token to revoke required requests_kwargs Optional[Dict[str, Any]] additional parameters for the underlying requests.post() call None revoke_kwargs Any additional parameters to pass to the revocation endpoint {} Source code in requests_oauth2client\\client.py def revoke_access_token ( self , access_token : Union [ BearerToken , str ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Sends a request to the revocation endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint \"\"\" return self . revoke_token ( access_token , token_type_hint = \"access_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) revoke_refresh_token ( self , refresh_token , requests_kwargs = None , ** revoke_kwargs ) \u00b6 Sends a request to the revocation endpoint to revoke a refresh token. Parameters: Name Type Description Default refresh_token Union[str, requests_oauth2client.tokens.BearerToken] the refresh token to revoke. required requests_kwargs Optional[Dict[str, Any]] additional parameters to pass to the revocation endpoint. None revoke_kwargs Any additional parameters to pass to the revocation endpoint. {} Returns: Type Description bool True if the revocation request is successful, False if this client has no configured revocation endpoint. Source code in requests_oauth2client\\client.py def revoke_refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Sends a request to the revocation endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: True if the revocation request is successful, False if this client has no configured revocation endpoint. \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) refresh_token = refresh_token . refresh_token return self . revoke_token ( refresh_token , token_type_hint = \"refresh_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , ) revoke_token ( self , token , token_type_hint = None , requests_kwargs = None , ** revoke_kwargs ) \u00b6 Generic method to use the Revocation Endpoint. Parameters: Name Type Description Default token Union[str, requests_oauth2client.tokens.BearerToken] the token to revoke. required token_type_hint Optional[str] a token_type_hint to send to the revocation endpoint. None requests_kwargs Optional[Dict[str, Any]] additional parameters to the underling call to requests.post() None revoke_kwargs Any additional parameters to send to the revocation endpoint. {} Returns: Type Description bool True if the revocation succeeds, False if no revocation endpoint is present or a non-standardised error is returned. Source code in requests_oauth2client\\client.py def revoke_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Generic method to use the Revocation Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: True if the revocation succeeds, False if no revocation endpoint is present or a non-standardised error is returned. \"\"\" if not self . revocation_endpoint : return False requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( revoke_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . revocation_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return True return self . on_revocation_error ( response ) token_exchange ( self , subject_token , subject_token_type = None , actor_token = None , actor_token_type = None , requested_token_type = None , requests_kwargs = None , ** token_kwargs ) \u00b6 Sends a Token Exchange request, which is actually a request to the Token Endpoint with a grant_type urn:ietf:params:oauth:grant-type:token-exchange . Parameters: Name Type Description Default subject_token Union[str, requests_oauth2client.tokens.BearerToken, requests_oauth2client.tokens.IdToken] the subject token to exchange for a new token. required subject_token_type Optional[str] a token type identifier for the subject_token, mandatory if it cannot be guessed based on type(subject_token) . None actor_token Union[NoneType, str, requests_oauth2client.tokens.BearerToken, requests_oauth2client.tokens.IdToken] the actor token to include in the request, if any. None actor_token_type Optional[str] a token type identifier for the actor_token, mandatory if it cannot be guessed based on type(actor_token) . None requested_token_type Optional[str] a token type identifier for the requested token. None requests_kwargs Optional[Dict[str, Any]] additional parameters to pass to the underlying requests.post() call. None token_kwargs Any additional parameters to include in the request body. {} Returns: Type Description BearerToken a BearerToken as returned by the Authorization Server. Source code in requests_oauth2client\\client.py def token_exchange ( self , subject_token : Union [ str , BearerToken , IdToken ], subject_token_type : Optional [ str ] = None , actor_token : Union [ None , str , BearerToken , IdToken ] = None , actor_token_type : Optional [ str ] = None , requested_token_type : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a Token Exchange request, which is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`. :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on `type(subject_token)`. :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on `type(actor_token)`. :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying `requests.post()` call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. \"\"\" requests_kwargs = requests_kwargs or {} try : subject_token_type = self . get_token_type ( subject_token_type , subject_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of subject_token you provided.\" \"Please specify a subject_token_type.\" ) if actor_token : # pragma: no branch try : actor_token_type = self . get_token_type ( actor_token_type , actor_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of actor_token you provided.\" \"Please specify an actor_token_type.\" ) data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:token-exchange\" , subject_token = subject_token , subject_token_type = subject_token_type , actor_token = actor_token , actor_token_type = actor_token_type , requested_token_type = requested_token_type , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs ) token_request ( self , data , timeout = 10 , ** requests_kwargs ) \u00b6 Sends a authenticated request to the token endpoint. Parameters: Name Type Description Default data Dict[str, Any] parameters to send to the token endpoint required timeout int a timeout value for the call 10 requests_kwargs Any additional parameters for requests.post() {} Returns: Type Description BearerToken the token endpoint response, as BearerToken instance. Source code in requests_oauth2client\\client.py def token_request ( self , data : Dict [ str , Any ], timeout : int = 10 , ** requests_kwargs : Any ) -> BearerToken : \"\"\" Sends a authenticated request to the token endpoint. :param data: parameters to send to the token endpoint :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as BearerToken instance. \"\"\" requests_kwargs = { key : value for key , value in requests_kwargs . items () if value is not None and value != \"\" } response = self . session . post ( self . token_endpoint , auth = self . auth , data = data , timeout = timeout , ** requests_kwargs , ) if response . ok : return self . parse_token_response ( response ) return self . on_token_error ( response ) userinfo ( self , access_token ) \u00b6 Calls the userinfo endpoint with the specified access_token and returns the result. Parameters: Name Type Description Default access_token Union[requests_oauth2client.tokens.BearerToken, str] the access token to use required Returns: Type Description Any the requests Response returned by the userinfo endpoint. Source code in requests_oauth2client\\client.py def userinfo ( self , access_token : Union [ BearerToken , str ]) -> Any : \"\"\" Calls the userinfo endpoint with the specified access_token and returns the result. :param access_token: the access token to use :return: the requests Response returned by the userinfo endpoint. \"\"\" if not self . userinfo_endpoint : raise AttributeError ( \"No userinfo endpoint defined for this client\" ) response = self . session . post ( self . userinfo_endpoint , auth = BearerAuth ( access_token ) ) return self . parse_userinfo_response ( response ) client_authentication \u00b6 ClientAssertionAuthenticationMethod \u00b6 Base class for assertion based client authentication methods. ClientAuthenticationMethod \u00b6 Base class for the Client Authentication methods. ClientSecretBasic \u00b6 Handles client_secret_basic authentication (client_id and client_secret passed as Basic authentication) ClientSecretJWT \u00b6 Handles client_secret_jwt client authentication method (client_assertion symmetrically signed with the client_secret). ClientSecretPost \u00b6 Handles client_secret_post client authentication method (client_id and client_secret passed as part of the request form data). PrivateKeyJWT \u00b6 Handles private_key_jwt client authentication method (client_assertion asymmetrically signed with a private key). PublicApp \u00b6 Handles the \"none\" authentication method (client only sends its client_id). device_authorization \u00b6 DeviceAuthorizationPoolingJob \u00b6 A pooling job for checking if the user has finished with his authorization in a Device Authorization flow. DeviceAuthorizationResponse \u00b6 A response returned by the device Authorization Endpoint (as defined in RFC8628) is_expired ( self ) \u00b6 Returns True if the device_code within this response is expired at the time of the call. Returns: Type Description Optional[bool] True if the device_code is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client\\device_authorization.py def is_expired ( self ) -> Optional [ bool ]: \"\"\" Returns True if the device_code within this response is expired at the time of the call. :return: True if the device_code is expired, False if it is still valid, None if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () > self . expires_at return None discovery \u00b6 oauth2_discovery_document_url ( issuer ) \u00b6 Given an issuer identifier, return the standardised URL where the OAuth20 server metadata can be retrieved, as specified in RFC8414. Parameters: Name Type Description Default issuer str an OAuth20 Authentication Server issuer required Returns: Type Description str the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client\\discovery.py def oauth2_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OAuth20 server metadata can be retrieved, as specified in RFC8414. :param issuer: an OAuth20 Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"oauth-authorization-server\" , at_root = True ) oidc_discovery_document_url ( issuer ) \u00b6 Given an issuer identifier, return the standardised URL where the OIDC discovery document can be retrieved, as specified in https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata Parameters: Name Type Description Default issuer str an OIDC Authentication Server issuer required Returns: Type Description str the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client\\discovery.py def oidc_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can be retrieved, as specified in https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata :param issuer: an OIDC Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"openid-configuration\" , at_root = False ) well_known_uri ( origin , name , at_root = True ) \u00b6 Returns the location of a well-known document on an origin, according to RFC8615. Parameters: Name Type Description Default origin str required name str required at_root bool if True, assume the well-known document is at root level (as defined in RFC8615). If False, assume the well-known location is per-directory, as defined by OIDC discovery. True Returns: Type Description str the well-know uri, relative to origin, where the well-known document named name should be found. Source code in requests_oauth2client\\discovery.py def well_known_uri ( origin : str , name : str , at_root : bool = True ) -> str : \"\"\" Returns the location of a well-known document on an origin, according to RFC8615. :param origin: :param name: :param at_root: if True, assume the well-known document is at root level (as defined in RFC8615). If False, assume the well-known location is per-directory, as defined by OIDC discovery. :return: the well-know uri, relative to origin, where the well-known document named `name` should be found. \"\"\" url = furl ( origin ) if at_root : url . path = Path ( \".well-known\" ) / url . path / name else : url . path . add ( Path ( \".well-known\" ) / name ) return str ( url ) exceptions \u00b6 AccessDenied \u00b6 Raised when the Authorization Server returns error = access_denied AccountSelectionRequired \u00b6 Raised when the Authorization Endpoint returns error = account_selection_required . AuthorizationPending \u00b6 Raised when the Token Endpoint returns error = authorization_pending . AuthorizationResponseError \u00b6 Base class for error responses returned by the Authorization endpoint. BackChannelAuthenticationError \u00b6 Base class for errors returned by the BackChannel Authentication endpoint. ConsentRequired \u00b6 Raised when the Authorization Endpoint returns error = consent_required . DeviceAuthorizationError \u00b6 Base class for Device Authorization Endpoint errors. EndpointError \u00b6 Base class for exceptions raised when a token endpoint returns a standardised error. ExpiredAccessToken \u00b6 Raised when an expired access token is used. ExpiredToken \u00b6 Raised when the Token Endpoint returns error = expired_token . InteractionRequired \u00b6 Raised when the Authorization Endpoint returns error = interaction_required . IntrospectionError \u00b6 Base class for Introspection Endpoint errors. InvalidAuthResponse \u00b6 Base class for errors due to Auth Responses that don't obey the standard (e.g. missing mandatory params) InvalidBackChannelAuthenticationResponse \u00b6 Raised when the BackChannel Authentication endpoint returns non-standardised errors. InvalidDeviceAuthorizationResponse \u00b6 Raised when the Device Authorization Endpoint returns a non-standard error response. InvalidGrant \u00b6 Raised when the Token Endpoint returns error = invalid_grant InvalidIdToken \u00b6 Raised when trying to validate an invalid Id Token value. InvalidScope \u00b6 Raised when the Token Endpoint returns error = invalid_scope InvalidTarget \u00b6 Raised when the Token Endpoint returns error = invalid_target InvalidTokenResponse \u00b6 Base class for exceptions raised when a token endpoint returns a non-standardised response. LoginRequired \u00b6 Raised when the Authorization Endpoint returns error = login_required . MismatchingState \u00b6 Raised when an auth response contains a state parameter that doesn't match the expected state. MissingAuthCode \u00b6 Raised when the authorization code is missing from the auth response and no error is returned. OAuth2Error \u00b6 Base class for Exceptions raised by requests_oauth2client. RevocationError \u00b6 Base class for Revocation Endpoint errors. ServerError \u00b6 Raised when the token endpoint returns error = server_error SessionSelectionRequired \u00b6 Raised when the Authorization Endpoint returns error = session_selection_required . SlowDown \u00b6 Raised when the Token Endpoint returns error = slow_down . TokenEndpointError \u00b6 Base class for errors that are specific to the token endpoint. UnauthorizedClient \u00b6 Raised when the Authorization Server returns error = unauthorized_client UnknownIntrospectionError \u00b6 Raised when the Introspection Endpoint retuns a non-standard error. UnknownTokenEndpointError \u00b6 Raised when an otherwise unknown error is returned by the token endpoint. UnsupportedTokenType \u00b6 Raised when the Revocation endpoint returns error = \"unsupported_token_type\" flask special \u00b6 auth \u00b6 FlaskOAuth2ClientCredentialsAuth \u00b6 A Requests Authentication handler that automatically gets access tokens from an OAuth20 Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask session , so that each user has a different access token. FlaskSessionAuthMixin \u00b6 A Mixin for auth handlers to store their tokens in Flask session. This way, each user of a Flask application has a different access token. jwskate \u00b6 Implements the various Json Web Crypto-related standards like JWA, JWK, JWKS, JWE, JWT. This doesn't implement any actual cryptographic operations, it just provides a set of convenient wrappers around the cryptography module. ECJwk \u00b6 kty : str \u00b6 The Key Type associated with this JWK. Jwk \u00b6 Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. subclasses : Dict [ str , Type [ requests_oauth2client . jwskate . Jwk ]] \u00b6 A dict of subclasses implementing each specific Key Type __init_subclass__ () classmethod special \u00b6 Automatically add subclasses to the registry. This allows new to pick the appropriate subclass when creating a Jwk Source code in requests_oauth2client\\jwskate.py def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk\"\"\" Jwk . subclasses [ cls . kty ] = cls __new__ ( cls , jwk ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in requests_oauth2client\\jwskate.py def __new__ ( cls , jwk : Dict [ str , Any ]): # type: ignore if cls == Jwk : if jwk . get ( \"keys\" ): # if this is a JwkSet jwks = JwkSet ( jwk ) return jwks kty : Optional [ str ] = jwk . get ( \"kty\" ) if kty is None : raise ValueError ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise ValueError ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) return super () . __new__ ( cls ) thumbprint ( self , hashalg = 'SHA256' ) \u00b6 Returns the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Source code in requests_oauth2client\\jwskate.py def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Returns the key thumbprint as specified by RFC 7638. :param hashalg: A hash function (defaults to SHA256) \"\"\" digest = hashlib . new ( hashalg ) t = { \"kty\" : self . get ( \"kty\" )} for name , ( description , private , required , kind ) in self . PARAMS . items (): if required and not private : t [ name ] = self . get ( name ) intermediary = json . dumps ( t , separators = ( \",\" , \":\" ), sort_keys = True ) digest . update ( intermediary . encode ( \"utf8\" )) return b64u_encode ( digest . digest ()) JwkSet \u00b6 A set of JWK keys, with methods for easy management of keys. JwsCompact \u00b6 Represents a a Json Web Signature (JWS), using compact serialization, as defined in RFC7515. Jwt \u00b6 __new__ ( cls , value ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in requests_oauth2client\\jwskate.py def __new__ ( cls , value : str ): # type: ignore if cls == Jwt : if value . count ( \".\" ) == 2 : return super () . __new__ ( SignedJwt ) elif value . count ( \".\" ) == 3 : return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls ) OKPJwk \u00b6 kty : str \u00b6 The Key Type associated with this JWK. RSAJwk \u00b6 kty : str \u00b6 The Key Type associated with this JWK. SignedJwt \u00b6 Represents a Signed Json Web Token (JWT), as defined in RFC7519. SymetricJwk \u00b6 kty : str \u00b6 The Key Type associated with this JWK. pooling \u00b6 TokenEndpointPoolingJob \u00b6 Base class for Token Endpoint pooling jobs on decoupled flows like CIBA or Device Authorization. tokens \u00b6 BearerToken \u00b6 A wrapper around a Bearer Token and associated expiration date and refresh token, as returned by an OAuth20 or OIDC Token Endpoint. __contains__ ( self , key ) special \u00b6 Check existence of a key in the token response. Allows testing like assert \"refresh_token\" in token_response . Parameters: Name Type Description Default key str a key required Returns: Type Description bool True if the key exists in the token response, False otherwise Source code in requests_oauth2client\\tokens.py def __contains__ ( self , key : str ) -> bool : \"\"\" Check existence of a key in the token response. Allows testing like `assert \"refresh_token\" in token_response`. :param key: a key :return: True if the key exists in the token response, False otherwise \"\"\" if key == \"access_token\" : return True elif key == \"refresh_token\" : return self . refresh_token is not None elif key == \"scope\" : return self . scope is not None elif key == \"token_type\" : return True elif key == \"expires_in\" : return self . expires_at is not None else : return key in self . other __getattr__ ( self , key ) special \u00b6 Returns items from this Token Response. Allows token_response.expires_in or token_response.any_custom_attribute Parameters: Name Type Description Default key str a key required Returns: Type Description Any the associated value in this token response Source code in requests_oauth2client\\tokens.py def __getattr__ ( self , key : str ) -> Any : \"\"\" Returns items from this Token Response. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises: \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) elif key == \"token_type\" : return \"Bearer\" return self . other . get ( key ) or super () . __getattribute__ ( key ) __str__ ( self ) special \u00b6 Returns the access token value, as a string Returns: Type Description str the access token string Source code in requests_oauth2client\\tokens.py def __str__ ( self ) -> str : \"\"\" Returns the access token value, as a string :return: the access token string \"\"\" return self . access_token authorization_header ( self ) \u00b6 Returns the Authorization Header value containing this access token, correctly formatted as per RFC6750. Returns: Type Description str the value to use in a HTTP Authorization Header Source code in requests_oauth2client\\tokens.py def authorization_header ( self ) -> str : \"\"\" Returns the Authorization Header value containing this access token, correctly formatted as per RFC6750. :return: the value to use in a HTTP Authorization Header \"\"\" return f \"Bearer { self . access_token } \" is_expired ( self ) \u00b6 Returns True if the access token is expired at the time of the call. Returns: Type Description Optional[bool] True if the access token is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client\\tokens.py def is_expired ( self ) -> Optional [ bool ]: \"\"\" Returns True if the access token is expired at the time of the call. :return: True if the access token is expired, False if it is still valid, None if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () > self . expires_at return None BearerTokenSerializer \u00b6 default_dumper ( token ) staticmethod \u00b6 Serializes as JSON, encodes as base64url of zlib compression of JSON representation of the Access Token, with expiration date represented as expires_at. Parameters: Name Type Description Default token BearerToken the :class: BearerToken to serialize required Returns: Type Description str the serialized value Source code in requests_oauth2client\\tokens.py @staticmethod def default_dumper ( token : BearerToken ) -> str : \"\"\" Serializes as JSON, encodes as base64url of zlib compression of JSON representation of the Access Token, with expiration date represented as expires_at. :param token: the :class:`BearerToken` to serialize :return: the serialized value \"\"\" return b64u_encode ( zlib . compress ( json . dumps ( token . as_dict ( True ), default = lambda d : d . timestamp () ) . encode () ) ) default_loader ( self , serialized , token_class =< class ' requests_oauth2client . tokens . BearerToken '>) \u00b6 Default deserializer for tokens. Parameters: Name Type Description Default serialized str the serialized token required Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\tokens.py def default_loader ( self , serialized : str , token_class : Type [ BearerToken ] = BearerToken ) -> BearerToken : \"\"\" Default deserializer for tokens. :param serialized: the serialized token :return: a BearerToken \"\"\" attrs = json . loads ( zlib . decompress ( b64u_decode ( serialized ))) expires_at = attrs . get ( \"expires_at\" ) if expires_at : attrs [ \"expires_at\" ] = datetime . fromtimestamp ( expires_at ) return token_class ( ** attrs ) dumps ( self , token ) \u00b6 Serialize and compress a given token for easier storage Parameters: Name Type Description Default token BearerToken a BearerToken to serialize required Returns: Type Description str the serialized token, as a str Source code in requests_oauth2client\\tokens.py def dumps ( self , token : BearerToken ) -> str : \"\"\" Serialize and compress a given token for easier storage :param token: a BearerToken to serialize :return: the serialized token, as a str \"\"\" return self . dumper ( token ) loads ( self , serialized ) \u00b6 Deserialize a serialized token Parameters: Name Type Description Default serialized str the serialized token required Returns: Type Description BearerToken the deserialized token Source code in requests_oauth2client\\tokens.py def loads ( self , serialized : str ) -> BearerToken : \"\"\" Deserialize a serialized token :param serialized: the serialized token :return: the deserialized token \"\"\" return self . loader ( serialized ) utils \u00b6 b64_decode ( data ) \u00b6 Decodes a base64-encoded string or bytes. Parameters: Name Type Description Default data Union[str, bytes] required encoding required Returns: Type Description bytes Source code in requests_oauth2client\\utils.py def b64_decode ( data : Union [ str , bytes ]) -> bytes : \"\"\" Decodes a base64-encoded string or bytes. :param data: :param encoding: :return: \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( \"ascii\" ) padding_len = len ( data ) % 4 if padding_len : data = data + b \"=\" * padding_len decoded = base64 . urlsafe_b64decode ( data ) return decoded b64_encode ( data , encoding = 'utf-8' , padded = True ) \u00b6 Encodes the string or bytes data using base64. If data is a string, encode it to string using encoding before converting it to base64. If padded is True (default), outputs includes a padding with = to make its length a multiple of 4. If False, no padding is included. Parameters: Name Type Description Default data Union[bytes, str] a str or bytes to base64-encode. required encoding str if data is a str, use this encoding to convert it to bytes first. 'utf-8' padded bool whether to include padding in the output True Returns: Type Description str a str with the base64-encoded data. Source code in requests_oauth2client\\utils.py def b64_encode ( data : Union [ bytes , str ], encoding : str = \"utf-8\" , padded : bool = True ) -> str : \"\"\" Encodes the string or bytes `data` using base64. If data is a string, encode it to string using `encoding` before converting it to base64. If padded is True (default), outputs includes a padding with = to make its length a multiple of 4. If False, no padding is included. :param data: a str or bytes to base64-encode. :param encoding: if data is a str, use this encoding to convert it to bytes first. :param padded: whether to include padding in the output :return: a str with the base64-encoded data. \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( encoding ) encoded = base64 . b64encode ( data ) if not padded : encoded = encoded . rstrip ( b \"=\" ) return encoded . decode ( \"ascii\" ) b64u_decode ( data ) \u00b6 Decodes a base64encoded string or bytes. Parameters: Name Type Description Default data Union[str, bytes] the data to decode. Can be bytes or str required encoding the encoding to use when converting the decoded data to str. If None, no decoding will be done and data will be decoded as bytes. required Returns: Type Description bytes the decoded data as a string, or bytes if encoding is None. Source code in requests_oauth2client\\utils.py def b64u_decode ( data : Union [ str , bytes ], ) -> bytes : \"\"\" Decodes a base64encoded string or bytes. :param data: the data to decode. Can be bytes or str :param encoding: the encoding to use when converting the decoded data to str. If None, no decoding will be done and data will be decoded as bytes. :return: the decoded data as a string, or bytes if `encoding` is None. \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( \"ascii\" ) padding_len = len ( data ) % 4 if padding_len : data = data + b \"=\" * padding_len decoded = base64 . urlsafe_b64decode ( data ) return decoded b64u_encode ( data , encoding = 'utf-8' , padded = False ) \u00b6 Encodes some data in Base64url. Parameters: Name Type Description Default data Union[bytes, str] the data to encode. Can be bytes or str. required encoding str if data is a string, the encoding to use to convert it as bytes 'utf-8' padded bool if True, pad the output with = to make its length a multiple of 4 False Returns: Type Description str the base64url encoded data, as a string Source code in requests_oauth2client\\utils.py def b64u_encode ( data : Union [ bytes , str ], encoding : str = \"utf-8\" , padded : bool = False ) -> str : \"\"\" Encodes some data in Base64url. :param data: the data to encode. Can be bytes or str. :param encoding: if data is a string, the encoding to use to convert it as bytes :param padded: if True, pad the output with = to make its length a multiple of 4 :return: the base64url encoded data, as a string \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( encoding ) encoded = base64 . urlsafe_b64encode ( data ) if not padded : encoded = encoded . rstrip ( b \"=\" ) return encoded . decode ( \"ascii\" )","title":"API"},{"location":"api/#requests_oauth2client.api_client","text":"","title":"api_client"},{"location":"api/#requests_oauth2client.api_client.ApiClient","text":"A Wrapper around :class: requests.Session to simplify Rest API calls. This allows setting a root url at creation time, then passing relative urls at request time. It may also raise exceptions instead of returning error responses. Basic usage: 1 2 3 from requests_oauth2client import ApiClient api = ApiClient(\"https://myapi.local/resource\") resp = api.get(\"/myid\") # this will send a GET request to https://myapi.local/resource/myid","title":"ApiClient"},{"location":"api/#requests_oauth2client.api_client.ApiClient.__init__","text":"Parameters: Name Type Description Default url Optional[str] the base api url. This url will serve as root for relative urls passed to :method: ApiClient.request() , :method: ApiClient.get() , etc. None auth Optional[requests.auth.AuthBase] the :class: requests.auth.AuthBase to use as authentication handler. None raise_for_status bool if True , exceptions will be raised everytime a request returns an error code (>= 400). This parameter may be overridden at request time. True Source code in requests_oauth2client\\api_client.py def __init__ ( self , url : Optional [ str ] = None , auth : Optional [ requests . auth . AuthBase ] = None , raise_for_status : bool = True , ): \"\"\" :param url: the base api url. This url will serve as root for relative urls passed to :method:`ApiClient.request()`, :method:`ApiClient.get()`, etc. :param auth: the :class:`requests.auth.AuthBase` to use as authentication handler. :param raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (>= 400). This parameter may be overridden at request time. \"\"\" super ( ApiClient , self ) . __init__ () self . url = url self . auth = auth self . raise_for_status = raise_for_status","title":"__init__()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.delete","text":"Sends a DELETE request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def delete ( # type: ignore self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Sends a DELETE request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"DELETE\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"delete()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.get","text":"Sends a GET request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def get ( # type: ignore self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any , ) -> requests . Response : \"\"\" Sends a GET request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raise_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"GET\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"get()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.patch","text":"Sends a PATCH request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def patch ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any ) -> requests . Response : # type: ignore \"\"\" Sends a PATCH request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PATCH\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"patch()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.post","text":"Sends a POST request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def post ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any ) -> requests . Response : # type: ignore \"\"\" Sends a POST request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"POST\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"post()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.put","text":"Sends a PUT request. Returns :class: Response object. The passed url may be relative to the url passed at initialization time. Parameters: Name Type Description Default url Union[str, bytes, Iterable[Union[str, bytes]]] a url where the request will be sent. None raise_for_status Optional[bool] overrides the raises_for_status parameter passed at initialization time. None kwargs Any Optional arguments that request takes. {} Returns: Type Description Response a :class: requests.Response object. Source code in requests_oauth2client\\api_client.py def put ( self , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , raise_for_status : Optional [ bool ] = None , ** kwargs : Any ) -> requests . Response : # type: ignore \"\"\" Sends a PUT request. Returns :class:`Response` object. The passed `url` may be relative to the url passed at initialization time. :param url: a url where the request will be sent. :param raise_for_status: overrides the `raises_for_status` parameter passed at initialization time. :param kwargs: Optional arguments that ``request`` takes. :return: a :class:`requests.Response` object. :raises: a :class:`requests.HTTPError` if `raises_for_status` is True (in this request or at initialization time) and an error response is returned. \"\"\" return self . request ( \"PUT\" , url , raise_for_status = raise_for_status , ** kwargs )","title":"put()"},{"location":"api/#requests_oauth2client.api_client.ApiClient.request","text":"A customized request method to handle a path instead of a full url. Parameters: Name Type Description Default method str the HTTP method to use required url Union[str, bytes, Iterable[Union[str, bytes]]] the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. None Returns: Type Description Response a :class: requests.Response as returned by requests Source code in requests_oauth2client\\api_client.py def request ( # type: ignore self , method : str , url : Optional [ Union [ str , bytes , Iterable [ Union [ str , bytes ]]]] = None , params : Union [ None , bytes , MutableMapping [ str , str ]] = None , data : Union [ None , str , bytes , MutableMapping [ str , Any ], Iterable [ Tuple [ str , Optional [ str ]]], IO [ Any ], ] = None , headers : Optional [ MutableMapping [ str , str ]] = None , cookies : Union [ None , RequestsCookieJar , MutableMapping [ str , str ]] = None , files : Optional [ MutableMapping [ str , IO [ Any ]]] = None , auth : Union [ None , Tuple [ str , str ], requests . auth . AuthBase , Callable [[ requests . PreparedRequest ], requests . PreparedRequest ], ] = None , timeout : Union [ None , float , Tuple [ float , float ], Tuple [ float , None ]] = None , allow_redirects : Optional [ bool ] = True , proxies : Optional [ MutableMapping [ str , str ]] = None , hooks : Optional [ MutableMapping [ str , Union [ Iterable [ Callable [[ requests . Response ], Any ]], Callable [[ requests . Response ], Any ], ], ] ] = None , stream : Optional [ bool ] = None , verify : Optional [ Union [ str , bool ]] = None , cert : Optional [ Union [ str , Tuple [ str , str ]]] = None , json : Optional [ Mapping [ str , Any ]] = None , raise_for_status : Optional [ bool ] = None , ) -> requests . Response : \"\"\" A customized request method to handle a path instead of a full url. :param method: the HTTP method to use :param url: the url where the request will be sent to. Can be a path instead of a full url; that path will be joined to the configured API url. :return: a :class:`requests.Response` as returned by requests \"\"\" if self . url : if url is not None : if not isinstance ( url , ( str , bytes )): try : url = \"/\" . join ( [ part . decode () if isinstance ( part , bytes ) else str ( part ) for part in url if part ] ) except TypeError : raise TypeError ( \"Unexpected url type, please pass a relative path as string or bytes, \" \"or an iterable of string-able objects\" , type ( url ), ) if isinstance ( url , bytes ): url = url . decode () url = urljoin ( self . url + \"/\" , url . lstrip ( \"/\" )) else : url = self . url if url is None or not isinstance ( url , str ): raise ValueError ( \"No url to send the request to\" ) response = super ( ApiClient , self ) . request ( method , url , params = params , data = data , headers = headers , cookies = cookies , files = files , auth = auth , timeout = timeout , allow_redirects = allow_redirects , proxies = proxies , hooks = hooks , stream = stream , verify = verify , cert = cert , json = json , ) if raise_for_status is None : raise_for_status = self . raise_for_status if raise_for_status : response . raise_for_status () return response","title":"request()"},{"location":"api/#requests_oauth2client.auth","text":"","title":"auth"},{"location":"api/#requests_oauth2client.auth.BearerAuth","text":"A Requests compatible Authentication helper for API protected with Bearer tokens. Using this AuthBase, you have to obtain an access token manually.","title":"BearerAuth"},{"location":"api/#requests_oauth2client.auth.BearerAuth.token","text":"The token that is used for authorization against the API. Returns: Type Description Optional[requests_oauth2client.tokens.BearerToken]","title":"token"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth","text":"A Requests Authentication handler using a Bearer access token, and can automatically refreshes it when expired.","title":"OAuth2AccessTokenAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.__call__","text":"Adds the Parameters: Name Type Description Default request PreparedRequest required Returns: Type Description PreparedRequest Source code in requests_oauth2client\\auth.py def __call__ ( self , request : requests . PreparedRequest ) -> requests . PreparedRequest : \"\"\" Adds the :param request: :return: \"\"\" token = self . token if ( token is not None and token . is_expired () and token . refresh_token and self . client is not None ): self . token = self . client . refresh_token ( refresh_token = token . refresh_token , ** self . token_kwargs ) return super () . __call__ ( request )","title":"__call__()"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.__init__","text":"Initializes an Authorization handler (RFC6750), with an (optional) initial token. Parameters: Name Type Description Default client OAuth2Client an OAuth2Client configured to talk to the token endpoint. required token Union[str, requests_oauth2client.tokens.BearerToken] a BearerToken that has been retrieved from the token endpoint manually None token_kwargs Any additional kwargs to pass to the token endpoint {} Source code in requests_oauth2client\\auth.py def __init__ ( self , client : \"OAuth2Client\" , token : Optional [ Union [ str , BearerToken ]] = None , ** token_kwargs : Any , ) -> None : \"\"\" Initializes an Authorization handler (RFC6750), with an (optional) initial token. :param client: an `OAuth2Client` configured to talk to the token endpoint. :param token: a BearerToken that has been retrieved from the token endpoint manually :param token_kwargs: additional kwargs to pass to the token endpoint \"\"\" super () . __init__ ( token ) self . client = client self . token_kwargs = token_kwargs","title":"__init__()"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth","text":"A Requests Auth handler that exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.","title":"OAuth2AuthorizationCodeAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth","text":"A Requests Authentication handler that automatically gets access tokens from an OAuth20 Token Endpoint with the Client Credentials grant (and can get a new one once it is expired).","title":"OAuth2ClientCredentialsAuth"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth","text":"A Requests Auth handler that exchanges a Device Code for an access token, then automatically refreshes it once it is expired.","title":"OAuth2DeviceCodeAuth"},{"location":"api/#requests_oauth2client.authorization_request","text":"","title":"authorization_request"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest","text":"Represents an Authorization Request. It generates a valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), stores all parameters, and may validate that the callback authorization response matches the state.","title":"AuthorizationRequest"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.default_exception_class","text":"Base class for error responses returned by the Authorization endpoint.","title":"default_exception_class"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.__init__","text":"Creates an AuthorizationRequest. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: state: if True (default), a random state parameter will be generated for you. You may pass your own state as str, or set it to None so that the state parameter will not be included in the request. You may access that state in the state attribute from this request. nonce: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the nonce attribute from this request. code_verifier: if None, and code_challenge_method is 'S256' or 'plain', a valid code_challenge and code_verifier for PKCE will be automatically generated, and the code_challenge will be included in the request. You may pass your own code_verifier as a str parameter, in which case the appropriate code_challenge will be included in the request. Parameters: Name Type Description Default authorization_endpoint str the uri for the authorization endpoint required client_id str the client_id to include in the request required redirect_uri str the redirect_uri to include in the request required scope Union[str, Iterable[str]] the scope to include in the request, as an iterable of string, or a space-separated str required response_type str the response type to include in the request. 'code' state Union[str, bool] the state to include in the request, or True to autogenerate one (default). True nonce Union[str, bool] the nonce to include in the request, or True to autogenerate one (default). True code_verifier Optional[str] the state to include in the request, or True to autogenerate one (default). None code_challenge_method Optional[str] the method to use to derive the code_challenge from the code_verifier. 'S256' kwargs Any extra parameters to include in the request, as-is. {} Source code in requests_oauth2client\\authorization_request.py def __init__ ( self , authorization_endpoint : str , client_id : str , redirect_uri : str , scope : Union [ str , Iterable [ str ]], response_type : str = \"code\" , state : Union [ str , bool , None ] = True , nonce : Union [ str , bool , None ] = True , code_verifier : Optional [ str ] = None , code_challenge_method : Optional [ str ] = \"S256\" , ** kwargs : Any , ) -> None : \"\"\" Creates an AuthorizationRequest. All parameters passed here will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour: * state: if True (default), a random state parameter will be generated for you. You may pass your own state as str, or set it to `None` so that the state parameter will not be included in the request. You may access that state in the `state` attribute from this request. * nonce: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request. You may access that nonce in the `nonce` attribute from this request. * code_verifier: if None, and `code_challenge_method` is 'S256' or 'plain', a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated, and the code_challenge will be included in the request. You may pass your own code_verifier as a str parameter, in which case the appropriate `code_challenge` will be included in the request. :param authorization_endpoint: the uri for the authorization endpoint :param client_id: the client_id to include in the request :param redirect_uri: the redirect_uri to include in the request :param scope: the scope to include in the request, as an iterable of string, or a space-separated str :param response_type: the response type to include in the request. :param state: the state to include in the request, or True to autogenerate one (default). :param nonce: the nonce to include in the request, or True to autogenerate one (default). :param code_verifier: the state to include in the request, or True to autogenerate one (default). :param code_challenge_method: the method to use to derive the code_challenge from the code_verifier. :param kwargs: extra parameters to include in the request, as-is. \"\"\" if state is True : state = secrets . token_urlsafe ( 32 ) elif state is False : state = None if scope is not None and isinstance ( scope , str ): scope = scope . split ( \" \" ) if nonce is True and scope is not None and \"openid\" in scope : nonce = secrets . token_urlsafe ( 32 ) elif nonce is False : nonce = None if scope is not None and not isinstance ( scope , str ): scope = \" \" . join ( str ( s ) for s in scope ) if \"code_challenge\" in kwargs : raise ValueError ( \"A code_challenge must not be passed as parameter. \" \"Pass the code_verifier instead, and the appropriate code_challenge \" \"will automatically be derived from it and included in the request, \" \"based on code_challenge_method.\" ) if not code_challenge_method : code_verifier = code_challenge = code_challenge_method = None else : if not code_verifier : code_verifier = PkceUtils . generate_code_verifier () code_challenge = PkceUtils . derive_challenge ( code_verifier , code_challenge_method ) self . authorization_endpoint = authorization_endpoint self . client_id = client_id self . redirect_uri = redirect_uri self . response_type = response_type self . scope = scope self . state = state self . nonce = nonce self . code_verifier = code_verifier self . code_challenge = code_challenge self . code_challenge_method = code_challenge_method self . kwargs = kwargs self . args = dict ( client_id = client_id , redirect_uri = redirect_uri , response_type = response_type , scope = scope , state = state , nonce = nonce , code_challenge = code_challenge , code_challenge_method = code_challenge_method , ** kwargs , )","title":"__init__()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils","text":"Contains helper methods for PKCE, as described in RFC7636 .","title":"PkceUtils"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.derive_challenge","text":"Derives the code_challenge from a given code_verifier . Parameters: Name Type Description Default verifier Union[str, bytes] a code verifier required method str the method to use for deriving the challenge. Accepts 'S256' or 'plain'. 'S256' Returns: Type Description str a code_challenge derived from the given verifier Source code in requests_oauth2client\\authorization_request.py @classmethod def derive_challenge ( cls , verifier : Union [ str , bytes ], method : str = \"S256\" ) -> str : \"\"\" Derives the `code_challenge` from a given `code_verifier`. :param verifier: a code verifier :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a code_challenge derived from the given verifier \"\"\" if isinstance ( verifier , bytes ): verifier = verifier . decode () if not cls . code_verifier_re . match ( verifier ): raise ValueError ( f \"Invalid code verifier, does not match { cls . code_verifier_re } \" , verifier , ) if method == \"S256\" : return b64u_encode ( hashlib . sha256 ( verifier . encode ()) . digest ()) elif method == \"plain\" : return verifier else : raise ValueError ( \"Unsupported code_challenge_method\" , method )","title":"derive_challenge()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier","text":"Generates a valid code_verifier . Returns: Type Description str a code_verifier ready to use for PKCE Source code in requests_oauth2client\\authorization_request.py @classmethod def generate_code_verifier ( cls ) -> str : \"\"\" Generates a valid `code_verifier`. :return: a code_verifier ready to use for PKCE \"\"\" return secrets . token_urlsafe ( 96 )","title":"generate_code_verifier()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier_and_challenge","text":"Generate a valid code_verifier and derives its code_challenge . Parameters: Name Type Description Default method str the method to use for deriving the challenge. Accepts 'S256' or 'plain'. 'S256' Returns: Type Description Tuple[str, str] a (code_verifier, code_challenge) tuple. Source code in requests_oauth2client\\authorization_request.py @classmethod def generate_code_verifier_and_challenge ( cls , method : str = \"S256\" ) -> Tuple [ str , str ]: \"\"\" Generate a valid `code_verifier` and derives its `code_challenge`. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: a (code_verifier, code_challenge) tuple. \"\"\" verifier = cls . generate_code_verifier () challenge = cls . derive_challenge ( verifier , method ) return verifier , challenge","title":"generate_code_verifier_and_challenge()"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.validate_code_verifier","text":"Validates a code_verifier against a code_challenge . Parameters: Name Type Description Default verifier str the code_verifier , exactly as submitted by the client on token request. required challenge str the code_challenge , exactly as submitted by the client on authorization request. required method str the method to use for deriving the challenge. Accepts 'S256' or 'plain'. 'S256' Returns: Type Description bool True if verifier is valid, or False otherwise Source code in requests_oauth2client\\authorization_request.py @classmethod def validate_code_verifier ( cls , verifier : str , challenge : str , method : str = \"S256\" ) -> bool : \"\"\" Validates a `code_verifier` against a `code_challenge`. :param verifier: the `code_verifier`, exactly as submitted by the client on token request. :param challenge: the `code_challenge`, exactly as submitted by the client on authorization request. :param method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'. :return: True if verifier is valid, or False otherwise \"\"\" return ( cls . code_verifier_re . match ( verifier ) is not None and cls . derive_challenge ( verifier , method ) == challenge )","title":"validate_code_verifier()"},{"location":"api/#requests_oauth2client.backchannel_authentication","text":"","title":"backchannel_authentication"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob","text":"A pooling job for checking if the user has finished with his authorization in a Device Authorization flow.","title":"BackChannelAuthenticationPoolingJob"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse","text":"","title":"BackChannelAuthenticationResponse"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.__getattr__","text":"Returns items from this Token Response. Allows token_response.expires_in or token_response.any_custom_attribute Parameters: Name Type Description Default key str a key required Returns: Type Description Any the associated value in this token response Source code in requests_oauth2client\\backchannel_authentication.py def __getattr__ ( self , key : str ) -> Any : \"\"\" Returns items from this Token Response. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises: \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) return self . other . get ( key ) or super () . __getattribute__ ( key )","title":"__getattr__()"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.is_expired","text":"Returns True if the auth_req_id within this response is expired at the time of the call. Returns: Type Description Optional[bool] True if the auth_req_id is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client\\backchannel_authentication.py def is_expired ( self ) -> Optional [ bool ]: \"\"\" Returns True if the auth_req_id within this response is expired at the time of the call. :return: True if the auth_req_id is expired, False if it is still valid, None if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () > self . expires_at return None","title":"is_expired()"},{"location":"api/#requests_oauth2client.client","text":"","title":"client"},{"location":"api/#requests_oauth2client.client.OAuth2Client","text":"An OAuth 2.0 client, able to obtain tokens from the Token Endpoint using one of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint. This class doesn't implement anything related to the end-user authentication or any request that goes in a browser. For authentication requests, see :class AuthorizationRequest .","title":"OAuth2Client"},{"location":"api/#requests_oauth2client.client.OAuth2Client.__init__","text":"Parameters: Name Type Description Default token_endpoint str the token endpoint where this client will get access tokens required auth Union[requests.auth.AuthBase, Tuple[str, str], str] the authentication handler to use for client authentication on the token endpoint. Can be a requests.auth.AuthBase instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize an instance of default_auth_handler , or a client_id which will use PublicApp authentication. required revocation_endpoint Optional[str] the revocation endpoint url to use for revoking tokens, if any None introspection_endpoint Optional[str] the introspection endpoint url to get info about tokens, if any None session Optional[requests.sessions.Session] a requests Session to use when sending HTTP requests None Source code in requests_oauth2client\\client.py def __init__ ( self , token_endpoint : str , auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], revocation_endpoint : Optional [ str ] = None , introspection_endpoint : Optional [ str ] = None , userinfo_endpoint : Optional [ str ] = None , backchannel_authentication_endpoint : Optional [ str ] = None , device_authorization_endpoint : Optional [ str ] = None , jwks_uri : Optional [ str ] = None , session : Optional [ requests . Session ] = None , ): \"\"\" :param token_endpoint: the token endpoint where this client will get access tokens :param auth: the authentication handler to use for client authentication on the token endpoint. Can be a `requests.auth.AuthBase` instance (which will be used directly), or a tuple of (client_id, client_secret) which will initialize an instance of `default_auth_handler`, or a client_id which will use PublicApp authentication. :param revocation_endpoint: the revocation endpoint url to use for revoking tokens, if any :param introspection_endpoint: the introspection endpoint url to get info about tokens, if any :param session: a requests Session to use when sending HTTP requests \"\"\" self . token_endpoint = str ( token_endpoint ) self . revocation_endpoint = ( str ( revocation_endpoint ) if revocation_endpoint else None ) self . introspection_endpoint = ( str ( introspection_endpoint ) if introspection_endpoint else None ) self . userinfo_endpoint = str ( userinfo_endpoint ) if userinfo_endpoint else None self . backchannel_authentication_endpoint = ( str ( backchannel_authentication_endpoint ) if backchannel_authentication_endpoint else None ) self . device_authorization_endpoint = ( str ( device_authorization_endpoint ) if device_authorization_endpoint else None ) self . jwks_uri = str ( jwks_uri ) if jwks_uri else None self . session = session or requests . Session () self . auth = client_auth_factory ( auth , ClientSecretPost )","title":"__init__()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code","text":"Sends a request to the token endpoint with the authorization_code grant. Parameters: Name Type Description Default code str an authorization code to exchange for tokens required token_kwargs Any additional parameters for the token endpoint, alongside grant_type, code, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a TokenResponse Source code in requests_oauth2client\\client.py def authorization_code ( self , code : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the authorization_code grant. :param code: an authorization code to exchange for tokens :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, code, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"authorization_code\" , code = code , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs )","title":"authorization_code()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code_pkce","text":"Sends a request to the token endpoint with the authorization_code grant, and This is just an alias to authorization_code() with code_verifier as mandatory parameter. Parameters: Name Type Description Default code str an authorization code to exchange for tokens required code_verifier str the code verifier that matches the authorization code required token_kwargs Any additional parameters for the token endpoint, alongside grant_type, code, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\client.py def authorization_code_pkce ( self , code : str , code_verifier : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the authorization_code grant, and This is just an alias to `authorization_code()` with code_verifier as mandatory parameter. :param code: an authorization code to exchange for tokens :param code_verifier: the code verifier that matches the authorization code :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, code, etc. :param requests_kwargs: additional parameters for the call to requests :return: a BearerToken \"\"\" return self . authorization_code ( code = code , code_verifier = code_verifier , requests_kwargs = requests_kwargs , ** token_kwargs , )","title":"authorization_code_pkce()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorize_device","text":"Sends a Device Authorization Request. Parameters: Name Type Description Default data Any additional data to send to the Device Authorization Endpoint {} Returns: Type Description DeviceAuthorizationResponse a Device Authorization Response Source code in requests_oauth2client\\client.py def authorize_device ( self , ** data : Any ) -> DeviceAuthorizationResponse : \"\"\" Sends a Device Authorization Request. :param data: additional data to send to the Device Authorization Endpoint :return: a Device Authorization Response \"\"\" if self . device_authorization_endpoint is None : raise AttributeError ( \"No device authorization endpoint defined for this client\" ) response = self . session . post ( self . device_authorization_endpoint , data = data , auth = self . auth ) if response . ok : return self . parse_device_authorization_response ( response ) return self . on_device_authorization_error ( response )","title":"authorize_device()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.backchannel_authentication_request","text":"Sends a CIBA Authentication Request. Returns: Type Description BackChannelAuthenticationResponse a BackChannelAuthenticationResponse Source code in requests_oauth2client\\client.py def backchannel_authentication_request ( self , scope : Union [ str , Iterable [ str ]], client_notification_token : Optional [ str ] = None , acr_values : Optional [ str ] = None , login_hint_token : Optional [ str ] = None , id_token_hint : Optional [ str ] = None , login_hint : Optional [ str ] = None , binding_message : Optional [ str ] = None , user_code : Optional [ str ] = None , requested_expiry : Optional [ int ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , private_jwk : Union [ Jwk , Dict [ str , Any ], None ] = None , alg : Optional [ str ] = None , ** ciba_kwargs : Any , ) -> BackChannelAuthenticationResponse : \"\"\" Sends a CIBA Authentication Request. :return: a BackChannelAuthenticationResponse \"\"\" if not self . backchannel_authentication_endpoint : raise AttributeError ( \"No backchannel authentication endpoint defined for this client\" ) requests_kwargs = requests_kwargs or {} if not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc if not ( login_hint or login_hint_token or id_token_hint ): raise ValueError ( \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) if ( ( login_hint_token and id_token_hint ) or ( login_hint and id_token_hint ) or ( login_hint_token and login_hint ) ): raise ValueError ( \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\" ) data = dict ( ciba_kwargs , scope = scope , client_notification_token = client_notification_token , acr_values = acr_values , login_hint_token = login_hint_token , id_token_hint = id_token_hint , login_hint = login_hint , binding_message = binding_message , user_code = user_code , requested_expiry = requested_expiry , ) if private_jwk is not None : data = { \"request\" : str ( Jwt . sign ( data , jwk = private_jwk , alg = alg ))} response = self . session . post ( self . backchannel_authentication_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return self . parse_backchannel_authentication_response ( response ) return self . on_backchannel_authentication_error ( response )","title":"backchannel_authentication_request()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_credentials","text":"Sends a request to the token endpoint with the client_credentials grant. Parameters: Name Type Description Default scope Union[str, Iterable[str]] the scope to send with the request. Can be a str, or an iterable of str. None token_kwargs Any additional parameters for the token endpoint, alongside grant_type. Common parameters to pass that way include scope, audience, resource, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a TokenResponse Source code in requests_oauth2client\\client.py def client_credentials ( self , requests_kwargs : Optional [ Dict [ str , Any ]] = None , scope : Optional [ Union [ str , Iterable [ str ]]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the client_credentials grant. :param scope: the scope to send with the request. Can be a str, or an iterable of str. :param token_kwargs: additional parameters for the token endpoint, alongside grant_type. Common parameters to pass that way include scope, audience, resource, etc. :param requests_kwargs: additional parameters for the call to requests :return: a TokenResponse \"\"\" requests_kwargs = requests_kwargs or {} if scope is not None and not isinstance ( scope , str ): try : scope = \" \" . join ( scope ) except Exception as exc : raise ValueError ( \"Unsupported scope value\" ) from exc data = dict ( grant_type = \"client_credentials\" , scope = scope , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs )","title":"client_credentials()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.device_code","text":"Sends a request to the token endpoint with the urn:ietf:params:oauth:grant-type:device_code grant. Parameters: Name Type Description Default device_code str a device code as received during the device authorization request required requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None token_kwargs Any additional parameters for the token endpoint, alongside grant_type, device_code, etc. {} Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\client.py def device_code ( self , device_code : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the urn:ietf:params:oauth:grant-type:device_code grant. :param device_code: a device code as received during the device authorization request :param requests_kwargs: additional parameters for the call to requests :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, device_code, etc. :return: a BearerToken \"\"\" requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:device_code\" , device_code = device_code , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs )","title":"device_code()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_document","text":"Initialise an OAuth2Client, based on the server metadata from discovery . Parameters: Name Type Description Default discovery Dict[str, Any] a dict of server metadata, in the same format as retrieved from a discovery endpoint. required issuer Optional[str] if an issuer is given, check that it matches the one mentioned in the document required auth Union[requests.auth.AuthBase, Tuple[str, str], str] the authentication handler to use for client authentication required session Optional[requests.sessions.Session] a requests Session to use to retrieve the document and initialise the client with None https bool if True, validates that urls in the discovery document use the https scheme True Returns: Type Description OAuth2Client an OAuth2Client Source code in requests_oauth2client\\client.py @classmethod def from_discovery_document ( cls , discovery : Dict [ str , Any ], issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , https : bool = True , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, based on the server metadata from `discovery`. :param discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint. :param issuer: if an issuer is given, check that it matches the one mentioned in the document :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param https: if True, validates that urls in the discovery document use the https scheme :return: an OAuth2Client \"\"\" if issuer : # pragma: no branch issuer_from_doc = discovery . get ( \"issuer\" ) if issuer_from_doc != issuer : raise ValueError ( \"issuer mismatch!\" , issuer_from_doc ) token_endpoint = discovery . get ( \"token_endpoint\" ) if token_endpoint is None : raise ValueError ( \"token_endpoint not found in that discovery document\" ) validate_uri ( token_endpoint , https = https ) revocation_endpoint = discovery . get ( \"revocation_endpoint\" ) if revocation_endpoint is not None : validate_uri ( revocation_endpoint , https = https ) introspection_endpoint = discovery . get ( \"introspection_endpoint\" ) if introspection_endpoint is not None : validate_uri ( introspection_endpoint , https = https ) userinfo_endpoint = discovery . get ( \"userinfo_endpoint\" ) if userinfo_endpoint is not None : validate_uri ( userinfo_endpoint , https = https ) jwks_uri = discovery . get ( \"jwks_uri\" ) if jwks_uri is not None : validate_uri ( userinfo_endpoint , https = https ) return cls ( token_endpoint = token_endpoint , revocation_endpoint = revocation_endpoint , introspection_endpoint = introspection_endpoint , userinfo_endpoint = userinfo_endpoint , jwks_uri = jwks_uri , auth = auth , session = session , )","title":"from_discovery_document()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_endpoint","text":"Initialise an OAuth2Client, retrieving server metadata from a discovery document. Parameters: Name Type Description Default url str the url where the server metadata will be retrieved required auth Union[requests.auth.AuthBase, Tuple[str, str], str] the authentication handler to use for client authentication required session Optional[requests.sessions.Session] a requests Session to use to retrieve the document and initialise the client with None issuer Optional[str] if an issuer is given, check that it matches the one from the retrieved document required Returns: Type Description OAuth2Client a OAuth2Client Source code in requests_oauth2client\\client.py @classmethod def from_discovery_endpoint ( cls , url : str , issuer : Optional [ str ], auth : Union [ requests . auth . AuthBase , Tuple [ str , str ], str ], session : Optional [ requests . Session ] = None , ) -> \"OAuth2Client\" : \"\"\" Initialise an OAuth2Client, retrieving server metadata from a discovery document. :param url: the url where the server metadata will be retrieved :param auth: the authentication handler to use for client authentication :param session: a requests Session to use to retrieve the document and initialise the client with :param issuer: if an issuer is given, check that it matches the one from the retrieved document :return: a OAuth2Client \"\"\" session = session or requests . Session () discovery = session . get ( url ) . json () return cls . from_discovery_document ( discovery , issuer = issuer , auth = auth , session = session )","title":"from_discovery_endpoint()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_revocation_error","text":"Executed when the revocation endpoint return an error. Parameters: Name Type Description Default response Response the revocation response required Returns: Type Description bool returns False to signal that an error occurred. May raise exceptions instead depending on the revocation response. Source code in requests_oauth2client\\client.py def on_revocation_error ( self , response : requests . Response ) -> bool : \"\"\" Executed when the revocation endpoint return an error. :param response: the revocation response :return: returns False to signal that an error occurred. May raise exceptions instead depending on the revocation response. \"\"\" try : data = response . json () except ValueError : return False error = data . get ( \"error\" ) error_description = data . get ( \"error_description\" ) error_uri = data . get ( \"error_uri\" ) if error is not None : exception_class = self . exception_classes . get ( error , RevocationError ) raise exception_class ( error , error_description , error_uri ) return False","title":"on_revocation_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_token_error","text":"Executed when the token endpoint returns an error. Parameters: Name Type Description Default response Response the token response required Returns: Type Description BearerToken should return nothing and raise an exception instead. But a subclass can return a BearerToken to implement a default behaviour if needed. Source code in requests_oauth2client\\client.py def on_token_error ( self , response : requests . Response ) -> BearerToken : \"\"\" Executed when the token endpoint returns an error. :param response: the token response :return: should return nothing and raise an exception instead. But a subclass can return a BearerToken to implement a default behaviour if needed. \"\"\" error_json = response . json () error = error_json . get ( \"error\" ) error_description = error_json . get ( \"error_description\" ) error_uri = error_json . get ( \"error_uri\" ) if error : exception_class = self . exception_classes . get ( error , UnknownTokenEndpointError ) raise exception_class ( error , error_description , error_uri ) else : raise InvalidTokenResponse ( \"token endpoint returned an HTTP error without error message\" , error_json , )","title":"on_token_error()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_userinfo_response","text":"Given a response obtained from the userinfo endpoint, extracts its JSON content. A subclass may implement the signature validation and/or decryption of a userinfo JWT response. Parameters: Name Type Description Default resp Response a response obtained from the userinfo endpoint required Returns: Type Description Any the parsed JSON content from this response Source code in requests_oauth2client\\client.py def parse_userinfo_response ( self , resp : requests . Response ) -> Any : \"\"\" Given a response obtained from the userinfo endpoint, extracts its JSON content. A subclass may implement the signature validation and/or decryption of a userinfo JWT response. :param resp: a response obtained from the userinfo endpoint :return: the parsed JSON content from this response \"\"\" try : return resp . json () except ValueError : return resp . text","title":"parse_userinfo_response()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.refresh_token","text":"Sends a request to the token endpoint with the refresh_token grant. Parameters: Name Type Description Default refresh_token str a refresh_token required token_kwargs Any additional parameters for the token endpoint, alongside grant_type, refresh_token, etc. {} requests_kwargs Optional[Dict[str, Any]] additional parameters for the call to requests None Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\client.py def refresh_token ( self , refresh_token : str , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a request to the token endpoint with the refresh_token grant. :param refresh_token: a refresh_token :param token_kwargs: additional parameters for the token endpoint, alongside grant_type, refresh_token, etc. :param requests_kwargs: additional parameters for the call to requests :return: a BearerToken \"\"\" requests_kwargs = requests_kwargs or {} data = dict ( grant_type = \"refresh_token\" , refresh_token = refresh_token , ** token_kwargs ) return self . token_request ( data , ** requests_kwargs )","title":"refresh_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_access_token","text":"Sends a request to the revocation endpoint to revoke an access token. Parameters: Name Type Description Default access_token Union[requests_oauth2client.tokens.BearerToken, str] the access token to revoke required requests_kwargs Optional[Dict[str, Any]] additional parameters for the underlying requests.post() call None revoke_kwargs Any additional parameters to pass to the revocation endpoint {} Source code in requests_oauth2client\\client.py def revoke_access_token ( self , access_token : Union [ BearerToken , str ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Sends a request to the revocation endpoint to revoke an access token. :param access_token: the access token to revoke :param requests_kwargs: additional parameters for the underlying requests.post() call :param revoke_kwargs: additional parameters to pass to the revocation endpoint \"\"\" return self . revoke_token ( access_token , token_type_hint = \"access_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , )","title":"revoke_access_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token","text":"Sends a request to the revocation endpoint to revoke a refresh token. Parameters: Name Type Description Default refresh_token Union[str, requests_oauth2client.tokens.BearerToken] the refresh token to revoke. required requests_kwargs Optional[Dict[str, Any]] additional parameters to pass to the revocation endpoint. None revoke_kwargs Any additional parameters to pass to the revocation endpoint. {} Returns: Type Description bool True if the revocation request is successful, False if this client has no configured revocation endpoint. Source code in requests_oauth2client\\client.py def revoke_refresh_token ( self , refresh_token : Union [ str , BearerToken ], requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Sends a request to the revocation endpoint to revoke a refresh token. :param refresh_token: the refresh token to revoke. :param requests_kwargs: additional parameters to pass to the revocation endpoint. :param revoke_kwargs: additional parameters to pass to the revocation endpoint. :return: True if the revocation request is successful, False if this client has no configured revocation endpoint. \"\"\" if isinstance ( refresh_token , BearerToken ): if refresh_token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) refresh_token = refresh_token . refresh_token return self . revoke_token ( refresh_token , token_type_hint = \"refresh_token\" , requests_kwargs = requests_kwargs , ** revoke_kwargs , )","title":"revoke_refresh_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_token","text":"Generic method to use the Revocation Endpoint. Parameters: Name Type Description Default token Union[str, requests_oauth2client.tokens.BearerToken] the token to revoke. required token_type_hint Optional[str] a token_type_hint to send to the revocation endpoint. None requests_kwargs Optional[Dict[str, Any]] additional parameters to the underling call to requests.post() None revoke_kwargs Any additional parameters to send to the revocation endpoint. {} Returns: Type Description bool True if the revocation succeeds, False if no revocation endpoint is present or a non-standardised error is returned. Source code in requests_oauth2client\\client.py def revoke_token ( self , token : Union [ str , BearerToken ], token_type_hint : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** revoke_kwargs : Any , ) -> bool : \"\"\" Generic method to use the Revocation Endpoint. :param token: the token to revoke. :param token_type_hint: a token_type_hint to send to the revocation endpoint. :param requests_kwargs: additional parameters to the underling call to requests.post() :param revoke_kwargs: additional parameters to send to the revocation endpoint. :return: True if the revocation succeeds, False if no revocation endpoint is present or a non-standardised error is returned. \"\"\" if not self . revocation_endpoint : return False requests_kwargs = requests_kwargs or {} if token_type_hint == \"refresh_token\" and isinstance ( token , BearerToken ): if token . refresh_token is None : raise ValueError ( \"The supplied BearerToken doesn't have a refresh token.\" ) token = token . refresh_token data = dict ( revoke_kwargs , token = str ( token )) if token_type_hint : data [ \"token_type_hint\" ] = token_type_hint response = self . session . post ( self . revocation_endpoint , data = data , auth = self . auth , ** requests_kwargs , ) if response . ok : return True return self . on_revocation_error ( response )","title":"revoke_token()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_exchange","text":"Sends a Token Exchange request, which is actually a request to the Token Endpoint with a grant_type urn:ietf:params:oauth:grant-type:token-exchange . Parameters: Name Type Description Default subject_token Union[str, requests_oauth2client.tokens.BearerToken, requests_oauth2client.tokens.IdToken] the subject token to exchange for a new token. required subject_token_type Optional[str] a token type identifier for the subject_token, mandatory if it cannot be guessed based on type(subject_token) . None actor_token Union[NoneType, str, requests_oauth2client.tokens.BearerToken, requests_oauth2client.tokens.IdToken] the actor token to include in the request, if any. None actor_token_type Optional[str] a token type identifier for the actor_token, mandatory if it cannot be guessed based on type(actor_token) . None requested_token_type Optional[str] a token type identifier for the requested token. None requests_kwargs Optional[Dict[str, Any]] additional parameters to pass to the underlying requests.post() call. None token_kwargs Any additional parameters to include in the request body. {} Returns: Type Description BearerToken a BearerToken as returned by the Authorization Server. Source code in requests_oauth2client\\client.py def token_exchange ( self , subject_token : Union [ str , BearerToken , IdToken ], subject_token_type : Optional [ str ] = None , actor_token : Union [ None , str , BearerToken , IdToken ] = None , actor_token_type : Optional [ str ] = None , requested_token_type : Optional [ str ] = None , requests_kwargs : Optional [ Dict [ str , Any ]] = None , ** token_kwargs : Any , ) -> BearerToken : \"\"\" Sends a Token Exchange request, which is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`. :param subject_token: the subject token to exchange for a new token. :param subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based on `type(subject_token)`. :param actor_token: the actor token to include in the request, if any. :param actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based on `type(actor_token)`. :param requested_token_type: a token type identifier for the requested token. :param requests_kwargs: additional parameters to pass to the underlying `requests.post()` call. :param token_kwargs: additional parameters to include in the request body. :return: a BearerToken as returned by the Authorization Server. \"\"\" requests_kwargs = requests_kwargs or {} try : subject_token_type = self . get_token_type ( subject_token_type , subject_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of subject_token you provided.\" \"Please specify a subject_token_type.\" ) if actor_token : # pragma: no branch try : actor_token_type = self . get_token_type ( actor_token_type , actor_token ) except ValueError : raise TypeError ( \"Cannot determine the kind of actor_token you provided.\" \"Please specify an actor_token_type.\" ) data = dict ( grant_type = \"urn:ietf:params:oauth:grant-type:token-exchange\" , subject_token = subject_token , subject_token_type = subject_token_type , actor_token = actor_token , actor_token_type = actor_token_type , requested_token_type = requested_token_type , ** token_kwargs , ) return self . token_request ( data , ** requests_kwargs )","title":"token_exchange()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_request","text":"Sends a authenticated request to the token endpoint. Parameters: Name Type Description Default data Dict[str, Any] parameters to send to the token endpoint required timeout int a timeout value for the call 10 requests_kwargs Any additional parameters for requests.post() {} Returns: Type Description BearerToken the token endpoint response, as BearerToken instance. Source code in requests_oauth2client\\client.py def token_request ( self , data : Dict [ str , Any ], timeout : int = 10 , ** requests_kwargs : Any ) -> BearerToken : \"\"\" Sends a authenticated request to the token endpoint. :param data: parameters to send to the token endpoint :param timeout: a timeout value for the call :param requests_kwargs: additional parameters for requests.post() :return: the token endpoint response, as BearerToken instance. \"\"\" requests_kwargs = { key : value for key , value in requests_kwargs . items () if value is not None and value != \"\" } response = self . session . post ( self . token_endpoint , auth = self . auth , data = data , timeout = timeout , ** requests_kwargs , ) if response . ok : return self . parse_token_response ( response ) return self . on_token_error ( response )","title":"token_request()"},{"location":"api/#requests_oauth2client.client.OAuth2Client.userinfo","text":"Calls the userinfo endpoint with the specified access_token and returns the result. Parameters: Name Type Description Default access_token Union[requests_oauth2client.tokens.BearerToken, str] the access token to use required Returns: Type Description Any the requests Response returned by the userinfo endpoint. Source code in requests_oauth2client\\client.py def userinfo ( self , access_token : Union [ BearerToken , str ]) -> Any : \"\"\" Calls the userinfo endpoint with the specified access_token and returns the result. :param access_token: the access token to use :return: the requests Response returned by the userinfo endpoint. \"\"\" if not self . userinfo_endpoint : raise AttributeError ( \"No userinfo endpoint defined for this client\" ) response = self . session . post ( self . userinfo_endpoint , auth = BearerAuth ( access_token ) ) return self . parse_userinfo_response ( response )","title":"userinfo()"},{"location":"api/#requests_oauth2client.client_authentication","text":"","title":"client_authentication"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod","text":"Base class for assertion based client authentication methods.","title":"ClientAssertionAuthenticationMethod"},{"location":"api/#requests_oauth2client.client_authentication.ClientAuthenticationMethod","text":"Base class for the Client Authentication methods.","title":"ClientAuthenticationMethod"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic","text":"Handles client_secret_basic authentication (client_id and client_secret passed as Basic authentication)","title":"ClientSecretBasic"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJWT","text":"Handles client_secret_jwt client authentication method (client_assertion symmetrically signed with the client_secret).","title":"ClientSecretJWT"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost","text":"Handles client_secret_post client authentication method (client_id and client_secret passed as part of the request form data).","title":"ClientSecretPost"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJWT","text":"Handles private_key_jwt client authentication method (client_assertion asymmetrically signed with a private key).","title":"PrivateKeyJWT"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp","text":"Handles the \"none\" authentication method (client only sends its client_id).","title":"PublicApp"},{"location":"api/#requests_oauth2client.device_authorization","text":"","title":"device_authorization"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob","text":"A pooling job for checking if the user has finished with his authorization in a Device Authorization flow.","title":"DeviceAuthorizationPoolingJob"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse","text":"A response returned by the device Authorization Endpoint (as defined in RFC8628)","title":"DeviceAuthorizationResponse"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.is_expired","text":"Returns True if the device_code within this response is expired at the time of the call. Returns: Type Description Optional[bool] True if the device_code is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client\\device_authorization.py def is_expired ( self ) -> Optional [ bool ]: \"\"\" Returns True if the device_code within this response is expired at the time of the call. :return: True if the device_code is expired, False if it is still valid, None if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () > self . expires_at return None","title":"is_expired()"},{"location":"api/#requests_oauth2client.discovery","text":"","title":"discovery"},{"location":"api/#requests_oauth2client.discovery.oauth2_discovery_document_url","text":"Given an issuer identifier, return the standardised URL where the OAuth20 server metadata can be retrieved, as specified in RFC8414. Parameters: Name Type Description Default issuer str an OAuth20 Authentication Server issuer required Returns: Type Description str the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client\\discovery.py def oauth2_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OAuth20 server metadata can be retrieved, as specified in RFC8414. :param issuer: an OAuth20 Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"oauth-authorization-server\" , at_root = True )","title":"oauth2_discovery_document_url()"},{"location":"api/#requests_oauth2client.discovery.oidc_discovery_document_url","text":"Given an issuer identifier, return the standardised URL where the OIDC discovery document can be retrieved, as specified in https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata Parameters: Name Type Description Default issuer str an OIDC Authentication Server issuer required Returns: Type Description str the standardised discovery document URL. Note that no attempt to fetch this document is made. Source code in requests_oauth2client\\discovery.py def oidc_discovery_document_url ( issuer : str ) -> str : \"\"\" Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can be retrieved, as specified in https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata :param issuer: an OIDC Authentication Server `issuer` :return: the standardised discovery document URL. Note that no attempt to fetch this document is made. \"\"\" return well_known_uri ( issuer , \"openid-configuration\" , at_root = False )","title":"oidc_discovery_document_url()"},{"location":"api/#requests_oauth2client.discovery.well_known_uri","text":"Returns the location of a well-known document on an origin, according to RFC8615. Parameters: Name Type Description Default origin str required name str required at_root bool if True, assume the well-known document is at root level (as defined in RFC8615). If False, assume the well-known location is per-directory, as defined by OIDC discovery. True Returns: Type Description str the well-know uri, relative to origin, where the well-known document named name should be found. Source code in requests_oauth2client\\discovery.py def well_known_uri ( origin : str , name : str , at_root : bool = True ) -> str : \"\"\" Returns the location of a well-known document on an origin, according to RFC8615. :param origin: :param name: :param at_root: if True, assume the well-known document is at root level (as defined in RFC8615). If False, assume the well-known location is per-directory, as defined by OIDC discovery. :return: the well-know uri, relative to origin, where the well-known document named `name` should be found. \"\"\" url = furl ( origin ) if at_root : url . path = Path ( \".well-known\" ) / url . path / name else : url . path . add ( Path ( \".well-known\" ) / name ) return str ( url )","title":"well_known_uri()"},{"location":"api/#requests_oauth2client.exceptions","text":"","title":"exceptions"},{"location":"api/#requests_oauth2client.exceptions.AccessDenied","text":"Raised when the Authorization Server returns error = access_denied","title":"AccessDenied"},{"location":"api/#requests_oauth2client.exceptions.AccountSelectionRequired","text":"Raised when the Authorization Endpoint returns error = account_selection_required .","title":"AccountSelectionRequired"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationPending","text":"Raised when the Token Endpoint returns error = authorization_pending .","title":"AuthorizationPending"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError","text":"Base class for error responses returned by the Authorization endpoint.","title":"AuthorizationResponseError"},{"location":"api/#requests_oauth2client.exceptions.BackChannelAuthenticationError","text":"Base class for errors returned by the BackChannel Authentication endpoint.","title":"BackChannelAuthenticationError"},{"location":"api/#requests_oauth2client.exceptions.ConsentRequired","text":"Raised when the Authorization Endpoint returns error = consent_required .","title":"ConsentRequired"},{"location":"api/#requests_oauth2client.exceptions.DeviceAuthorizationError","text":"Base class for Device Authorization Endpoint errors.","title":"DeviceAuthorizationError"},{"location":"api/#requests_oauth2client.exceptions.EndpointError","text":"Base class for exceptions raised when a token endpoint returns a standardised error.","title":"EndpointError"},{"location":"api/#requests_oauth2client.exceptions.ExpiredAccessToken","text":"Raised when an expired access token is used.","title":"ExpiredAccessToken"},{"location":"api/#requests_oauth2client.exceptions.ExpiredToken","text":"Raised when the Token Endpoint returns error = expired_token .","title":"ExpiredToken"},{"location":"api/#requests_oauth2client.exceptions.InteractionRequired","text":"Raised when the Authorization Endpoint returns error = interaction_required .","title":"InteractionRequired"},{"location":"api/#requests_oauth2client.exceptions.IntrospectionError","text":"Base class for Introspection Endpoint errors.","title":"IntrospectionError"},{"location":"api/#requests_oauth2client.exceptions.InvalidAuthResponse","text":"Base class for errors due to Auth Responses that don't obey the standard (e.g. missing mandatory params)","title":"InvalidAuthResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidBackChannelAuthenticationResponse","text":"Raised when the BackChannel Authentication endpoint returns non-standardised errors.","title":"InvalidBackChannelAuthenticationResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidDeviceAuthorizationResponse","text":"Raised when the Device Authorization Endpoint returns a non-standard error response.","title":"InvalidDeviceAuthorizationResponse"},{"location":"api/#requests_oauth2client.exceptions.InvalidGrant","text":"Raised when the Token Endpoint returns error = invalid_grant","title":"InvalidGrant"},{"location":"api/#requests_oauth2client.exceptions.InvalidIdToken","text":"Raised when trying to validate an invalid Id Token value.","title":"InvalidIdToken"},{"location":"api/#requests_oauth2client.exceptions.InvalidScope","text":"Raised when the Token Endpoint returns error = invalid_scope","title":"InvalidScope"},{"location":"api/#requests_oauth2client.exceptions.InvalidTarget","text":"Raised when the Token Endpoint returns error = invalid_target","title":"InvalidTarget"},{"location":"api/#requests_oauth2client.exceptions.InvalidTokenResponse","text":"Base class for exceptions raised when a token endpoint returns a non-standardised response.","title":"InvalidTokenResponse"},{"location":"api/#requests_oauth2client.exceptions.LoginRequired","text":"Raised when the Authorization Endpoint returns error = login_required .","title":"LoginRequired"},{"location":"api/#requests_oauth2client.exceptions.MismatchingState","text":"Raised when an auth response contains a state parameter that doesn't match the expected state.","title":"MismatchingState"},{"location":"api/#requests_oauth2client.exceptions.MissingAuthCode","text":"Raised when the authorization code is missing from the auth response and no error is returned.","title":"MissingAuthCode"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error","text":"Base class for Exceptions raised by requests_oauth2client.","title":"OAuth2Error"},{"location":"api/#requests_oauth2client.exceptions.RevocationError","text":"Base class for Revocation Endpoint errors.","title":"RevocationError"},{"location":"api/#requests_oauth2client.exceptions.ServerError","text":"Raised when the token endpoint returns error = server_error","title":"ServerError"},{"location":"api/#requests_oauth2client.exceptions.SessionSelectionRequired","text":"Raised when the Authorization Endpoint returns error = session_selection_required .","title":"SessionSelectionRequired"},{"location":"api/#requests_oauth2client.exceptions.SlowDown","text":"Raised when the Token Endpoint returns error = slow_down .","title":"SlowDown"},{"location":"api/#requests_oauth2client.exceptions.TokenEndpointError","text":"Base class for errors that are specific to the token endpoint.","title":"TokenEndpointError"},{"location":"api/#requests_oauth2client.exceptions.UnauthorizedClient","text":"Raised when the Authorization Server returns error = unauthorized_client","title":"UnauthorizedClient"},{"location":"api/#requests_oauth2client.exceptions.UnknownIntrospectionError","text":"Raised when the Introspection Endpoint retuns a non-standard error.","title":"UnknownIntrospectionError"},{"location":"api/#requests_oauth2client.exceptions.UnknownTokenEndpointError","text":"Raised when an otherwise unknown error is returned by the token endpoint.","title":"UnknownTokenEndpointError"},{"location":"api/#requests_oauth2client.exceptions.UnsupportedTokenType","text":"Raised when the Revocation endpoint returns error = \"unsupported_token_type\"","title":"UnsupportedTokenType"},{"location":"api/#requests_oauth2client.flask","text":"","title":"flask"},{"location":"api/#requests_oauth2client.flask.auth","text":"","title":"auth"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth","text":"A Requests Authentication handler that automatically gets access tokens from an OAuth20 Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask session , so that each user has a different access token.","title":"FlaskOAuth2ClientCredentialsAuth"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin","text":"A Mixin for auth handlers to store their tokens in Flask session. This way, each user of a Flask application has a different access token.","title":"FlaskSessionAuthMixin"},{"location":"api/#requests_oauth2client.jwskate","text":"Implements the various Json Web Crypto-related standards like JWA, JWK, JWKS, JWE, JWT. This doesn't implement any actual cryptographic operations, it just provides a set of convenient wrappers around the cryptography module.","title":"jwskate"},{"location":"api/#requests_oauth2client.jwskate.ECJwk","text":"","title":"ECJwk"},{"location":"api/#requests_oauth2client.jwskate.ECJwk.kty","text":"The Key Type associated with this JWK.","title":"kty"},{"location":"api/#requests_oauth2client.jwskate.Jwk","text":"Represents a Json Web Key (JWK), as specified in RFC7517. A JWK is a JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value.","title":"Jwk"},{"location":"api/#requests_oauth2client.jwskate.Jwk.subclasses","text":"A dict of subclasses implementing each specific Key Type","title":"subclasses"},{"location":"api/#requests_oauth2client.jwskate.Jwk.__init_subclass__","text":"Automatically add subclasses to the registry. This allows new to pick the appropriate subclass when creating a Jwk Source code in requests_oauth2client\\jwskate.py def __init_subclass__ ( cls ) -> None : \"\"\"Automatically add subclasses to the registry. This allows __new__ to pick the appropriate subclass when creating a Jwk\"\"\" Jwk . subclasses [ cls . kty ] = cls","title":"__init_subclass__()"},{"location":"api/#requests_oauth2client.jwskate.Jwk.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in requests_oauth2client\\jwskate.py def __new__ ( cls , jwk : Dict [ str , Any ]): # type: ignore if cls == Jwk : if jwk . get ( \"keys\" ): # if this is a JwkSet jwks = JwkSet ( jwk ) return jwks kty : Optional [ str ] = jwk . get ( \"kty\" ) if kty is None : raise ValueError ( \"A Json Web Key must have a Key Type (kty)\" ) subclass = Jwk . subclasses . get ( kty ) if subclass is None : raise ValueError ( \"Unsupported Key Type\" , kty ) return super () . __new__ ( subclass ) return super () . __new__ ( cls )","title":"__new__()"},{"location":"api/#requests_oauth2client.jwskate.Jwk.thumbprint","text":"Returns the key thumbprint as specified by RFC 7638. Parameters: Name Type Description Default hashalg str A hash function (defaults to SHA256) 'SHA256' Source code in requests_oauth2client\\jwskate.py def thumbprint ( self , hashalg : str = \"SHA256\" ) -> str : \"\"\"Returns the key thumbprint as specified by RFC 7638. :param hashalg: A hash function (defaults to SHA256) \"\"\" digest = hashlib . new ( hashalg ) t = { \"kty\" : self . get ( \"kty\" )} for name , ( description , private , required , kind ) in self . PARAMS . items (): if required and not private : t [ name ] = self . get ( name ) intermediary = json . dumps ( t , separators = ( \",\" , \":\" ), sort_keys = True ) digest . update ( intermediary . encode ( \"utf8\" )) return b64u_encode ( digest . digest ())","title":"thumbprint()"},{"location":"api/#requests_oauth2client.jwskate.JwkSet","text":"A set of JWK keys, with methods for easy management of keys.","title":"JwkSet"},{"location":"api/#requests_oauth2client.jwskate.JwsCompact","text":"Represents a a Json Web Signature (JWS), using compact serialization, as defined in RFC7515.","title":"JwsCompact"},{"location":"api/#requests_oauth2client.jwskate.Jwt","text":"","title":"Jwt"},{"location":"api/#requests_oauth2client.jwskate.Jwt.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in requests_oauth2client\\jwskate.py def __new__ ( cls , value : str ): # type: ignore if cls == Jwt : if value . count ( \".\" ) == 2 : return super () . __new__ ( SignedJwt ) elif value . count ( \".\" ) == 3 : return super () . __new__ ( EncryptedJwt ) return super () . __new__ ( cls )","title":"__new__()"},{"location":"api/#requests_oauth2client.jwskate.OKPJwk","text":"","title":"OKPJwk"},{"location":"api/#requests_oauth2client.jwskate.OKPJwk.kty","text":"The Key Type associated with this JWK.","title":"kty"},{"location":"api/#requests_oauth2client.jwskate.RSAJwk","text":"","title":"RSAJwk"},{"location":"api/#requests_oauth2client.jwskate.RSAJwk.kty","text":"The Key Type associated with this JWK.","title":"kty"},{"location":"api/#requests_oauth2client.jwskate.SignedJwt","text":"Represents a Signed Json Web Token (JWT), as defined in RFC7519.","title":"SignedJwt"},{"location":"api/#requests_oauth2client.jwskate.SymetricJwk","text":"","title":"SymetricJwk"},{"location":"api/#requests_oauth2client.jwskate.SymetricJwk.kty","text":"The Key Type associated with this JWK.","title":"kty"},{"location":"api/#requests_oauth2client.pooling","text":"","title":"pooling"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob","text":"Base class for Token Endpoint pooling jobs on decoupled flows like CIBA or Device Authorization.","title":"TokenEndpointPoolingJob"},{"location":"api/#requests_oauth2client.tokens","text":"","title":"tokens"},{"location":"api/#requests_oauth2client.tokens.BearerToken","text":"A wrapper around a Bearer Token and associated expiration date and refresh token, as returned by an OAuth20 or OIDC Token Endpoint.","title":"BearerToken"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__contains__","text":"Check existence of a key in the token response. Allows testing like assert \"refresh_token\" in token_response . Parameters: Name Type Description Default key str a key required Returns: Type Description bool True if the key exists in the token response, False otherwise Source code in requests_oauth2client\\tokens.py def __contains__ ( self , key : str ) -> bool : \"\"\" Check existence of a key in the token response. Allows testing like `assert \"refresh_token\" in token_response`. :param key: a key :return: True if the key exists in the token response, False otherwise \"\"\" if key == \"access_token\" : return True elif key == \"refresh_token\" : return self . refresh_token is not None elif key == \"scope\" : return self . scope is not None elif key == \"token_type\" : return True elif key == \"expires_in\" : return self . expires_at is not None else : return key in self . other","title":"__contains__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__getattr__","text":"Returns items from this Token Response. Allows token_response.expires_in or token_response.any_custom_attribute Parameters: Name Type Description Default key str a key required Returns: Type Description Any the associated value in this token response Source code in requests_oauth2client\\tokens.py def __getattr__ ( self , key : str ) -> Any : \"\"\" Returns items from this Token Response. Allows `token_response.expires_in` or `token_response.any_custom_attribute` :param key: a key :return: the associated value in this token response :raises: \"\"\" if key == \"expires_in\" : if self . expires_at is None : return None return int ( self . expires_at . timestamp () - datetime . now () . timestamp ()) elif key == \"token_type\" : return \"Bearer\" return self . other . get ( key ) or super () . __getattribute__ ( key )","title":"__getattr__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.__str__","text":"Returns the access token value, as a string Returns: Type Description str the access token string Source code in requests_oauth2client\\tokens.py def __str__ ( self ) -> str : \"\"\" Returns the access token value, as a string :return: the access token string \"\"\" return self . access_token","title":"__str__()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.authorization_header","text":"Returns the Authorization Header value containing this access token, correctly formatted as per RFC6750. Returns: Type Description str the value to use in a HTTP Authorization Header Source code in requests_oauth2client\\tokens.py def authorization_header ( self ) -> str : \"\"\" Returns the Authorization Header value containing this access token, correctly formatted as per RFC6750. :return: the value to use in a HTTP Authorization Header \"\"\" return f \"Bearer { self . access_token } \"","title":"authorization_header()"},{"location":"api/#requests_oauth2client.tokens.BearerToken.is_expired","text":"Returns True if the access token is expired at the time of the call. Returns: Type Description Optional[bool] True if the access token is expired, False if it is still valid, None if there is no expires_in hint. Source code in requests_oauth2client\\tokens.py def is_expired ( self ) -> Optional [ bool ]: \"\"\" Returns True if the access token is expired at the time of the call. :return: True if the access token is expired, False if it is still valid, None if there is no expires_in hint. \"\"\" if self . expires_at : return datetime . now () > self . expires_at return None","title":"is_expired()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer","text":"","title":"BearerTokenSerializer"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_dumper","text":"Serializes as JSON, encodes as base64url of zlib compression of JSON representation of the Access Token, with expiration date represented as expires_at. Parameters: Name Type Description Default token BearerToken the :class: BearerToken to serialize required Returns: Type Description str the serialized value Source code in requests_oauth2client\\tokens.py @staticmethod def default_dumper ( token : BearerToken ) -> str : \"\"\" Serializes as JSON, encodes as base64url of zlib compression of JSON representation of the Access Token, with expiration date represented as expires_at. :param token: the :class:`BearerToken` to serialize :return: the serialized value \"\"\" return b64u_encode ( zlib . compress ( json . dumps ( token . as_dict ( True ), default = lambda d : d . timestamp () ) . encode () ) )","title":"default_dumper()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_loader","text":"Default deserializer for tokens. Parameters: Name Type Description Default serialized str the serialized token required Returns: Type Description BearerToken a BearerToken Source code in requests_oauth2client\\tokens.py def default_loader ( self , serialized : str , token_class : Type [ BearerToken ] = BearerToken ) -> BearerToken : \"\"\" Default deserializer for tokens. :param serialized: the serialized token :return: a BearerToken \"\"\" attrs = json . loads ( zlib . decompress ( b64u_decode ( serialized ))) expires_at = attrs . get ( \"expires_at\" ) if expires_at : attrs [ \"expires_at\" ] = datetime . fromtimestamp ( expires_at ) return token_class ( ** attrs )","title":"default_loader()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.dumps","text":"Serialize and compress a given token for easier storage Parameters: Name Type Description Default token BearerToken a BearerToken to serialize required Returns: Type Description str the serialized token, as a str Source code in requests_oauth2client\\tokens.py def dumps ( self , token : BearerToken ) -> str : \"\"\" Serialize and compress a given token for easier storage :param token: a BearerToken to serialize :return: the serialized token, as a str \"\"\" return self . dumper ( token )","title":"dumps()"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.loads","text":"Deserialize a serialized token Parameters: Name Type Description Default serialized str the serialized token required Returns: Type Description BearerToken the deserialized token Source code in requests_oauth2client\\tokens.py def loads ( self , serialized : str ) -> BearerToken : \"\"\" Deserialize a serialized token :param serialized: the serialized token :return: the deserialized token \"\"\" return self . loader ( serialized )","title":"loads()"},{"location":"api/#requests_oauth2client.utils","text":"","title":"utils"},{"location":"api/#requests_oauth2client.utils.b64_decode","text":"Decodes a base64-encoded string or bytes. Parameters: Name Type Description Default data Union[str, bytes] required encoding required Returns: Type Description bytes Source code in requests_oauth2client\\utils.py def b64_decode ( data : Union [ str , bytes ]) -> bytes : \"\"\" Decodes a base64-encoded string or bytes. :param data: :param encoding: :return: \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( \"ascii\" ) padding_len = len ( data ) % 4 if padding_len : data = data + b \"=\" * padding_len decoded = base64 . urlsafe_b64decode ( data ) return decoded","title":"b64_decode()"},{"location":"api/#requests_oauth2client.utils.b64_encode","text":"Encodes the string or bytes data using base64. If data is a string, encode it to string using encoding before converting it to base64. If padded is True (default), outputs includes a padding with = to make its length a multiple of 4. If False, no padding is included. Parameters: Name Type Description Default data Union[bytes, str] a str or bytes to base64-encode. required encoding str if data is a str, use this encoding to convert it to bytes first. 'utf-8' padded bool whether to include padding in the output True Returns: Type Description str a str with the base64-encoded data. Source code in requests_oauth2client\\utils.py def b64_encode ( data : Union [ bytes , str ], encoding : str = \"utf-8\" , padded : bool = True ) -> str : \"\"\" Encodes the string or bytes `data` using base64. If data is a string, encode it to string using `encoding` before converting it to base64. If padded is True (default), outputs includes a padding with = to make its length a multiple of 4. If False, no padding is included. :param data: a str or bytes to base64-encode. :param encoding: if data is a str, use this encoding to convert it to bytes first. :param padded: whether to include padding in the output :return: a str with the base64-encoded data. \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( encoding ) encoded = base64 . b64encode ( data ) if not padded : encoded = encoded . rstrip ( b \"=\" ) return encoded . decode ( \"ascii\" )","title":"b64_encode()"},{"location":"api/#requests_oauth2client.utils.b64u_decode","text":"Decodes a base64encoded string or bytes. Parameters: Name Type Description Default data Union[str, bytes] the data to decode. Can be bytes or str required encoding the encoding to use when converting the decoded data to str. If None, no decoding will be done and data will be decoded as bytes. required Returns: Type Description bytes the decoded data as a string, or bytes if encoding is None. Source code in requests_oauth2client\\utils.py def b64u_decode ( data : Union [ str , bytes ], ) -> bytes : \"\"\" Decodes a base64encoded string or bytes. :param data: the data to decode. Can be bytes or str :param encoding: the encoding to use when converting the decoded data to str. If None, no decoding will be done and data will be decoded as bytes. :return: the decoded data as a string, or bytes if `encoding` is None. \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( \"ascii\" ) padding_len = len ( data ) % 4 if padding_len : data = data + b \"=\" * padding_len decoded = base64 . urlsafe_b64decode ( data ) return decoded","title":"b64u_decode()"},{"location":"api/#requests_oauth2client.utils.b64u_encode","text":"Encodes some data in Base64url. Parameters: Name Type Description Default data Union[bytes, str] the data to encode. Can be bytes or str. required encoding str if data is a string, the encoding to use to convert it as bytes 'utf-8' padded bool if True, pad the output with = to make its length a multiple of 4 False Returns: Type Description str the base64url encoded data, as a string Source code in requests_oauth2client\\utils.py def b64u_encode ( data : Union [ bytes , str ], encoding : str = \"utf-8\" , padded : bool = False ) -> str : \"\"\" Encodes some data in Base64url. :param data: the data to encode. Can be bytes or str. :param encoding: if data is a string, the encoding to use to convert it as bytes :param padded: if True, pad the output with = to make its length a multiple of 4 :return: the base64url encoded data, as a string \"\"\" if not isinstance ( data , bytes ): if not isinstance ( data , str ): data = str ( data ) data = data . encode ( encoding ) encoded = base64 . urlsafe_b64encode ( data ) if not padded : encoded = encoded . rstrip ( b \"=\" ) return encoded . decode ( \"ascii\" )","title":"b64u_encode()"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Guillaume Pujol guill.p.linux@gmail.com Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Guillaume Pujol guill.p.linux@gmail.com","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: ## Types of Contributions ### Report Bugs Report bugs at https://github.com/guillp/requests_oauth2client/issues. If you are reporting a bug, please include: * Your operating system name and version. * Any details about your local setup that might be helpful in troubleshooting. * Detailed steps to reproduce the bug. ### Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. ### Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. ### Write Documentation requests_oauth2client could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such. ### Submit Feedback The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues. If you are proposing a feature: * Explain in detail how it would work. * Keep the scope as narrow as possible, to make it easier to implement. * Remember that this is a volunteer-driven project, and that contributions are welcome :) ## Get Started! Ready to contribute? Here's how to set up `requests_oauth2client` for local development. 1. Fork the `requests_oauth2client` repo on GitHub. 2. Clone your fork locally $ git clone git@github.com:your_name_here/requests_oauth2client.git 1 2 3 4 3. Ensure [poetry](https://python-poetry.org/docs/) is installed. 4. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev 1 2 3 5. Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature 1 2 3 4 5 6 Now you can make your changes locally. 6. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ tox 1 2 3 4 5 7. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature ```To run a subset of tests. Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/requests_oauth2client/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_requests_oauth2client Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/guillp/requests_oauth2client/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_requests_oauth2client","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.20.0 (2021-09-06) \u00b6 First properly documented version. Migrated from pipenv to poetry","title":"Changelog"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#0200-2021-09-06","text":"First properly documented version. Migrated from pipenv to poetry","title":"0.20.0 (2021-09-06)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install requests_oauth2client, run this command in your terminal: 1 $ pip install requests_oauth2client This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for requests_oauth2client can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/requests_oauth2client Or download the tarball : 1 $ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install requests_oauth2client, run this command in your terminal: 1 $ pip install requests_oauth2client This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for requests_oauth2client can be downloaded from the Github repo . You can either clone the public repository: 1 $ git clone git://github.com/guillp/requests_oauth2client Or download the tarball : 1 $ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master Once you have a copy of the source, you can install it with: 1 $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use requests_oauth2client in a project 1 from requests_oauth2client import * Alternatively, you can import only the required components one by one instead of * . You usually also have to use requests for your actual API calls: 1 import requests That is unless you use the ApiClient class as a wrapper around requests.Session . In that case, you don't need to import requests at all!","title":"Usage"},{"location":"usage/#usage","text":"To use requests_oauth2client in a project 1 from requests_oauth2client import * Alternatively, you can import only the required components one by one instead of * . You usually also have to use requests for your actual API calls: 1 import requests That is unless you use the ApiClient class as a wrapper around requests.Session . In that case, you don't need to import requests at all!","title":"Usage"}]}