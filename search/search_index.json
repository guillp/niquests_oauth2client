{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>requests_oauth2client</code> is an OAuth 2.x client for Python, able to obtain, refresh and revoke tokens from any OAuth2.x/OIDC compliant Authorization Server. It sits upon and extends the famous requests HTTP client module.</p> <p>It can act as an OAuth 2.0 / 2.1 client, to automatically get and renew Access Tokens, based on the Client Credentials, Authorization Code, Refresh token, Token Exchange, JWT Bearer, Device Authorization, Resource Owner Password or CIBA grants. Additional grant types are easy to add if needed.</p> <p>It also supports OpenID Connect 1.0, PKCE, Client Assertions, Token Revocation and Introspection, Resource Indicators, JWT-secured Authorization Requests, Pushed Authorization Requests, Authorization Server Issuer Identification, as well as using custom params to any endpoint, and other important features that are often overlooked in other client libraries.</p> <p>And it also includes a wrapper around requests.Session that makes it super easy to use REST-style APIs, with or without OAuth 2.x.</p> <p>Please note that despite the name, this library has no relationship with Google oauth2client library.</p> <p> </p>"},{"location":"#documentation","title":"Documentation","text":"<p>Full module documentation is available at https://guillp.github.io/requests_oauth2client/</p>"},{"location":"#installation","title":"Installation","text":"<p><code>requests_oauth2client</code> is available from PyPi, so installing it is as easy as:</p> <pre><code>pip install requests_oauth2client\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Everything from <code>requests_oauth2client</code> is available from the root module, so you can import it like this:</p> <pre><code>from requests_oauth2client import *\n</code></pre> <p>Or you can import individual objects from this package as usual. Note that importing <code>*</code> automatically imports <code>requests</code>, so no need to import it yourself.</p>"},{"location":"#calling-apis-with-access-tokens","title":"Calling APIs with Access Tokens","text":"<p>If you already managed to obtain an access token for the API you want to call, you can simply use the BearerAuth Auth Handler for requests:</p> <pre><code>import requests\nfrom requests_oauth2client import BearerAuth\n\ntoken = \"an_access_token\"\nresp = requests.get(\"https://my.protected.api/endpoint\", auth=BearerAuth(token))\n</code></pre> <p>This authentication handler will add a <code>Authorization: Bearer &lt;access_token&gt;</code> header in the request, with your access token, properly formatted according to RFC6750.</p>"},{"location":"#using-an-oauth2client","title":"Using an OAuth2Client","text":"<p>OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints.</p> <p>You have to provide the URLs for those endpoints if you intend to use them. Otherwise, only the Token Endpoint is mandatory to initialize an <code>OAuth2Client</code>.</p> <p>To initialize an instance of <code>OAuth2Client</code>, you only need a Token Endpoint URI from your AS, and the credentials for your application, which are typically a <code>client_id</code> and a <code>client_secret</code>, usually also provided by the AS:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre> <p>The Token Endpoint is the only endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by <code>OAuth2Client</code> is Client Secret Post, but other standardised methods such as Client Secret Basic, Client Secret JWT or Private Key JWT are supported as well. See more about client authentication methods below.</p> <p>Instead of providing each endpoint URL yourself, you may also use the AS metadata endpoint URI, or the document data itself, to initialize your OAuth 2.0 client with the appropriate endpoints.</p>"},{"location":"#obtaining-tokens","title":"Obtaining tokens","text":"<p>OAuth2Client has dedicated methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the Token Endpoint URL and Client Authentication Method to use are already declared for the client at init time, the only required parameters for those methods are those that will be sent in the request to the Token Endpoint.</p> <p>Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken contains all the data as returned by the Token Endpoint, including the Access Token. It will:</p> <ul> <li>keep track of the Access Token expiration date (based on the <code>expires_in</code> hint as returned by the AS). This date is   accessible with the <code>expires_at</code> attribute.</li> <li>contain the Refresh Token, if returned by the AS, accessible with the <code>refresh_token</code> attribute.</li> <li>contain the ID Token, if returned by the AS, accessible with the <code>\u00ecd_token</code> attribute (when using the Authorization   Code flow).</li> <li>keep track of other associated metadata as well, also accessible as attributes with the same name:   <code>token.custom_attr</code>, or with subscription syntax <code>token[\"my.custom.attr\"]</code>.</li> </ul> <p>You can create such a BearerToken yourself if you need:</p> <pre><code>from requests_oauth2client import BearerToken\n\nbearer_token = BearerToken(access_token=\"an_access_token\", expires_in=60)\nprint(bearer_token)\n# {'access_token': 'an_access_token',\n#  'expires_in': 55,\n#  'token_type': 'Bearer'}\nprint(bearer_token.expires_at)\n# datetime.datetime(2021, 8, 20, 9, 56, 59, 498793)\nassert not bearer_token.is_expired()\n\nprint(bearer_token.expires_in)\n# 40\n</code></pre> <p>Note that the <code>expires_in</code> indicator here is not static. It keeps track of the token lifetime, in seconds, and is calculated as the time flies. The actual static expiration date is accessible with the <code>expires_at</code> property. You can check if a token is expired with bearer_token.is_expired().</p> <p>You can use a BearerToken instance anywhere you can use an access_token as string.</p>"},{"location":"#using-oauth2client-as-a-requests-auth-handler","title":"Using OAuth2Client as a requests Auth Handler","text":"<p>While using OAuth2Client directly is great for testing or debugging OAuth2.x flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. <code>requests_oauth2client</code> contains several requests compatible Auth Handlers (as subclasses of requests.auth.AuthBase), that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a requests.Session, or an ApiClient, which is a wrapper around <code>Session</code> with a few enhancements as described below.</p>"},{"location":"#client-credentials-grant","title":"Client Credentials grant","text":"<p>To send a request using the Client Credentials grant, use the aptly named .client_credentials() method, with the parameters to send in the token request as keyword parameters:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\ntoken = oauth2client.client_credentials(scope=\"myscope\")\n# or, if your AS uses resource indicator:\ntoken = oauth2client.client_credentials(scope=\"myscope\", resource=\"https://myapi.local\")\n# or, if your AS uses 'audience' as parameter to identify the requested API (Auth0 style):\ntoken = oauth2client.client_credentials(audience=\"https://myapi.local\")\n# or, if your AS uses custom parameters:\ntoken = oauth2client.client_credentials(scope=\"myscope\", custom_param=\"custom_value\")\n</code></pre> <p>Parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> or any other parameter that may be required by the AS can be passed as keyword parameters. Those will be included in the token request that is sent to the AS. <code>scope</code> is not mandatory at client level (but it might be required by your AS to serve your request).</p>"},{"location":"#as-auth-handler","title":"As Auth Handler","text":"<p>You can use the OAuth2ClientCredentialsAuth auth handler. It takes an <code>OAuth2Client</code> as parameter, and the additional kwargs to pass to the token endpoint:</p> <pre><code>import requests\nfrom requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client, scope=\"myscope\", resource=\"https://myapi.local\"\n)\n\n# use it like this:\nrequests.get(\"https://myapi.local/resource\", auth=auth)\n\n# or like this:\nsession = requests.Session()\nsession.auth = auth\n\nresp = session.get(\"https://myapi.local/resource\")\n</code></pre> <p>Once again, extra parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> are allowed if required.</p> <p>When you send your first request, OAuth2ClientCredentialsAuth will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in the request. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved once the previous one is expired.</p> <p>You can configure a leeway, which is a period of time before the actual expiration, in seconds, when a new token will be obtained. This may help getting continuous access to the API when the client and API clocks are slightly out of sync. Use the parameter <code>leeway</code> to <code>OAuth2ClientCredentialsAuth</code>:</p> <pre><code>from requests_oauth2client import OAuth2ClientCredentialsAuth\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client,\n    scope=\"myscope\",\n    leeway=30,\n)\n</code></pre>"},{"location":"#authorization-code-grant","title":"Authorization Code Grant","text":"<p>Obtaining tokens using the Authorization code grant is made in 3 steps:</p> <ol> <li> <p>your application must open a specific url called the Authentication Request in a browser.</p> </li> <li> <p>your application must obtain and validate the Authorization Response, which is a redirection back to your    application that contains an Authorization Code as parameter. This redirect back (often called \"callback\") is    initiated by the Authorization Server after any necessary interaction with the user is complete (Registration, Login,    Profile completion, Multi-Factor Authentication, Authorization, Consent, etc.)</p> </li> <li> <p>your application must then exchange this Authorization Code for an Access Token, with a request to the Token    Endpoint.</p> </li> </ol> <p>Using an <code>OAuth2Client</code> will help you with all those steps, as described below.</p>"},{"location":"#generating-authorization-requests","title":"Generating Authorization Requests","text":"<p>To be able to use the Authorization Code grant, you need 2 (optionally 3) URIs:</p> <ul> <li>the URL for Authorization Endpoint, which is the url where you must send your Authorization Requests</li> <li>the Redirect URI, which is the url pointing to your application, where the Authorization Server will reply with   Authorization Response</li> <li>optionally, the issuer identifier, if your AS uses   Issuer Identification.</li> </ul> <p>You can declare those URIs when initializing your <code>OAuth2Client</code> instance, or you can use the AS discovery endpoint to initialize those URLs automatically. Then you can generate valid Authorization Requests by calling the method <code>.authorization_request()</code>, with the request specific parameters, such as <code>scope</code>, <code>state</code>, <code>nonce</code> as parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    redirect_uri=\"https://url.to.my.application/redirect_uri\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\naz_request = client.authorization_request(scope=\"openid email profile\")\n\nprint(az_request)\n# this will look like this, with line feeds for display purposes only:\n# https://url.to.the.as/authorization_endpoint\n# ?client_id=client_id\n# &amp;redirect_uri=https%3A%2F%2Furl.to.my.application%2Fredirect_uri\n# &amp;response_type=code\n# &amp;scope=openid+email+profile\n# &amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY\n# &amp;nonce=iHZJokhkGOAojff1tdknRyz9mPZyy5vq9JDlVaUHyqk\n# &amp;code_challenge=TG7qgdyKnwUPuoQ6NNJRlLMoHbeVmJlB8g0VOcfQEkc\n# &amp;code_challenge_method=S256\n\n# you can send the user to that url with:\nimport webbrowser\n\nwebbrowser.open(az_request.uri)\n</code></pre> <p>Note that the <code>state</code>, <code>nonce</code> and <code>code_challenge</code> parameters are generated with secure random values by default. Should you wish to use your own values, you can pass them as parameters to <code>OAuth2Client.authorization_request()</code>. For PKCE, you need to pass your generated <code>code_verifier</code>, and the <code>code_challenge</code> will automatically be derived from it. If you want to disable PKCE, you can pass <code>code_challenge_method=None</code> when initializing your <code>OAuth2Client</code>.</p>"},{"location":"#validating-the-authorization-response","title":"Validating the Authorization Response","text":"<p>Once you have redirected the user browser to the Authorization Request URI, and after the user is successfully authenticated and authorized, plus any other extra interactive step is complete, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response. It contains several parameters that must be retrieved by your client. The Authorization Code is one of those parameters, but you must also validate that the state matches your request; if using AS Issuer Identification, you must also validate that the issuer matches what is expected. You can do this with:</p> <pre><code># using the `az_request` as defined above\n\nresponse_uri = input(\n    \"Please enter the full url and/or params obtained on the redirect_uri: \"\n)\n# say the callback url is https://url.to.my.application/redirect_uri?code=an_az_code&amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY&amp;issuer=https://url.to.the.as\naz_response = az_request.validate_callback(response_uri)\n</code></pre> <p>This <code>auth_response</code> is an <code>AuthorizationResponse</code> instance and contains everything that is needed for your application to complete the authentication and get its tokens from the AS.</p>"},{"location":"#exchanging-code-for-tokens","title":"Exchanging code for tokens","text":"<p>Once you have obtained the AS response, containing an authorization code, your application must exchange it for actual Token(s).</p> <p>To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method. If you have obtained an AuthorizationResponse as described above, you can simply do:</p> <pre><code>token = oauth2client.authorization_code(az_response)\n</code></pre> <p>This will automatically include the <code>code</code>, <code>redirect_uri</code> and <code>code_verifier</code> parameters in the Token Request, as expected by the AS. You may include extra parameters if required, or you may pass your own parameters, without using an <code>AuthorizationResponse</code> instance, like this:</p> <pre><code>token = oauth2client.authorization_code(\n    code=code,\n    code_verifier=code_verifier,\n    redirect_uri=redirect_uri,\n    custom_param=custom_value,\n)\n</code></pre>"},{"location":"#as-auth-handler_1","title":"As Auth Handler","text":"<p>The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2AuthorizationCodeAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2AuthorizationCodeAuth(\n        oauth2client,\n        \"my_authorization_code\",\n    ),\n)\n\n# any request using api_client will trigger exchanging the code for an access_token, which is then cached, and refreshed later if needed\nresp = api_client.post(data={...})\n</code></pre> <p>OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available.</p>"},{"location":"#note-on-authorizationrequest","title":"Note on AuthorizationRequest","text":"<p>Authorization Requests generated by <code>OAuth2Client.authorization_request()</code> are instance of the class <code>AuthorizationRequest</code>. You can also use that class directly to generate your requests, but in that case you need to supply your Authorization Endpoint URI, your <code>client_id</code>, <code>redirect_uri</code>, etc. You can access every parameter from an <code>AuthorizationRequest</code> instance, as well as the generated <code>code_verifier</code>, as attributes of this instance. Once an Authorization Request URL is generated, it your application responsibility to redirect or otherwise send the user to that URL. You may use the <code>webbrowser</code> module from Python standard library to do so. Here is an example for generating Authorization Requests:</p> <pre><code>from requests_oauth2client import AuthorizationRequest\n\naz_request = AuthorizationRequest(\n    \"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",  # this redirect_uri is specific to your app\n    scope=\"openid email profile\",\n    # extra parameters such as `resource` can be included as well if required by your AS\n    resource=\"https://my.resource.local/api\",\n)\nprint(\n    az_request\n)  # this request will look like this, with line breaks for display purposes only\n# https://url.to.the/authorization_endpoint\n# ?client_id=my_client_id\n# &amp;redirect_uri=http%3A%2F%2Flocalhost%callback\n# &amp;response_type=code\n# &amp;state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc\n# &amp;nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc\n# &amp;scope=openid+email+profile\n# &amp;code_challenge=W3n02f6xUKoDVbmhWEWz3h780b-Ci6ucnBS_d7nogmQ\n# &amp;code_challenge_method=S256\n# &amp;resource=https%3A%2F%2Fmy.resource.local%2Fapi\n\nprint(az_request.code_verifier)\n# 'gYK-ZnQfoat2bghwed7oEz--wvn4D70ksJ5GuWO9sXXygZ7PMnUlSpBmMCcNRHxdgTS9m_roYwGxF6HQxIqZVwXmxRJUziFHUFxDrNuUIjCJCx6gBhPlpFbUXulB1fo2'\n</code></pre>"},{"location":"#device-authorization-grant","title":"Device Authorization Grant","text":"<p>Helpers for the Device Authorization Grant are also included. To get device and user codes, read the response attributes (including Device Code, User Code, Verification URI, etc.), then pooling the Token Endpoint:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    DeviceAuthorizationPoolingJob,\n    BearerToken,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nda_resp = client.authorize_device()\n\n# `da_resp` contains the Device Code, User Code, Verification URI and other info returned by the AS:\nda_resp.device_code\nda_resp.user_code\nda_resp.verification_uri\nda_resp.verification_uri_complete\nda_resp.expires_at  # just like for BearerToken, expiration is tracked by requests_oauth2client\nda_resp.interval\n\n# Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and\n# input the User Code.\n\n# You can then request the Token endpoint to check if the user successfully authorized your device like this:\npool_job = DeviceAuthorizationPoolingJob(client, da_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call <code>pool_job()</code>, it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests.</p>"},{"location":"#as-auth-handler_2","title":"As Auth Handler","text":"<p>Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token:</p> <pre><code>from requests_oauth2client import ApiClient, OAuth2DeviceCodeAuth, OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\ndevice_auth_resp = client.authorize_device()\n\n# expose user_code and verification_uri or verification_uri_complete to the user\ndevice_auth_resp.user_code\ndevice_auth_resp.verification_uri\ndevice_auth_resp.verification_uri_complete\n\n# then try to send your request with a OAuth2DeviceCodeAuth handler\n# this will pool the token endpoint until the user authorize the device\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2DeviceCodeAuth(client, device_auth_resp),\n)\n\nresp = api_client.post(\n    data={...}\n)  # first call will hang until the user authorizes your app and the token endpoint returns a token.\n</code></pre>"},{"location":"#client-initiated-backchannel-authentication-ciba","title":"Client-Initiated BackChannel Authentication (CIBA)","text":"<p>To initiate a BackChannel Authentication against the dedicated endpoint, read the response attributes, and pool the Token Endpoint until the end-user successfully authenticates:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    BearerToken,\n    BackChannelAuthenticationPoolingJob,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    backchannel_authentication_endpoint=\"https://url.to.the/backchannel_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nba_resp = client.backchannel_authentication_request(\n    scope=\"openid email profile\",\n    login_hint=\"user@example.net\",\n)\n\n# `ba_resp` will contain the response attributes as returned by the AS, including an `auth_req_id`:\nba_resp.auth_req_id\nba_resp.expires_in  # decreases as times fly\nba_resp.expires_at  # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS\nba_resp.interval  # the pooling interval indicated by the AS\nba_resp.custom  # if the AS respond with additional attributes, they are also accessible\n\npool_job = BackChannelAuthenticationPoolingJob(client, ba_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>Hints by the AS to slow down pooling will automatically be obeyed.</p>"},{"location":"#token-exchange","title":"Token Exchange","text":"<p>To send a token exchange request, use the OAuth2Client.token_exchange() method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\ntoken = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"urn:ietf:params:oauth:token-type:access_token\",\n)\n</code></pre> <p>As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like <code>actor_token</code> or <code>actor_token_type</code>, or any custom parameter. There are short names for token types, that will be automatically translated to standardised types:</p> <pre><code>token = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"access_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=\"your_actor_token\",\n    actor_token_type=\"id_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre> <p>Or to make it even easier, types can be guessed based on the supplied subject or actor token:</p> <pre><code>from requests_oauth2client import BearerToken, ClientSecretJwt, IdToken, OAuth2Client\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\ntoken = client.token_exchange(\n    subject_token=BearerToken(\n        \"your_token_value\"\n    ),  # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=IdToken(\n        \"your_actor_token\"\n    ),  # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre>"},{"location":"#supported-client-authentication-methods","title":"Supported Client Authentication Methods","text":"<p><code>requests_oauth2client</code> supports several client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client, with the <code>auth</code> parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards.</p>"},{"location":"#client-secret-basic","title":"Client Secret Basic","text":"<p>With client_secret_basic, <code>client_id</code> and <code>client_secret</code> are included in clear-text in the <code>Authorization</code> header when sending requests to the Token Endpoint. To use it, just pass a <code>ClientSecretBasic(client_id, client_secret)</code> as <code>auth</code> parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretBasic\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretBasic(\"client_id\", \"client_secret\"),\n)\n</code></pre>"},{"location":"#client-secret-post","title":"Client Secret Post","text":"<p>With client_secret_post, <code>client_id</code> and <code>client_secret</code> are included as part of the body form data. To use it, pass a <code>ClientSecretPost(client_id, client_secret)</code> as <code>auth</code> parameter. This is the default when you pass a tuple <code>(client_id, client_secret)</code> as <code>auth</code> when initializing an <code>OAuth2Client</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretPost\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretPost(\"client_id\", \"client_secret\"),\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", \"client_secret\")\n)\n# or\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre>"},{"location":"#client-secret-jwt","title":"Client Secret JWT","text":"<p>With client_secret_jwt, the client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and an expiration date a few seconds in the future. To use it, pass a <code>ClientSecretJwt(client_id, client_secret)</code> as <code>auth</code> parameter. Assertion generation is entirely automatic, you don't have anything to do:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This method is more secure than the 2 previous, because only ephemeral credentials are transmitted, which limits the possibility for interception and replay of the Client Secret. But that Client Secret still needs to be shared between the AS and Client owner(s).</p>"},{"location":"#private-key-jwt","title":"Private Key JWT","text":"<p>With private_key_jwt, client uses a JWT assertion that is just like the one for client_secret_jwt, but it is signed with an asymmetric key. To use it, you need a private signing key, in a <code>dict</code> that matches the JWK format, or as an instance of <code>jwskate.Jwk</code>. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is simple with the <code>PrivateKeyJwt(client_id, private_jwk)</code> auth handler:</p> <pre><code>from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\nprivate_jwk = {\n    \"kid\": \"mykid\",\n    \"kty\": \"RSA\",\n    \"e\": \"AQAB\",\n    \"n\": \"...\",\n    \"d\": \"...\",\n    \"p\": \"...\",\n    \"q\": \"...\",\n    \"dp\": \"...\",\n    \"dq\": \"...\",\n    \"qi\": \"...\",\n}\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PrivateKeyJwt(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", client_id=\"client_id\", private_jwk=private_jwk\n)\n</code></pre> <p>This method can be considered more secure than those relying on a client secret, because only ephemeral credentials are sent over the wire, and it uses asymmetric cryptography: the signing key is generated by the client, and only the public key is known by the AS. Transmitting that public key between owner(s) of the client and of the AS is much easier than transmitting the Client Secret, which is a shared key that must be considered as confidential.</p>"},{"location":"#none","title":"None","text":"<p>The latest Client Authentication Method, none, is for Public Clients which do not authenticate to the Token Endpoint. Those clients only include their <code>client_id</code> in body form data, without any authentication credentials. Use <code>PublicApp(client_id)</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PublicApp(\"app_client_id\")\n)\n</code></pre>"},{"location":"#token-revocation","title":"Token Revocation","text":"<p>OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the OAuth2Client. The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    revocation_endpoint=\"https://url.to.the/revocation_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\noauth2client.revoke_token(\"mytoken\", token_type_hint=\"access_token\")\noauth2client.revoke_access_token(\n    \"mytoken\"\n)  # will automatically add token_type_hint=access_token\noauth2client.revoke_refresh_token(\n    \"mytoken\"\n)  # will automatically add token_type_hint=refresh_token\n</code></pre> <p>Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server returns a non-successful HTTP code, but no standardised error message, it will return <code>False</code>. If the Authorization Server actually returns a standardised error, an exception will be raised instead, like the other methods from <code>OAuth2Client</code>.</p>"},{"location":"#token-introspection","title":"Token Introspection","text":"<p>OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the <code>OAuth2Client</code>. The OAuth2Client.introspect_token() method is then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    introspection_endpoint=\"https://url.to.the/introspection_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\nresp = oauth2client.introspect_token(\"mytoken\", token_type_hint=\"access_token\")\n</code></pre> <p>It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded).</p>"},{"location":"#userinfo-requests","title":"UserInfo Requests","text":"<p>OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the <code>OAuth2Client</code>. The OAuth2Client.userinfo()) method is then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    userinfo_endpoint=\"https://url.to.the/userinfo_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\nresp = oauth2client.userinfo(\"mytoken\")\n</code></pre> <p>It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded).</p>"},{"location":"#initializing-an-oauth2client-from-a-discovery-document","title":"Initializing an <code>OAuth2Client</code> from a discovery document","text":"<p>You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    \"https://url.to.the.as/.well-known/openid-configuration\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\n# OR, if you know the issuer value\noauth2client = OAuth2Client.from_discovery_endpoint(\n    issuer=\"https://url.to.the.as\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs.</p> <p>If using the <code>issuer</code> keyword arg, the URI to the discovery endpoint will be deduced from that identifier, and a check will be made that the <code>issuer</code> from the retrieved metadata document matches that value.</p>"},{"location":"#specialized-api-client","title":"Specialized API Client","text":"<p>Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, <code>requests_oauth2client</code> includes a requests.Session wrapper called ApiClient, which takes the root API url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an <code>auth</code> parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests-compatible Authentication Handler. Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", (\"client_id\", \"client_secret\")\n)\napi = ApiClient(\n    \"https://myapi.local/root\", auth=OAuth2ClientCredentialsAuth(oauth2client)\n)\n\n# will actually send a GET to https://myapi.local/root/resource/foo\nresp = api.get(\"/resource/foo\")\n</code></pre> <p>Note that ApiClient will never send requests \"outside\" its configured root url. The leading <code>/</code> in <code>/resource</code> above is optional. A leading <code>/</code> will not \"reset\" the url path to root, which means that you can also write the relative path without the <code>/</code> and it will automatically be included:</p> <pre><code>api.get(\"resource/foo\")  # will also send a GET to https://myapi.local/root/resource/foo\n</code></pre> <p>You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a <code>/</code> and appended to the url path:</p> <pre><code># will send a GET to https://myapi.local/root/resource/foo\napi.get([\"resource\", \"foo\"])\n# will send a GET to https://myapi.local/root/users/1234/details\napi.get([\"users\", 1234, \"details\"])\n</code></pre> <p>You can also use a syntax based on <code>__getattr__</code> or <code>__getitem__</code>:</p> <pre><code>api.resource.get()  # will send a GET to https://myapi.local/root/resource\napi[\"my-resource\"].get()  # will send a GET to https://myapi.local/root/my-resource\n</code></pre> <p>Both <code>__getattr__</code> and <code>__getitem__</code> return a new <code>ApiClient</code> initialised on the new base_url. So you can easily call multiple sub-resources on the same API this way:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local\")\nusers_api = api.users\nuser = users_api.get(\"userid\")  # GET https://myapi.local/users/userid\nother_user = users_api.get(\"other_userid\")  # GET https://myapi.local/users/other_userid\nresources_api = api.resources\nresources = resources_api.get()  # GET https://myapi.local/resources\n</code></pre> <p>ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing <code>raise_for_status=False</code> when initializing your ApiClient:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\n    \"http://httpstat.us\", raise_for_status=False\n)  # raise_for_status defaults to True\nresp = api.get(\"500\")\nassert resp is not None\n# without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead\n</code></pre> <p>You may override this at request time:</p> <pre><code># raise_for_status at request-time overrides the value defined at init-time\nresp = api.get(\"500\", raise_for_status=True)\n</code></pre> <p>You can access the underlying <code>requests.Session</code> with the session attribute, and you can provide an already existing and configured <code>Session</code> instance at init time:</p> <pre><code>import requests\nfrom requests_oauth2client import ApiClient\n\nsession = requests.Session()\nsession.proxies = {\"https\": \"http://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\nassert api.session == session\n</code></pre>"},{"location":"#vendor-specific-clients","title":"Vendor-Specific clients","text":"<p><code>requests_oauth2client</code> is flexible enough to handle most use cases, so you should be able to use any AS by any vendor as long as it supports OAuth 2.0.</p> <p>You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. OAuth2Client has several extensibility points in the form of methods like <code>OAuth2Client.parse_token_response()</code>, <code>OAuth2Client.on_token_error()</code> that implement response parsing, error handling, etc.</p> <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0client = Auth0.client(\n    \"mytenant.eu\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\n# this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token\n# and other endpoints accordingly\ntoken = a0client.client_credentials(audience=\"audience\")\n\n# this is a wrapper around Auth0 Management API\na0mgmt = Auth0.management_api_client(\n    \"mytenant.eu\", client_id=\"client_id\", client_secret=\"client_secret\"\n)\nmyusers = a0mgmt.get(\"users\")\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#requests_oauth2client","title":"<code>requests_oauth2client</code>","text":"<p>Main module for <code>requests_oauth2client</code>.</p> <p>You can import any class from any submodule directly from this main module.</p>"},{"location":"api/#requests_oauth2client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for REST API calls.</p> <p>Additional features compared to using a requests.Session directly:</p> <ul> <li>You must set a root url at creation time, which then allows passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code>  or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc.</p> <p>An <code>HTTPError</code> will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Usage <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init its own session and provide additional configuration\n# parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\",\n    proxies={\"https\": \"https://localhost:3128\"},\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>the base api url, that is the root for all the target API endpoints.</p> required <code>auth</code> <code>AuthBase | None</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>the default timeout, in seconds, to use for each request from this <code>ApiClient</code>. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>what to do with parameters with value <code>None</code> in <code>data</code> or <code>json</code> fields.</p> <ul> <li>if <code>\"exclude\"</code> (default), fields whose values are <code>None</code> are not included in the request.</li> <li>if <code>\"include\"</code>, they are included with string value <code>None</code>. Note that this is the default behavior of <code>requests</code>.</li> <li>if \"empty\", they are included with an empty value (as an empty string).</li> </ul> <code>'exclude'</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>a tuple of (true_value, false_value). Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and <code>requests</code> serializes <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behaviour.</p> <code>('true', 'false')</code> <code>session</code> <code>Session | None</code> <p>a preconfigured <code>requests.Session</code> to use with this <code>ApiClient</code>.</p> <code>None</code> <code>**session_kwargs</code> <code>Any</code> <p>additional kwargs to configure the underlying <code>requests.Session</code>.</p> <code>{}</code> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>@frozen(init=False)\nclass ApiClient:\n    \"\"\"A Wrapper around [requests.Session][] with extra features for REST API calls.\n\n    Additional features compared to using a [requests.Session][] directly:\n\n    - You must set a root url at creation time, which then allows passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the\n    [Session][requests.Session], instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be\n    automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable\n    for the target API, like `\"true\"`  or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default\n    values `\"True\"` or `\"False\"`.\n\n    `base_url` will serve as root for relative urls passed to\n    [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request],\n    [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n\n    An `HTTPError` will be raised everytime an API call returns an error code (&gt;= 400), unless\n    you set `raise_for_status` to `False`. Additional parameters passed at init time, including\n    `auth` will be used to configure the [Session][requests.Session].\n\n    Usage:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init its own session and provide additional configuration\n        # parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\",\n            proxies={\"https\": \"https://localhost:3128\"},\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that is the root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this `ApiClient`.\n            Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an\n            error code (&gt;= 400).\n        none_fields: what to do with parameters with value `None` in `data` or `json` fields.\n\n            - if `\"exclude\"` (default), fields whose values are `None` are not included in the request.\n            - if `\"include\"`, they are included with string value `None`. Note that this is\n            the default behavior of `requests`.\n            - if \"empty\", they are included with an empty value (as an empty string).\n        bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with\n            a boolean value (`True` or `False`) will be serialized to the corresponding value.\n            This can be useful since some APIs expect a `'true'` or `'false'` value as boolean,\n            and `requests` serializes `True` to `'True'` and `False` to `'False'`.\n            Set it to `None` to restore default requests behaviour.\n        session: a preconfigured `requests.Session` to use with this `ApiClient`.\n        **session_kwargs: additional kwargs to configure the underlying `requests.Session`.\n\n    \"\"\"\n\n    base_url: str\n    auth: requests.auth.AuthBase | None = None\n    timeout: int | None = 60\n    raise_for_status: bool = True\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\"\n    bool_fields: tuple[Any, Any] | None = \"true\", \"false\"\n    session: requests.Session = field(factory=requests.Session)\n\n    def __init__(\n        self,\n        base_url: str,\n        *,\n        auth: requests.auth.AuthBase | None = None,\n        timeout: int | None = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: tuple[Any, Any] | None = (\"true\", \"false\"),\n        session: requests.Session | None = None,\n        **session_kwargs: Any,\n    ):\n        session = session or requests.Session()\n        for key, val in session_kwargs.items():\n            setattr(session, key, val)\n\n        if bool_fields is None:\n            bool_fields = (True, False)\n\n        self.__attrs_init__(\n            base_url=base_url,\n            auth=auth,\n            raise_for_status=raise_for_status,\n            none_fields=none_fields,\n            bool_fields=bool_fields,\n            timeout=timeout,\n            session=session,\n        )\n\n    def request(  # noqa: C901, PLR0913, D417\n        self,\n        method: str,\n        url: None | str | bytes | Iterable[str | bytes | int] = None,\n        *,\n        params: None | bytes | MutableMapping[str, str] = None,\n        data: (\n            Iterable[bytes]\n            | str\n            | bytes\n            | list[tuple[Any, Any]]\n            | tuple[tuple[Any, Any], ...]\n            | Mapping[Any, Any]\n            | None\n        ) = None,\n        headers: MutableMapping[str, str] | None = None,\n        cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n        files: MutableMapping[str, IO[Any]] | None = None,\n        auth: (\n            None\n            | tuple[str, str]\n            | requests.auth.AuthBase\n            | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n        ) = None,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        allow_redirects: bool = False,\n        proxies: MutableMapping[str, str] | None = None,\n        hooks: None\n        | (\n            MutableMapping[\n                str,\n                (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n            ]\n        ) = None,\n        stream: bool | None = None,\n        verify: str | bool | None = None,\n        cert: str | tuple[str, str] | None = None,\n        json: Mapping[str, Any] | None = None,\n        raise_for_status: bool | None = None,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n        bool_fields: tuple[Any, Any] | None = None,\n    ) -&gt; requests.Response:\n        \"\"\"Overridden `request` method with extra features.\n\n        Features added compared to plain request():\n\n        - takes a relative path instead of a full url, which will be appended to the\n          base_url\n        - it can raise an exception when the API returns a non-success status code\n        - allow_redirects is False by default (since API usually don't use redirects)\n        - `data` or `json` fields with value `None` can either be included or excluded from the\n          request\n        - boolean fields can be serialized to `'true'` or `'false'` instead of `'True'` and\n          `'False'`\n\n        Args:\n          method: the HTTP method to use\n          url: the url where the request will be sent to. Can be a path, as str ;\n            that path will be joined to the configured API url. Can also be an iterable of path\n            segments, that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from `ApiClient.__init__`,\n            but this will be applied for this request only.\n          none_fields: like the parameter of the same name from `ApiClient.__init__`,\n            but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from `ApiClient.__init__`,\n            but this will be applied for this request only.\n\n        Returns:\n          a [requests.Response][] as returned by requests\n\n        \"\"\"\n        url = self.to_absolute_url(url)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            try:\n                true_value, false_value = bool_fields\n            except ValueError:\n                msg = \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\"\n                raise ValueError(msg) from None\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth or self.auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(self, relative_url: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n        \"\"\"Convert a relative url to an absolute url.\n\n        Given a `relative_url`, return the matching absolute url, based on the `base_url` that is\n        configured for this API.\n\n        The result of this method is different from a standard `urljoin()`, because a relative_url\n        that starts with a \"/\" will not override the path from the base url. You can also pass an\n        iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n        may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n        any other type (which will be converted to `str` first, using the `str() function`). See the\n        table below for example results which would exhibit most cases:\n\n        | base_url | relative_url | result_url |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | b\"/path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | \"path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | None | \"https://myhost.com/root\" |\n        | \"https://myhost.com/root\" |  (\"user\", 1, \"resource\") | \"https://myhost.com/root/user/1/resource\" |\n        | \"https://myhost.com/root\" | \"https://otherhost.org/foo\" | ValueError |\n\n        Args:\n          relative_url: a relative url\n\n        Returns:\n          the resulting absolute url\n\n        \"\"\"\n        url = relative_url\n\n        if self.base_url:\n            if url is not None:\n                if not isinstance(url, (str, bytes)):\n                    try:\n                        url = \"/\".join(\n                            [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part]\n                        )\n                    except Exception as exc:\n                        msg = (\n                            \"Unexpected url type, please pass a relative path as string or\"\n                            \" bytes, or an iterable of string-able objects\"\n                        )\n                        raise TypeError(\n                            msg,\n                            type(url),\n                        ) from exc\n\n                if isinstance(url, bytes):\n                    url = url.decode()\n\n                if \"://\" in url:\n                    msg = \"url must be relative to root_url\"\n                    raise ValueError(msg)\n\n                url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n            else:\n                url = self.base_url\n\n        if url is None or not isinstance(url, str):\n            msg = \"Unable to determine an absolute url.\"\n            raise ValueError(msg)\n\n        return url\n\n    def get(\n        self,\n        url: None | str | bytes | Iterable[str | bytes | int] = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a GET request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            url: a url where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: Optional arguments that [request()][requests.request] takes.\n\n        Returns:\n            a [Response][requests.Response] object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"GET\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a POST request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: an url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: Optional arguments that ``request`` takes.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"POST\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: an url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: Optional arguments that ``request`` takes.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PATCH\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PUT\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"DELETE\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new ApiClient initialised on the new base url\n\n        Usage:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new ApiClient initialised on the new base url\n\n        Usage:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; ApiClient:\n        \"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as\n        `requests.Session`. The underlying request.Session will be closed on exit.\n\n        Usage:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n\n        \"\"\"\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n        \"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.request","title":"<code>request(method, url=None, *, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>Overridden <code>request</code> method with extra features.</p> <p>Features added compared to plain request():</p> <ul> <li>takes a relative path instead of a full url, which will be appended to the   base_url</li> <li>it can raise an exception when the API returns a non-success status code</li> <li>allow_redirects is False by default (since API usually don't use redirects)</li> <li><code>data</code> or <code>json</code> fields with value <code>None</code> can either be included or excluded from the   request</li> <li>boolean fields can be serialized to <code>'true'</code> or <code>'false'</code> instead of <code>'True'</code> and   <code>'False'</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the HTTP method to use</p> required <code>url</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the url where the request will be sent to. Can be a path, as str ; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <code>None</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty'] | None</code> <p>like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <code>None</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>a requests.Response as returned by requests</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901, PLR0913, D417\n    self,\n    method: str,\n    url: None | str | bytes | Iterable[str | bytes | int] = None,\n    *,\n    params: None | bytes | MutableMapping[str, str] = None,\n    data: (\n        Iterable[bytes]\n        | str\n        | bytes\n        | list[tuple[Any, Any]]\n        | tuple[tuple[Any, Any], ...]\n        | Mapping[Any, Any]\n        | None\n    ) = None,\n    headers: MutableMapping[str, str] | None = None,\n    cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n    files: MutableMapping[str, IO[Any]] | None = None,\n    auth: (\n        None\n        | tuple[str, str]\n        | requests.auth.AuthBase\n        | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n    ) = None,\n    timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n    allow_redirects: bool = False,\n    proxies: MutableMapping[str, str] | None = None,\n    hooks: None\n    | (\n        MutableMapping[\n            str,\n            (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n        ]\n    ) = None,\n    stream: bool | None = None,\n    verify: str | bool | None = None,\n    cert: str | tuple[str, str] | None = None,\n    json: Mapping[str, Any] | None = None,\n    raise_for_status: bool | None = None,\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n    bool_fields: tuple[Any, Any] | None = None,\n) -&gt; requests.Response:\n    \"\"\"Overridden `request` method with extra features.\n\n    Features added compared to plain request():\n\n    - takes a relative path instead of a full url, which will be appended to the\n      base_url\n    - it can raise an exception when the API returns a non-success status code\n    - allow_redirects is False by default (since API usually don't use redirects)\n    - `data` or `json` fields with value `None` can either be included or excluded from the\n      request\n    - boolean fields can be serialized to `'true'` or `'false'` instead of `'True'` and\n      `'False'`\n\n    Args:\n      method: the HTTP method to use\n      url: the url where the request will be sent to. Can be a path, as str ;\n        that path will be joined to the configured API url. Can also be an iterable of path\n        segments, that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from `ApiClient.__init__`,\n        but this will be applied for this request only.\n      none_fields: like the parameter of the same name from `ApiClient.__init__`,\n        but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from `ApiClient.__init__`,\n        but this will be applied for this request only.\n\n    Returns:\n      a [requests.Response][] as returned by requests\n\n    \"\"\"\n    url = self.to_absolute_url(url)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        try:\n            true_value, false_value = bool_fields\n        except ValueError:\n            msg = \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\"\n            raise ValueError(msg) from None\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        url,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth or self.auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(relative_url=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>relative_url</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this method is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for example results which would exhibit most cases:</p> base_url relative_url result_url \"https://myhost.com/root\" \"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" \"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" b\"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" \"path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" None \"https://myhost.com/root\" \"https://myhost.com/root\" (\"user\", 1, \"resource\") \"https://myhost.com/root/user/1/resource\" \"https://myhost.com/root\" \"https://otherhost.org/foo\" ValueError <p>Parameters:</p> Name Type Description Default <code>relative_url</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(self, relative_url: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n    \"\"\"Convert a relative url to an absolute url.\n\n    Given a `relative_url`, return the matching absolute url, based on the `base_url` that is\n    configured for this API.\n\n    The result of this method is different from a standard `urljoin()`, because a relative_url\n    that starts with a \"/\" will not override the path from the base url. You can also pass an\n    iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n    may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n    any other type (which will be converted to `str` first, using the `str() function`). See the\n    table below for example results which would exhibit most cases:\n\n    | base_url | relative_url | result_url |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | b\"/path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | \"path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | None | \"https://myhost.com/root\" |\n    | \"https://myhost.com/root\" |  (\"user\", 1, \"resource\") | \"https://myhost.com/root/user/1/resource\" |\n    | \"https://myhost.com/root\" | \"https://otherhost.org/foo\" | ValueError |\n\n    Args:\n      relative_url: a relative url\n\n    Returns:\n      the resulting absolute url\n\n    \"\"\"\n    url = relative_url\n\n    if self.base_url:\n        if url is not None:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part]\n                    )\n                except Exception as exc:\n                    msg = (\n                        \"Unexpected url type, please pass a relative path as string or\"\n                        \" bytes, or an iterable of string-able objects\"\n                    )\n                    raise TypeError(\n                        msg,\n                        type(url),\n                    ) from exc\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            if \"://\" in url:\n                msg = \"url must be relative to root_url\"\n                raise ValueError(msg)\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n        else:\n            url = self.base_url\n\n    if url is None or not isinstance(url, str):\n        msg = \"Unable to determine an absolute url.\"\n        raise ValueError(msg)\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.get","title":"<code>get(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that request() takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    url: None | str | bytes | Iterable[str | bytes | int] = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a GET request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        url: a url where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: Optional arguments that [request()][requests.request] takes.\n\n    Returns:\n        a [Response][requests.Response] object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"GET\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.post","title":"<code>post(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>an url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that <code>request</code> takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a POST request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: an url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: Optional arguments that ``request`` takes.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"POST\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.patch","title":"<code>patch(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>an url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that <code>request</code> takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: an url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: Optional arguments that ``request`` takes.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PATCH\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.put","title":"<code>put(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PUT\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.ApiClient.delete","title":"<code>delete(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"DELETE\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseOAuth2RenewableTokenAuth","title":"<code>BaseOAuth2RenewableTokenAuth</code>","text":"<p>             Bases: <code>BearerAuth</code></p> <p>Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.</p> <p>In addition to adding a properly formatted <code>Authorization</code> header, this will obtain a new token once the current token is expired. Expiration is detected based on the <code>expires_in</code> hint returned by the AS. A configurable <code>leeway</code>, in number of seconds, will make sure that a new token is obtained some seconds before the actual expiration is reached. This may help in situations where the client, AS and RS have slightly offset clocks.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client</p> required <code>token</code> <code>None | BearerToken | str</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds</p> <code>20</code> <code>token_kwargs</code> <code>Any</code> <p>additional kwargs to include in token requests</p> <code>{}</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class BaseOAuth2RenewableTokenAuth(BearerAuth):\n    \"\"\"Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.\n\n    In addition to adding a properly formatted `Authorization` header, this will obtain a new token\n    once the current token is expired. Expiration is detected based on the `expires_in` hint\n    returned by the AS. A configurable `leeway`, in number of seconds, will make sure that a new\n    token is obtained some seconds before the actual expiration is reached. This may help in\n    situations where the client, AS and RS have slightly offset clocks.\n\n    Args:\n        client: an OAuth2Client\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds\n        token_kwargs: additional kwargs to include in token requests\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        token: None | BearerToken | str = None,\n        leeway: int = 20,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(token)\n        self.client = client\n        self.leeway = leeway\n        self.token_kwargs = token_kwargs\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        token = self.token\n        if token is None or token.is_expired(self.leeway):\n            self.renew_token()\n        return super().__call__(request)\n\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new Bearer Token.\n\n        Subclasses should implement this.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def forget_token(self) -&gt; None:\n        \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n        self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseOAuth2RenewableTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new Bearer Token.</p> <p>Subclasses should implement this.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n    \"\"\"Obtain a new Bearer Token.\n\n    Subclasses should implement this.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseOAuth2RenewableTokenAuth.forget_token","title":"<code>forget_token()</code>","text":"<p>Forget the current token, forcing a renewal on the next HTTP request.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def forget_token(self) -&gt; None:\n    \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n    self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerAuth","title":"<code>BearerAuth</code>","text":"<p>             Bases: <code>AuthBase</code></p> <p>An Auth Handler that includes a Bearer Token in API calls, as defined in RFC6750$2.1.</p> <p>As a prerequisite to using this <code>AuthBase</code>, you have to obtain an access token manually. You most likely don't want to do that by yourself, but instead use an instance of OAuth2Client to do that for you. See the others Auth Handlers in this module, which will automatically obtain access tokens from an OAuth 2.x server.</p> Usage <pre><code>auth = BearerAuth(\"my_access_token\")\nresp = requests.get(\"https://my.api.local/resource\", auth=auth)\n</code></pre> <p>The HTTP request will look like: <pre><code>GET /resource HTTP/1.1\nHost: my.api.local\nAuthorization: Bearer my_access_token\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken | None</code> <p>a BearerToken or a string to use as token for this Auth Handler. If <code>None</code>, this Auth Handler is a no-op.</p> <code>None</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class BearerAuth(requests.auth.AuthBase):\n    \"\"\"An Auth Handler that includes a Bearer Token in API calls, as defined in [RFC6750$2.1].\n\n    As a prerequisite to using this `AuthBase`, you have to obtain an access token manually.\n    You most likely don't want to do that by yourself, but instead use an instance of\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to do that for you.\n    See the others Auth Handlers in this module, which will automatically obtain\n    access tokens from an OAuth 2.x server.\n\n    [RFC6750$2.1]: https://datatracker.ietf.org/doc/html/rfc6750#section-2.1\n\n    Usage:\n        ```python\n        auth = BearerAuth(\"my_access_token\")\n        resp = requests.get(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n        The HTTP request will look like:\n        ```\n        GET /resource HTTP/1.1\n        Host: my.api.local\n        Authorization: Bearer my_access_token\n        ```\n\n    Args:\n        token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string\n            to use as token for this Auth Handler. If `None`, this Auth Handler is a no-op.\n\n    \"\"\"\n\n    def __init__(self, token: str | BearerToken | None = None) -&gt; None:\n        self.token = token  # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed\n\n    @property\n    def token(self) -&gt; BearerToken | None:\n        \"\"\"Return the [BearerToken] that is used for authorization against the API.\n\n        Returns:\n            the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this\n            AuthHandler.\n\n        \"\"\"\n        return self._token\n\n    @token.setter\n    def token(self, token: str | BearerToken | None) -&gt; None:\n        \"\"\"Change the access token used with this AuthHandler.\n\n        Accepts a [BearerToken][requests_oauth2client.tokens.BearerToken] or an access token as\n        `str`.\n\n        Args:\n            token: an access token to use for this Auth Handler\n\n        \"\"\"\n        if token is not None and not isinstance(token, BearerToken):\n            token = BearerToken(token)\n        self._token = token\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in the request.\n\n        If the configured token is an instance of BearerToken with an expires_at attribute, raises\n        [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access\n        token is expired.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in\n            Authorization Header\n\n        \"\"\"\n        if self.token is None:\n            return request\n        if self.token.is_expired():\n            raise ExpiredAccessToken(self.token)\n        request.headers[\"Authorization\"] = self.token.authorization_header()\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerAuth.token","title":"<code>token: BearerToken | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the [BearerToken] that is used for authorization against the API.</p> <p>Returns:</p> Type Description <code>BearerToken | None</code> <p>the configured BearerToken used with this</p> <code>BearerToken | None</code> <p>AuthHandler.</p>"},{"location":"api/#requests_oauth2client.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>             Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer token, and can automatically refresh it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to refresh tokens.</p> required <code>token</code> <code>None | BearerToken | str</code> <p>a access token that has been previously obtained</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken(     access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\" )  # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2AccessTokenAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as\n    Bearer token, and can automatically refresh it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a\n    [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a refresh_token. If a\n    refresh_token and an expiration date are available, this Auth Handler will automatically refresh\n    the access token once it is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens.\n        token: a access token that has been previously obtained\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        token = BearerToken(\n            access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\"\n        )  # obtain a BearerToken any way you see fit, including a refresh token\n        oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth)\n        ````\n\n    \"\"\"\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token, using the Refresh Token, if available.\"\"\"\n        if self.token and self.token.refresh_token and self.client is not None:\n            self.token = self.client.refresh_token(refresh_token=self.token.refresh_token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AccessTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token, using the Refresh Token, if available.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token, using the Refresh Token, if available.\"\"\"\n    if self.token and self.token.refresh_token and self.client is not None:\n        self.token = self.client.refresh_token(refresh_token=self.token.refresh_token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>             Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>code</code> <code>str | AuthorizationResponse</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\"  # you must obtain this code yourself resp = requests.post(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code)) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2AuthorizationCodeAuth(OAuth2AccessTokenAuth):\n    \"\"\"Authentication handler for the Authorization Code grant.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\"  # you must obtain this code yourself\n        resp = requests.post(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ````\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        code: str | AuthorizationResponse,\n        leeway: int = 20,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(client, token=None, leeway=leeway, **token_kwargs)\n        self.code: str | AuthorizationResponse | None = code\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in\n            Authorization Header\n\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n        \"\"\"Obtain the initial access token with the authorization_code grant.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Obtain the initial access token with the authorization_code grant.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n    \"\"\"Obtain the initial access token with the authorization_code grant.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>             Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2ClientCredentialsAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"An Auth Handler for the Client Credentials grant.\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access Tokens from an OAuth\n    2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current\n    one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n\n    \"\"\"\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>             Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = client.device_authorization() auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=auth) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2DeviceCodeAuth(OAuth2AccessTokenAuth):\n    \"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be\n    able to get a token from the AS Token Endpoint just before the first request using this Auth\n    Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ````\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        leeway: int = 20,\n        interval: int = 5,\n        expires_in: int = 360,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(client=client, leeway=leeway, token=None, **token_kwargs)\n        self.device_code: str | DeviceAuthorizationResponse | None = device_code\n        self.interval = interval\n        self.expires_in = expires_in\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            while self.token is None:\n                self.token = pooling_job()\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        while self.token is None:\n            self.token = pooling_job()\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ResourceOwnerPasswordAuth","title":"<code>OAuth2ResourceOwnerPasswordAuth</code>","text":"<p>             Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Authentication Handler for the Resource Owner Password Flow.</p> <p>This Requests Auth handler implementation exchanges the user credentials for an Access Token, then automatically obtains a new one once it is expired.</p> <p>Note that this flow is considered deprecated, and the Authorization Code flow should be used whenever possible. Among other bad things, ROPC does not support SSO nor MFA and depends on the user typing its credentials directly inside the application instead of on a dedicated login page, which makes it totally insecure for 3rd party apps.</p> <p>It needs the username and password and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens</p> required <code>username</code> <code>str</code> <p>the username</p> required <code>password</code> <code>str</code> <p>the user password</p> required <code>leeway</code> <code>int</code> <p>an amount of time, in seconds</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2ResourceOwnerPasswordAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"Authentication Handler for the [Resource Owner Password Flow](https://www.rfc-editor.org/rfc/rfc6749#section-4.3).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges the user\n    credentials for an Access Token, then automatically obtains a new one once it is expired.\n\n    Note that this flow is considered *deprecated*, and the Authorization Code flow should be\n    used whenever possible. Among other bad things, ROPC does not support SSO nor MFA and\n    depends on the user typing its credentials directly inside the application instead of on a\n    dedicated login page, which makes it totally insecure for 3rd party apps.\n\n    It needs the username and password and an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from\n    the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain\n            Access Tokens\n        username: the username\n        password: the user password\n        leeway: an amount of time, in seconds\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        username: str,\n        password: str,\n        leeway: int = 20,\n        **token_kwargs: Any,\n    ):\n        super().__init__(client=client, leeway=leeway, **token_kwargs)\n        self.username = username\n        self.password = password\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n        self.token = self.client.resource_owner_password(\n            username=self.username,\n            password=self.password,\n            **self.token_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2ResourceOwnerPasswordAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Exchange the user credentials for an Access Token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n    self.token = self.client.resource_owner_password(\n        username=self.username,\n        password=self.password,\n        **self.token_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represent an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if <code>...</code> (default), a random <code>state</code> parameter will be generated for you.   You may pass your own <code>state</code> as <code>str</code>, or set it to <code>None</code> so that the <code>state</code> parameter   will not be included in the request. You may access that state in the <code>state</code> attribute   from this request.</li> <li><code>nonce</code>: if <code>...</code> (default) and <code>scope</code> includes 'openid', a random <code>nonce</code> will be   generated and included in the request. You may access that <code>nonce</code> in the <code>nonce</code> attribute   from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>,   a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated,   and the <code>code_challenge</code> will be included in the request.   You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the   appropriate <code>code_challenge</code> will be included in the request, according to the   <code>code_challenge_method</code>.</li> <li><code>authorization_response_iss_parameter_supported</code> and <code>issuer</code>:    those are used for Server Issuer Identification. If <code>\u00ecssuer</code> is set and an issuer is    included in the Authorization Response, then the consistency between those 2 values will be    checked when using <code>validate_callback()</code>. If issuer is not included in the response, and    <code>authorization_response_iss_parameter_supported</code> is <code>False</code> (default), then no issuer check    is performed. Set <code>authorization_response_iss_parameter_supported</code>    to <code>True</code> to enforce server identification: if no issuer is included in the Authorization    Response, then an error will be raised instead.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>'code'</code> <code>state</code> <code>str | ellipsis | None</code> <p>the state to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>the nonce to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>str | None</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>'S256'</code> <code>acr_values</code> <code>str | Iterable[str] | None</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationRequest:\n    \"\"\"Represent an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a\n    state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization\n    Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    - `state`: if `...` (default), a random `state` parameter will be generated for you.\n      You may pass your own `state` as `str`, or set it to `None` so that the `state` parameter\n      will not be included in the request. You may access that state in the `state` attribute\n      from this request.\n    - `nonce`: if `...` (default) and `scope` includes 'openid', a random `nonce` will be\n      generated and included in the request. You may access that `nonce` in the `nonce` attribute\n      from this request.\n    - `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`,\n      a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated,\n      and the `code_challenge` will be included in the request.\n      You may pass your own `code_verifier` as a `str` parameter, in which case the\n      appropriate `code_challenge` will be included in the request, according to the\n      `code_challenge_method`.\n    - `authorization_response_iss_parameter_supported` and `issuer`:\n       those are used for Server Issuer Identification. If `\u00ecssuer` is set and an issuer is\n       included in the Authorization Response, then the consistency between those 2 values will be\n       checked when using `validate_callback()`. If issuer is not included in the response, and\n       `authorization_response_iss_parameter_supported` is `False` (default), then no issuer check\n       is performed. Set `authorization_response_iss_parameter_supported`\n       to `True` to enforce server identification: if no issuer is included in the Authorization\n       Response, then an error will be raised instead.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization\n            Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `...` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `...` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request.\n            If left as `None` and `code_challenge_method` is set, a valid code_verifier\n            will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n\n    \"\"\"\n\n    authorization_endpoint: str\n\n    client_id: str = field(metadata={\"query\": True})\n    redirect_uri: str | None = field(metadata={\"query\": True}, default=None)\n    scope: tuple[str, ...] | None = field(metadata={\"query\": True}, default=(\"openid\",))\n    response_type: str = field(metadata={\"query\": True}, default=\"code\")\n    state: str | None = field(metadata={\"query\": True}, default=None)\n    nonce: str | None = field(metadata={\"query\": True}, default=None)\n    code_challenge_method: str | None = field(metadata={\"query\": True}, default=\"S256\")\n    acr_values: tuple[str, ...] | None = field(metadata={\"query\": True}, default=None)\n    max_age: int | None = field(metadata={\"query\": True}, default=None)\n    kwargs: dict[str, Any] = Factory(dict)\n\n    code_verifier: str | None = None\n    code_challenge: str | None = field(init=False, metadata={\"query\": True})\n    authorization_response_iss_parameter_supported: bool = False\n    issuer: str | None = None\n\n    exception_classes: ClassVar[dict[str, type[Exception]]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n        \"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n        \"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        redirect_uri: str | None = None,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = \"code\",\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        code_challenge_method: str | None = \"S256\",\n        acr_values: str | Iterable[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            msg = (\n                \"When 'authorization_response_iss_parameter_supported' is `True`, you must\"\n                \" provide the expected `issuer` as parameter.\"\n            )\n            raise ValueError(msg)\n\n        if state is ...:\n            state = self.generate_state()\n        if state is not None and not isinstance(state, str):\n            state = str(state)  # pragma: no cover\n\n        if nonce is ...:\n            nonce = self.generate_nonce() if scope is not None and \"openid\" in scope else None\n        if nonce is not None and not isinstance(nonce, str):\n            nonce = str(nonce)  # pragma: no cover\n\n        if not scope:\n            scope = None\n\n        if scope is not None:\n            scope = tuple(scope.split(\" \")) if isinstance(scope, str) else tuple(scope)\n\n        if acr_values is not None:\n            acr_values = tuple(acr_values.split()) if isinstance(acr_values, str) else tuple(acr_values)\n\n        if max_age is not None and max_age &lt; 0:\n            msg = \"The `max_age` parameter is a number of seconds and cannot be negative.\"\n            raise ValueError(msg)\n\n        if \"code_challenge\" in kwargs:\n            msg = (\n                \"A `code_challenge` must not be passed as parameter. Pass the `code_verifier`\"\n                \" instead, and the appropriate `code_challenge` will automatically be derived\"\n                \" from it and included in the request, based on `code_challenge_method`.\"\n            )\n            raise ValueError(msg)\n\n        code_challenge: str | None = None\n        if code_challenge_method:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n            code_challenge = PkceUtils.derive_challenge(code_verifier, code_challenge_method)\n        else:\n            code_verifier = None\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            issuer=issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=code_challenge_method,\n            acr_values=acr_values,\n            max_age=max_age,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            kwargs=kwargs,\n        )\n        object.__setattr__(self, \"code_challenge\", code_challenge)\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the full argument dict.\n\n        This can be used to serialize this request and/or to initialize a similar request.\n\n        \"\"\"\n        d = asdict(self)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return d\n\n    @property\n    def args(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict with all the query parameters from this AuthorizationRequest.\n\n        Returns:\n            a dict of parameters\n\n        \"\"\"\n        d = {field.name: getattr(self, field.name) for field in fields(type(self)) if field.metadata.get(\"query\")}\n        if d[\"scope\"]:\n            d[\"scope\"] = \" \".join(d[\"scope\"])\n        d.update(self.kwargs)\n\n        return {key: val for key, val in d.items() if val is not None}\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization Request, and return\n        an\n        [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting\n        the returned `code` and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the\n                query parameters (still encoded as x-www-form-urlencoded).\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MismatchingIssuer: if the 'iss' received from the response does not match the\n                expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            NotImplementedError: if response_type anything else than 'code'.\n\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer()\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if \"code\" in self.response_type:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode()\n        else:\n            raise NotImplementedError()\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            **response_url.args,\n        )\n\n    def sign_request_jwt(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n    ) -&gt; SignedJwt:\n        \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed request.\n                If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n        **kwargs: Any,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, don't use an 'exp' claim.\n            kwargs: additional query parameters to include in the signed authorization request\n\n        Returns:\n            the signed Authorization Request\n\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n            **kwargs,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; JweCompact:\n        \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Error handler for Authorization Response errors.\n\n        Triggered by\n        [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n        if the response uri contains an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method\n            will most likely raise exceptions instead.\n\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(error, error_description, error_uri)\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args=self.args,\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.args","title":"<code>args: dict[str, Any]</code>  <code>property</code>","text":"<p>Return a dict with all the query parameters from this AuthorizationRequest.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of parameters</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n    \"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n    \"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the full argument dict.</p> <p>This can be used to serialize this request and/or to initialize a similar request.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the full argument dict.\n\n    This can be used to serialize this request and/or to initialize a similar request.\n\n    \"\"\"\n    d = asdict(self)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return d\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters (still encoded as x-www-form-urlencoded).</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MismatchingIssuer</code> <p>if the 'iss' received from the response does not match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>NotImplementedError</code> <p>if response_type anything else than 'code'.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization Request, and return\n    an\n    [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting\n    the returned `code` and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the\n            query parameters (still encoded as x-www-form-urlencoded).\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MismatchingIssuer: if the 'iss' received from the response does not match the\n            expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        NotImplementedError: if response_type anything else than 'code'.\n\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer()\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if \"code\" in self.response_type:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode()\n    else:\n        raise NotImplementedError()\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>an optional number of seconds of validity for the signed request. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n) -&gt; SignedJwt:\n    \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed request.\n            If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None, **kwargs)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional query parameters to include in the signed authorization request</p> <code>{}</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n    **kwargs: Any,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, don't use an 'exp' claim.\n        kwargs: additional query parameters to include in the signed authorization request\n\n    Returns:\n        the signed Authorization Request\n\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; JweCompact:\n    \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>a <code>RequestParameterAuthorizationRequest</code>, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method</p> <code>AuthorizationResponse</code> <p>will most likely raise exceptions instead.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Error handler for Authorization Response errors.\n\n    Triggered by\n    [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n    if the response uri contains an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method\n        will most likely raise exceptions instead.\n\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(error, error_description, error_uri)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n    \"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client-\n    side. This class is here to help you do that.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[AuthorizationRequest], str] | None = None,\n        loader: Callable[[str], AuthorizationRequest] | None = None,\n    ):\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n        base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(azr)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n\n    @staticmethod\n    def default_loader(\n        serialized: str, azr_class: type[AuthorizationRequest] = AuthorizationRequest\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n            azr_class: the class to deserialize the Authorization Request to\n\n        Returns:\n            an AuthorizationRequest\n\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n        \"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n    base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(azr)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>  <code>staticmethod</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <code>azr_class</code> <code>type[AuthorizationRequest]</code> <p>the class to deserialize the Authorization Request to</p> <code>AuthorizationRequest</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_loader(\n    serialized: str, azr_class: type[AuthorizationRequest] = AuthorizationRequest\n) -&gt; AuthorizationRequest:\n    \"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n        azr_class: the class to deserialize the Authorization Request to\n\n    Returns:\n        an AuthorizationRequest\n\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n    \"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:</p> <ul> <li>all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional    parameters such as <code>state</code>.</li> <li>the redirect_uri that was used for the Authorization Request</li> <li>the code_verifier matching the code_challenge that was used for the Authorization Request</li> </ul> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>the authorization code returned by the AS</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>state</code> <code>str | None</code> <p>the state returned by the AS</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationResponse:\n    \"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS to the client's redirection\n    endpoint (redirect_uri) after an Authorization Request. This Response is typically created with\n    a call to `AuthorizationRequest.validate_callback()` once the call to the client Redirection\n    Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:\n\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional\n       parameters such as `state`.\n     - the redirect_uri that was used for the Authorization Request\n     - the code_verifier matching the code_challenge that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching\n    `AuthorizationRequest`. All other parameters including `code` and `state` must be those\n    extracted from the Authorization Response parameters.\n\n    Args:\n        code: the authorization code returned by the AS\n        redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest\n        code_verifier: the code_verifier matching the code_challenge that was passed as\n            parameter in the AuthorizationRequest\n        state: the state returned by the AS\n        **kwargs: other parameters as returned by the AS\n\n    \"\"\"\n\n    code: str\n    redirect_uri: str | None = None\n    code_verifier: str | None = None\n    state: str | None = None\n    nonce: str | None = None\n    acr_values: tuple[str, ...] | None = None\n    max_age: int | None = None\n    issuer: str | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    def __init__(\n        self,\n        *,\n        code: str,\n        redirect_uri: str | None = None,\n        code_verifier: str | None = None,\n        state: str | None = None,\n        nonce: str | None = None,\n        acr_values: str | Sequence[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        **kwargs: str,\n    ):\n        if not acr_values:\n            acr_values = None\n        elif isinstance(acr_values, str):\n            acr_values = tuple(acr_values.split(\" \"))\n        else:\n            acr_values = tuple(acr_values)\n\n        self.__attrs_init__(\n            code=code,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n            state=state,\n            nonce=nonce,\n            acr_values=acr_values,\n            max_age=max_age,\n            issuer=issuer,\n            kwargs=kwargs,\n        )\n\n    def __getattr__(self, item: str) -&gt; str | None:\n        \"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n\n        \"\"\"\n        return self.kwargs.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.CodeChallengeMethods","title":"<code>CodeChallengeMethods</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>PKCE Code Challenge Methods.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class CodeChallengeMethods(str, Enum):\n    \"\"\"PKCE Code Challenge Methods.\"\"\"\n\n    plain = \"plain\"\n    S256 = \"S256\"\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n    \"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n\n    \"\"\"\n\n    code_verifier_re = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n    \"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n        \"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a `code_verifier` ready to use for PKCE\n\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: str | bytes, method: str = \"S256\") -&gt; str:\n        \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `code_challenge` derived from the given verifier\n\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_re.match(verifier):\n            msg = f\"Invalid code verifier, does not match {cls.code_verifier_re}\"\n            raise ValueError(\n                msg,\n                verifier,\n            )\n\n        if method == \"S256\":\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        elif method == \"plain\":\n            return verifier\n        else:\n            msg = \"Unsupported code_challenge_method\"\n            raise ValueError(msg, method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = \"S256\") -&gt; tuple[str, str]:\n        \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `(code_verifier, code_challenge)` tuple.\n\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(cls, verifier: str, challenge: str, method: str = \"S256\") -&gt; bool:\n        \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n\n        \"\"\"\n        return cls.code_verifier_re.match(verifier) is not None and cls.derive_challenge(verifier, method) == challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.code_verifier_re","title":"<code>code_verifier_re = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_verifier</code> ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n    \"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a `code_verifier` ready to use for PKCE\n\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method='S256')</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str | bytes</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_challenge</code> derived from the given verifier</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: str | bytes, method: str = \"S256\") -&gt; str:\n    \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `code_challenge` derived from the given verifier\n\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_re.match(verifier):\n        msg = f\"Invalid code verifier, does not match {cls.code_verifier_re}\"\n        raise ValueError(\n            msg,\n            verifier,\n        )\n\n    if method == \"S256\":\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    elif method == \"plain\":\n        return verifier\n    else:\n        msg = \"Unsupported code_challenge_method\"\n        raise ValueError(msg, method)\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method='S256')</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and derive its <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a <code>(code_verifier, code_challenge)</code> tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = \"S256\") -&gt; tuple[str, str]:\n    \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `(code_verifier, code_challenge)` tuple.\n\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method='S256')</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(cls, verifier: str, challenge: str, method: str = \"S256\") -&gt; bool:\n    \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n\n    \"\"\"\n    return cls.code_verifier_re.match(verifier) is not None and cls.derive_challenge(verifier, method) == challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>str</code> <p>the request JWT</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request: str\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ):\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request=request,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": self.request, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.RequestParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request_uri</code> <code>str</code> <p>the request_uri</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestUriParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request_uri: the request_uri\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request_uri: str\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request_uri: str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ):\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request_uri=request_uri,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>             Bases: <code>TokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> <p>auth=(\"client_id\", \"client_secret\") ) pool_job = BackChannelAuthenticationPoolingJob( client=client, auth_req_id=\"my_auth_req_id\" )</p> <pre><code>token = None while token is None: token = pool_job() ```\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationPoolingJob(TokenEndpointPoolingJob):\n    \"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\",\n    auth=(\"client_id\", \"client_secret\") ) pool_job = BackChannelAuthenticationPoolingJob(\n    client=client, auth_req_id=\"my_auth_req_id\" )\n\n        token = None while token is None: token = pool_job() ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        *,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ):\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse) and interval is None:\n            interval = auth_req_id.interval\n\n        super().__init__(\n            client=client,\n            interval=interval,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs,\n            **token_kwargs,\n        )\n        self.auth_req_id = auth_req_id\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n    \"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel\n    Authentication Request, such as `auth_req_id` (required), and the optional `expires_at`,\n    `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: datetime | None = None,\n        interval: int | None = 20,\n        **kwargs: Any,\n    ):\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n        derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n        this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or\n        `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n\n        \"\"\"\n        if key == \"expires_in\":\n            if self.expires_at is None:\n                return None\n            return int(self.expires_at.timestamp() - datetime.now(tz=timezone.utc).timestamp())\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n    derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n    this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.GrantType","title":"<code>GrantType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardized <code>grant_type</code> values.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class GrantType(str, Enum):\n    \"\"\"An enum of standardized `grant_type` values.\"\"\"\n\n    CLIENT_CREDENTIALS = \"client_credentials\"\n    AUTHORIZATION_CODE = \"authorization_code\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RESOURCE_OWNER_PASSWORD = \"password\"\n    TOKEN_EXCHANGE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    JWT_BEARER = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n    CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION = \"urn:openid:params:grant-type:ciba\"\n    DEVICE_CODE = \"urn:ietf:params:oauth:grant-type:device_code\"\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint. Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be:</p> <ul> <li>a requests.auth.AuthBase instance (which will be used as-is)</li> <li>a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost</li> <li>a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt,</li> <li>or a <code>client_id</code> which will use PublicApp authentication.</li> </ul> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID (use either this or <code>auth</code>)</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret (use either this or <code>auth</code>)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private_key to use for client authentication (use either this or <code>auth</code>)</p> <code>None</code> <code>revocation_endpoint</code> <code>str | None</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>str | None</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>str | None</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>str | None</code> <p>the Authorization Endpoint URI, used for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>str | None</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>str | None</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>str | None</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>'S256'</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if <code>True</code>, don't verify the validity of the endpoint urls that are passed as parameter.</p> <code>False</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@frozen(init=False)\nclass OAuth2Client:\n    \"\"\"An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised\n    Grant Types, and to communicate with the various backend endpoints like the Revocation,\n    Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials\n    (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint.\n    Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as\n    parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in\n    a browser. For authentication requests, see\n    [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. You\n    may use the method `authorization_request()` to generate `AuthorizationRequest`s with the\n    preconfigured `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint.\n            Can be:\n\n            - a [requests.auth.AuthBase][] instance (which will be used as-is)\n            - a tuple of `(client_id, client_secret)` which will initialize an instance\n            of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost]\n            - a `(client_id, jwk)` to initialize\n            a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt],\n            - or a `client_id` which will\n            use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n\n        client_id: client ID (use either this or `auth`)\n        client_secret: client secret (use either this or `auth`)\n        private_key: private_key to use for client authentication (use either this or `auth`)\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI, used for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests.\n            Useful if some extra parameters such as proxy or client certificate must be used\n            to connect to the AS.\n        testing: if `True`, don't verify the validity of the endpoint urls that are passed as parameter.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be\n            used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Usage:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            client_id=\"client_id\",\n            client_secret=\"client_secret\",\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n\n    \"\"\"\n\n    auth: requests.auth.AuthBase = field(converter=client_auth_factory)\n    token_endpoint: str = field()\n    revocation_endpoint: str | None = field()\n    introspection_endpoint: str | None = field()\n    userinfo_endpoint: str | None = field()\n    authorization_endpoint: str | None = field()\n    redirect_uri: str | None = field()\n    backchannel_authentication_endpoint: str | None = field()\n    device_authorization_endpoint: str | None = field()\n    pushed_authorization_request_endpoint: str | None = field()\n    jwks_uri: str | None = field()\n    authorization_server_jwks: JwkSet\n    issuer: str | None = field()\n    id_token_signed_response_alg: str | None = SignatureAlgs.RS256\n    id_token_encrypted_response_alg: str | None = None\n    id_token_decryption_key: Jwk | None = None\n    code_challenge_method: str | None = \"S256\"\n    authorization_response_iss_parameter_supported: bool = False\n    session: requests.Session = field(factory=requests.Session)\n    extra_metadata: dict[str, Any] = field(factory=dict)\n    testing: bool = False\n\n    bearer_token_class: type[BearerToken] = BearerToken\n\n    exception_classes: ClassVar[dict[str, type[Exception]]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    def __init__(  # noqa: PLR0913\n        self,\n        token_endpoint: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        revocation_endpoint: str | None = None,\n        introspection_endpoint: str | None = None,\n        userinfo_endpoint: str | None = None,\n        authorization_endpoint: str | None = None,\n        redirect_uri: str | None = None,\n        backchannel_authentication_endpoint: str | None = None,\n        device_authorization_endpoint: str | None = None,\n        pushed_authorization_request_endpoint: str | None = None,\n        jwks_uri: str | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        issuer: str | None = None,\n        id_token_signed_response_alg: str | None = SignatureAlgs.RS256,\n        id_token_encrypted_response_alg: str | None = None,\n        id_token_decryption_key: Jwk | dict[str, Any] | None = None,\n        code_challenge_method: str = \"S256\",\n        authorization_response_iss_parameter_supported: bool = False,\n        bearer_token_class: type[BearerToken] = BearerToken,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **extra_metadata: Any,\n    ):\n        if authorization_response_iss_parameter_supported and not issuer:\n            msg = (\n                \"If the Authorization Server supports Issuer Identification, as specified by\"\n                \" `authorization_response_iss_parameter_supported=True`, then you must specify\"\n                \" the expected `issuer` value with parameter `issuer`.\"\n            )\n            raise ValueError(msg)\n\n        auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n\n        if authorization_server_jwks is None:\n            authorization_server_jwks = JwkSet()\n        elif not isinstance(authorization_server_jwks, JwkSet):\n            authorization_server_jwks = JwkSet(authorization_server_jwks)\n\n        if id_token_decryption_key is not None and not isinstance(id_token_decryption_key, Jwk):\n            id_token_decryption_key = Jwk(id_token_decryption_key)\n\n        if id_token_decryption_key is not None and id_token_encrypted_response_alg is None:\n            if id_token_decryption_key.alg:\n                id_token_encrypted_response_alg = id_token_decryption_key.alg\n            else:\n                msg = (\n                    \"An ID Token decryption key has been provided but no decryption algorithm is defined.\"\n                    \" You can either pass an `id_token_encrypted_response_alg` parameter with the alg identifier,\"\n                    \" or include an `alg` attribute in the decryption key, if it is in Jwk format.\"\n                )\n                raise ValueError(msg)\n\n        if session is None:\n            session = requests.Session()\n\n        self.__attrs_init__(\n            testing=testing,\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            redirect_uri=redirect_uri,\n            backchannel_authentication_endpoint=backchannel_authentication_endpoint,\n            device_authorization_endpoint=device_authorization_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            issuer=issuer,\n            session=session,\n            auth=auth,\n            id_token_signed_response_alg=id_token_signed_response_alg,\n            id_token_encrypted_response_alg=id_token_encrypted_response_alg,\n            id_token_decryption_key=id_token_decryption_key,\n            code_challenge_method=code_challenge_method,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            bearer_token_class=bearer_token_class,\n            extra_metadata=extra_metadata,\n        )\n\n    @token_endpoint.validator\n    @revocation_endpoint.validator\n    @introspection_endpoint.validator\n    @userinfo_endpoint.validator\n    @authorization_endpoint.validator\n    @backchannel_authentication_endpoint.validator\n    @device_authorization_endpoint.validator\n    @pushed_authorization_request_endpoint.validator\n    @jwks_uri.validator\n    def validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an endpoint URI is suitable for use.\n\n        If you need to disable some checks (for AS testing purposes only!), provide a different\n        method here.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_endpoint_uri(uri)\n        except ValueError as exc:\n            msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n            raise ValueError(msg) from exc\n\n    @issuer.validator\n    def validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an Issuer identifier is suitable for use.\n\n        This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_issuer_uri(uri)\n        except ValueError as exc:\n            msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n            raise ValueError(msg) from exc\n\n    @property\n    def client_id(self) -&gt; str:\n        \"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        msg = \"This client uses a custom authentication method without client_id.\"\n        raise AttributeError(msg)  # pragma: no cover\n\n    @property\n    def client_secret(self) -&gt; str | None:\n        \"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n        \"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def _request(\n        self,\n        endpoint: str,\n        on_success: Callable[[requests.Response], T],\n        on_failure: Callable[[requests.Response], T],\n        accept: str = \"application/json\",\n        method: str = \"POST\",\n        **requests_kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Send a request to one of the endpoints.\n\n        This is a helper method that takes care of the following tasks:\n\n        - make sure the endpoint as been configured\n        - set `Accept: application/json` header\n        - send the HTTP POST request, then\n            - apply `on_success` to a successful response\n            - or apply `on_failure` otherwise\n        - return the result\n\n        Args:\n            endpoint: name of the endpoint to use\n            on_success: a callable to apply to successful responses\n            on_failure: a callable to apply to error responses\n            accept: the Accept header to include in the request\n            method: the HTTP method to use\n            **requests_kwargs: keyword arguments for the request\n\n        \"\"\"\n        endpoint_uri = self._require_endpoint(endpoint)\n        requests_kwargs.setdefault(\"headers\", {})\n        requests_kwargs[\"headers\"][\"Accept\"] = accept\n\n        response = self.session.request(\n            method,\n            endpoint_uri,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return on_success(response)\n\n        return on_failure(response)\n\n    def token_request(\n        self,\n        data: dict[str, Any],\n        timeout: int = 10,\n        **requests_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n          data: parameters to send to the token endpoint. Items with a `None`\n               or empty value will not be sent in the request.\n          timeout: a timeout value for the call\n          **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response, as\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n        \"\"\"\n        return self._request(\n            \"token_endpoint\",\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            on_success=self.parse_token_response,\n            on_failure=self.on_token_error,\n            **requests_kwargs,\n        )\n\n    def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n        responses returned by the Token Endpoint. Those responses contain an `access_token` and\n        additional attributes.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n            contents.\n\n        \"\"\"\n        try:\n            token_response = self.bearer_token_class(**response.json())\n        except Exception as response_class_exc:\n            try:\n                return self.on_token_error(response)\n            except Exception as token_error_exc:\n                raise token_error_exc from response_class_exc\n        else:\n            return token_response\n\n    def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n        Token Endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n            behaviour if needed.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidTokenResponse(response) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: str | Iterable[str] | None = None,\n        *,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n        Returns:\n            a TokenResponse\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                msg = \"Unsupported scope value\"\n                raise ValueError(msg) from exc\n\n        data = dict(grant_type=GrantType.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: str | AuthorizationResponse,\n        *,\n        validate: bool = True,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        Args:\n             code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n             validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n             requests_kwargs: additional parameters for the call to requests\n             **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        azr: AuthorizationResponse | None = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=GrantType.AUTHORIZATION_CODE, code=code, **token_kwargs)\n        token = self.token_request(data, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            return token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        Args:\n            refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n                That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: additional parameters for the call to `requests`\n            **token_kwargs: additional parameters for the token endpoint,\n                alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n                msg = \"This BearerToken doesn't have a refresh_token\"\n                raise ValueError(msg)\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=GrantType.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: str | DeviceAuthorizationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n        or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: a device code, or a `DeviceAuthorizationResponse`\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                msg = \"This DeviceAuthorizationResponse doesn't have a device_code\"\n                raise ValueError(msg)\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantType.DEVICE_CODE,\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                msg = \"This `BackChannelAuthenticationResponse` doesn't have an `auth_req_id`\"\n                raise ValueError(msg)\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantType.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        subject_token: str | BearerToken | IdToken,\n        subject_token_type: str | None = None,\n        actor_token: None | str | BearerToken | IdToken = None,\n        actor_token_type: str | None = None,\n        requested_token_type: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n        `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: the subject token to exchange for a new token.\n            subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: the actor token to include in the request, if any.\n            actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: a token type identifier for the requested token.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError:\n            msg = \"Cannot determine the kind of 'subject_token' you provided. Please specify a 'subject_token_type'.\"\n            raise TypeError(msg) from None\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError:\n                msg = \"Cannot determine the kind of 'actor_token' you provided. Please specify an 'actor_token_type'.\"\n                raise TypeError(msg) from None\n\n        data = dict(\n            grant_type=GrantType.TOKEN_EXCHANGE,\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Jwt | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using a JWT as authorization grant.\n\n        This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=GrantType.JWT_BEARER,\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantType.RESOURCE_OWNER_PASSWORD,\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        *,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = \"code\",\n        redirect_uri: str | None = None,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: the `scope` to use\n            response_type: the `response_type` to use\n            redirect_uri: the `redirect_uri` to include in the request. By default,\n                the `redirect_uri` defined at init time is used.\n            state: the `state` parameter to use. Leave default to generate a random value.\n            nonce: a `nonce`. Leave default to generate a random value.\n            code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n            **kwargs: additional parameters to include in the auth request\n\n        Returns:\n            an AuthorizationRequest with the supplied parameters\n\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n        if not redirect_uri:\n            msg = (\n                \"No 'redirect_uri' defined for this client. You must either pass a redirect_uri\"\n                \" as parameter to this method, or include a redirect_uri when initializing your\"\n                \" OAuth2Client.\"\n            )\n            raise AttributeError(msg)\n\n        if response_type != \"code\":\n            msg = \"Only response_type=code is supported.\"\n            raise ValueError(msg)\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self,\n        authorization_request: AuthorizationRequest,\n        requests_kwargs: dict[str, Any] | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: the authorization request to send\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        return self._request(\n            \"pushed_authorization_request_endpoint\",\n            data=authorization_request.args,\n            auth=self.auth,\n            on_success=self.parse_pushed_authorization_response,\n            on_failure=self.on_pushed_authorization_request_error,\n            **requests_kwargs,\n        )\n\n    def parse_pushed_authorization_response(\n        self, response: requests.Response\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n        Args:\n            response: the `requests.Response` returned by the PAR endpoint\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest instance\n\n        \"\"\"\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n        )\n\n    def on_pushed_authorization_request_error(\n        self, response: requests.Response\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: the HTTP response as returned by the AS PAR endpoint.\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n        Raises:\n            EndpointError: a subclass of this error depending on the error returned by the AS\n            InvalidPushedAuthorizationResponse: if the returned response is not following the\n            specifications UnknownTokenEndpointError: for unknown/unhandled errors\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response) from exc\n        raise exception\n\n    def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n        \"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n        the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n\n        \"\"\"\n        return self._request(\n            \"userinfo_endpoint\",\n            auth=BearerAuth(access_token),\n            on_success=self.parse_userinfo_response,\n            on_failure=self.on_userinfo_error,\n        )\n\n    def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n        response from the UserInfo endpoint, this will extract and return its JSON content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            the parsed JSON content from this response.\n\n        \"\"\"\n        return resp.json()\n\n    def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse UserInfo error response.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            nothing, raises exception instead.\n\n        \"\"\"\n        resp.raise_for_status()\n\n    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise ValueError(msg)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"Cannot determine the type of provided token when it is a bare str. Please specify a token_type.\"\n                raise ValueError(msg)\n            elif isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            elif isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            else:\n                msg = \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\"\n                raise TypeError(\n                    msg,\n                    type(token),\n                )\n        elif token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = \"The supplied token is not a BearerToken or a string representation of it.\"\n                raise TypeError(\n                    msg,\n                    type(token),\n                )\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        elif token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = \"The supplied BearerToken doesn't have a refresh_token.\"\n                raise ValueError(msg)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        elif token_type == \"id_token\":\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = \"The supplied token is not an IdToken or a string representation of it.\"\n                raise TypeError(\n                    msg,\n                    type(token),\n                )\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n        else:\n            return {\n                \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n                \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n                \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n            }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: BearerToken | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=TokenType.ACCESS_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured\n            revocation endpoint.\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                raise ValueError(msg)\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=TokenType.REFRESH_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n            non-standardised error is returned.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                raise ValueError(msg)\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            \"revocation_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=lambda resp: True,\n            on_failure=self.on_revocation_error,\n            **requests_kwargs,\n        )\n\n    def on_revocation_error(self, response: requests.Response) -&gt; bool:\n        \"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n        revocation endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the\n            revocation response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception:\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                    raise ValueError(msg)\n                else:\n                    token = token.refresh_token\n            else:\n                msg = (\n                    \"Invalid `token_type_hint`. To test arbitrary `token_type_hint` values,\"\n                    \" you must provide `token` as a `str`.\"\n                )\n                raise ValueError(msg)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            \"introspection_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n\n    def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n        \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response. This decodes the JSON content if possible, otherwise it\n        returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response) -&gt; Any:\n        \"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n\n        Returns:\n            usually raises exceptions. A subclass can return a default response instead.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception as exc:\n            raise UnknownIntrospectionError(response) from exc\n        raise exception\n\n    def backchannel_authentication_request(  # noqa: PLR0913\n        self,\n        scope: None | str | Iterable[str] = \"openid\",\n        *,\n        client_notification_token: str | None = None,\n        acr_values: None | str | Iterable[str] = None,\n        login_hint_token: str | None = None,\n        id_token_hint: str | None = None,\n        login_hint: str | None = None,\n        binding_message: str | None = None,\n        user_code: str | None = None,\n        requested_expiry: int | None = None,\n        private_jwk: Jwk | dict[str, Any] | None = None,\n        alg: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n\n        \"\"\"\n        if not (login_hint or login_hint_token or id_token_hint):\n            msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise ValueError(msg)\n\n        if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n            msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise ValueError(msg)\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                msg = \"Unsupported `scope` value\"\n                raise ValueError(msg) from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                msg = \"Unsupported `acr_values`\"\n                raise ValueError(msg) from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        return self._request(\n            \"backchannel_authentication_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_backchannel_authentication_response,\n            on_failure=self.on_backchannel_authentication_error,\n            **requests_kwargs,\n        )\n\n    def parse_backchannel_authentication_response(\n        self, response: requests.Response\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response) from exc\n\n    def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n        error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response) from exc\n        raise exception\n\n    def authorize_device(\n        self, requests_kwargs: dict[str, Any] | None = None, **data: Any\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            a Device Authorization Response\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        return self._request(\n            \"device_authorization_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_device_authorization_response,\n            on_failure=self.on_device_authorization_error,\n            **requests_kwargs,\n        )\n\n    def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n\n        \"\"\"\n        device_authorization_response = DeviceAuthorizationResponse(**response.json())\n        return device_authorization_response\n\n    def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint, when that response is\n        an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n        \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n        available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no `jwks_uri` is configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        jwks = self._request(\n            \"jwks_uri\",\n            auth=None,\n            method=\"GET\",\n            on_success=lambda resp: resp.json(),\n            on_failure=lambda resp: resp.raise_for_status(),\n            **requests_kwargs,\n        )\n        self.authorization_server_jwks.update(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: str | None = None,\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n        This will retrieve the standardised metadata document available at `url`, and will extract\n        all Endpoint Uris from that document, will fetch the current public keys from its\n        `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n        Args:\n             url: the url where the server metadata will be retrieved\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             session: a `requests.Session` to use to retrieve the document and initialise the client with\n             issuer: if an issuer is given, check that it matches the one from the retrieved document\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional keyword parameters to pass to OAuth2Client\n\n        Returns:\n            an OAuth2Client with endpoint initialised based on the obtained metadata\n\n        Raises:\n            ValueError: if neither `url` nor `issuer` are suitable urls\n            requests.HTTPError: if an error happens while fetching the documents\n\n        \"\"\"\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            msg = \"Please specify at least one of `issuer` or `url`\"\n            raise ValueError(msg)\n\n        validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri:\n            jwks = JwkSet(session.get(jwks_uri).json())\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            testing=testing,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(  # noqa: PLR0913\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional args that will be passed to OAuth2Client\n\n        Returns:\n            an `OAuth2Client`\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"The https parameter is deprecated.\"\n                \" To disable endpoint uri validation, set `testing=True` when initializing your OAuth2Client.\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = \"Mismatching issuer value in discovery document: \"\n            raise ValueError(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        elif issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(\"token_endpoint\")\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise ValueError(msg)\n        authorization_endpoint = discovery.get(\"authorization_endpoint\")\n        revocation_endpoint = discovery.get(\"revocation_endpoint\")\n        introspection_endpoint = discovery.get(\"introspection_endpoint\")\n        userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri is not None:\n            validate_endpoint_uri(jwks_uri, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\", False\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; OAuth2Client:\n        \"\"\"Allow using `OAuth2Client` as a context-manager.\n\n        The Authorization Server public keys are retrieved on `__enter__`.\n\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; bool:  # noqa: D105\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n        \"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            msg = (\n                f\"No '{endpoint}' defined for this client. Please provide the URL for that\"\n                f\" endpoint when initializing your {self.__class__.__name__} instance.\"\n            )\n            raise AttributeError(msg)\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_id","title":"<code>client_id: str</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_secret","title":"<code>client_secret: str | None</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_jwks","title":"<code>client_jwks: JwkSet</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.OAuth2Client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(attribute, uri)</code>","text":"<p>Validate that an endpoint URI is suitable for use.</p> <p>If you need to disable some checks (for AS testing purposes only!), provide a different method here.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@token_endpoint.validator\n@revocation_endpoint.validator\n@introspection_endpoint.validator\n@userinfo_endpoint.validator\n@authorization_endpoint.validator\n@backchannel_authentication_endpoint.validator\n@device_authorization_endpoint.validator\n@pushed_authorization_request_endpoint.validator\n@jwks_uri.validator\ndef validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an endpoint URI is suitable for use.\n\n    If you need to disable some checks (for AS testing purposes only!), provide a different\n    method here.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_endpoint_uri(uri)\n    except ValueError as exc:\n        msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n        raise ValueError(msg) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.validate_issuer_uri","title":"<code>validate_issuer_uri(attribute, uri)</code>","text":"<p>Validate that an Issuer identifier is suitable for use.</p> <p>This is the same check as an endpoint URI, but the path may be (and usually is) empty.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@issuer.validator\ndef validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an Issuer identifier is suitable for use.\n\n    This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_issuer_uri(uri)\n    except ValueError as exc:\n        msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n        raise ValueError(msg) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.token_request","title":"<code>token_request(data, timeout=10, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a <code>None</code>    or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response, as</p> <code>BearerToken</code> <p><code>BearerToken</code> instance.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self,\n    data: dict[str, Any],\n    timeout: int = 10,\n    **requests_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n      data: parameters to send to the token endpoint. Items with a `None`\n           or empty value will not be sent in the request.\n      timeout: a timeout value for the call\n      **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response, as\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n    \"\"\"\n    return self._request(\n        \"token_endpoint\",\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        on_success=self.parse_token_response,\n        on_failure=self.on_token_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those responses contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response</p> <code>BearerToken</code> <p>contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n    responses returned by the Token Endpoint. Those responses contain an `access_token` and\n    additional attributes.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n        contents.\n\n    \"\"\"\n    try:\n        token_response = self.bearer_token_class(**response.json())\n    except Exception as response_class_exc:\n        try:\n            return self.on_token_error(response)\n        except Exception as token_error_exc:\n            raise token_error_exc from response_class_exc\n    else:\n        return token_response\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_token_error","title":"<code>on_token_error(response)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a</p> <code>BearerToken</code> <p><code>BearerToken</code> to implement a default</p> <code>BearerToken</code> <p>behaviour if needed.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n    Token Endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n        behaviour if needed.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidTokenResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, *, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>str | Iterable[str] | None</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>. Common parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a TokenResponse</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: str | Iterable[str] | None = None,\n    *,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n    Returns:\n        a TokenResponse\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            msg = \"Unsupported scope value\"\n            raise ValueError(msg) from exc\n\n    data = dict(grant_type=GrantType.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, *, validate=True, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str | AuthorizationResponse</code> <p>an authorization code or an <code>AuthorizationResponse</code> to exchange for tokens</p> required <code>validate</code> <code>bool</code> <p>if <code>True</code>, validate the received ID Token (this works only if <code>code</code> is an AuthorizationResponse)</p> <code>True</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: str | AuthorizationResponse,\n    *,\n    validate: bool = True,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    Args:\n         code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n         validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n         requests_kwargs: additional parameters for the call to requests\n         **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    azr: AuthorizationResponse | None = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=GrantType.AUTHORIZATION_CODE, code=code, **token_kwargs)\n    token = self.token_request(data, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        return token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>a refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to <code>requests</code></p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    Args:\n        refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n            That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: additional parameters for the call to `requests`\n        **token_kwargs: additional parameters for the token endpoint,\n            alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n            msg = \"This BearerToken doesn't have a refresh_token\"\n            raise ValueError(msg)\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=GrantType.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.device_code","title":"<code>device_code(device_code, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a device code, or a <code>DeviceAuthorizationResponse</code></p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: str | DeviceAuthorizationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n    or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: a device code, or a `DeviceAuthorizationResponse`\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            msg = \"This DeviceAuthorizationResponse doesn't have a device_code\"\n            raise ValueError(msg)\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantType.DEVICE_CODE,\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: str | BackChannelAuthenticationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            msg = \"This `BackChannelAuthenticationResponse` doesn't have an `auth_req_id`\"\n            raise ValueError(msg)\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantType.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.token_exchange","title":"<code>token_exchange(subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>str | BearerToken | IdToken</code> <p>the subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>str | None</code> <p>a token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>None | str | BearerToken | IdToken</code> <p>the actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>str | None</code> <p>a token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>str | None</code> <p>a token type identifier for the requested token.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    subject_token: str | BearerToken | IdToken,\n    subject_token_type: str | None = None,\n    actor_token: None | str | BearerToken | IdToken = None,\n    actor_token_type: str | None = None,\n    requested_token_type: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n    `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: the subject token to exchange for a new token.\n        subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: the actor token to include in the request, if any.\n        actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: a token type identifier for the requested token.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError:\n        msg = \"Cannot determine the kind of 'subject_token' you provided. Please specify a 'subject_token_type'.\"\n        raise TypeError(msg) from None\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError:\n            msg = \"Cannot determine the kind of 'actor_token' you provided. Please specify an 'actor_token_type'.\"\n            raise TypeError(msg) from None\n\n    data = dict(\n        grant_type=GrantType.TOKEN_EXCHANGE,\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Jwt | str</code> <p>a JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Jwt | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using a JWT as authorization grant.\n\n    This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=GrantType.JWT_BEARER,\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantType.RESOURCE_OWNER_PASSWORD,\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorization_request","title":"<code>authorization_request(*, scope='openid', response_type='code', redirect_uri=None, state=..., nonce=..., code_verifier=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the <code>scope</code> to use</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the <code>response_type</code> to use</p> <code>'code'</code> <code>redirect_uri</code> <code>str | None</code> <p>the <code>redirect_uri</code> to include in the request. By default, the <code>redirect_uri</code> defined at init time is used.</p> <code>None</code> <code>state</code> <code>str | ellipsis | None</code> <p>the <code>state</code> parameter to use. Leave default to generate a random value.</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>a <code>nonce</code>. Leave default to generate a random value.</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the PKCE <code>code_verifier</code> to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters to include in the auth request</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest with the supplied parameters</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    *,\n    scope: None | str | Iterable[str] = \"openid\",\n    response_type: str = \"code\",\n    redirect_uri: str | None = None,\n    state: str | ellipsis | None = ...,  # noqa: F821\n    nonce: str | ellipsis | None = ...,  # noqa: F821\n    code_verifier: str | None = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n    \"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: the `scope` to use\n        response_type: the `response_type` to use\n        redirect_uri: the `redirect_uri` to include in the request. By default,\n            the `redirect_uri` defined at init time is used.\n        state: the `state` parameter to use. Leave default to generate a random value.\n        nonce: a `nonce`. Leave default to generate a random value.\n        code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n        **kwargs: additional parameters to include in the auth request\n\n    Returns:\n        an AuthorizationRequest with the supplied parameters\n\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n    if not redirect_uri:\n        msg = (\n            \"No 'redirect_uri' defined for this client. You must either pass a redirect_uri\"\n            \" as parameter to this method, or include a redirect_uri when initializing your\"\n            \" OAuth2Client.\"\n        )\n        raise AttributeError(msg)\n\n    if response_type != \"code\":\n        msg = \"Only response_type=code is supported.\"\n        raise ValueError(msg)\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request, requests_kwargs=None)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>the authorization request to send</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>the <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self,\n    authorization_request: AuthorizationRequest,\n    requests_kwargs: dict[str, Any] | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: the authorization request to send\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    return self._request(\n        \"pushed_authorization_request_endpoint\",\n        data=authorization_request.args,\n        auth=self.auth,\n        on_success=self.parse_pushed_authorization_response,\n        on_failure=self.on_pushed_authorization_request_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_pushed_authorization_response","title":"<code>parse_pushed_authorization_response(response)</code>","text":"<p>Parse the response obtained by <code>pushed_authorization_request()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> returned by the PAR endpoint</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest instance</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_pushed_authorization_response(\n    self, response: requests.Response\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n    Args:\n        response: the `requests.Response` returned by the PAR endpoint\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest instance\n\n    \"\"\"\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response as returned by the AS PAR endpoint.</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest, if the error is recoverable</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>a subclass of this error depending on the error returned by the AS</p> <code>InvalidPushedAuthorizationResponse</code> <p>if the returned response is not following the</p> <code>specifications UnknownTokenEndpointError</code> <p>for unknown/unhandled errors</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self, response: requests.Response\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: the HTTP response as returned by the AS PAR endpoint.\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n    Raises:\n        EndpointError: a subclass of this error depending on the error returned by the AS\n        InvalidPushedAuthorizationResponse: if the returned response is not following the\n        specifications UnknownTokenEndpointError: for unknown/unhandled errors\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n    \"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n    the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n\n    \"\"\"\n    return self._request(\n        \"userinfo_endpoint\",\n        auth=BearerAuth(access_token),\n        on_success=self.parse_userinfo_response,\n        on_failure=self.on_userinfo_error,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n    response from the UserInfo endpoint, this will extract and return its JSON content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        the parsed JSON content from this response.\n\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_userinfo_error","title":"<code>on_userinfo_error(resp)</code>","text":"<p>Parse UserInfo error response.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>nothing, raises exception instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse UserInfo error response.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        nothing, raises exception instead.\n\n    \"\"\"\n    resp.raise_for_status()\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardized token type identifiers.</p> <p>Return a standardized token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>str | None</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\"</p> <code>None</code> <code>token</code> <code>None | str | BearerToken | IdToken</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef get_token_type(  # noqa: C901\n    cls,\n    token_type: str | None = None,\n    token: None | str | BearerToken | IdToken = None,\n) -&gt; str:\n    \"\"\"Get standardized token type identifiers.\n\n    Return a standardized token type identifier, based on a short `token_type` hint and/or a\n    token value.\n\n    Args:\n        token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n            or \"id_token\"\n        token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n    Returns:\n        the token_type as defined in the Token Exchange RFC8693.\n\n    \"\"\"\n    if not (token_type or token):\n        msg = \"Cannot determine type of an empty token without a token_type hint\"\n        raise ValueError(msg)\n\n    if token_type is None:\n        if isinstance(token, str):\n            msg = \"Cannot determine the type of provided token when it is a bare str. Please specify a token_type.\"\n            raise ValueError(msg)\n        elif isinstance(token, BearerToken):\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        elif isinstance(token, IdToken):\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n        else:\n            msg = \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\"\n            raise TypeError(\n                msg,\n                type(token),\n            )\n    elif token_type == TokenType.ACCESS_TOKEN:\n        if token is not None and not isinstance(token, (str, BearerToken)):\n            msg = \"The supplied token is not a BearerToken or a string representation of it.\"\n            raise TypeError(\n                msg,\n                type(token),\n            )\n        return \"urn:ietf:params:oauth:token-type:access_token\"\n    elif token_type == TokenType.REFRESH_TOKEN:\n        if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n            msg = \"The supplied BearerToken doesn't have a refresh_token.\"\n            raise ValueError(msg)\n        return \"urn:ietf:params:oauth:token-type:refresh_token\"\n    elif token_type == \"id_token\":\n        if token is not None and not isinstance(token, (str, IdToken)):\n            msg = \"The supplied token is not an IdToken or a string representation of it.\"\n            raise TypeError(\n                msg,\n                type(token),\n            )\n        return \"urn:ietf:params:oauth:token-type:id_token\"\n    else:\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: BearerToken | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=TokenType.ACCESS_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured</p> <code>bool</code> <p>revocation endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured\n        revocation endpoint.\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            msg = \"The supplied BearerToken doesn't have a refresh token.\"\n            raise ValueError(msg)\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=TokenType.REFRESH_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>str | None</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds, <code>False</code> if no revocation endpoint is present or a</p> <code>bool</code> <p>non-standardised error is returned.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n        non-standardised error is returned.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            msg = \"The supplied BearerToken doesn't have a refresh token.\"\n            raise ValueError(msg)\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        \"revocation_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=lambda resp: True,\n        on_failure=self.on_revocation_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Revocation Endpoint</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the</p> <code>bool</code> <p>revocation response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response) -&gt; bool:\n    \"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n    revocation endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the\n        revocation response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception:\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the Introspection Endpoint.</p> <p>Parameter <code>token</code> can be:</p> <ul> <li>a <code>str</code></li> <li>a <code>BearerToken</code> instance</li> </ul> <p>You may pass any arbitrary <code>token</code> and <code>token_type_hint</code> values as <code>str</code>. Those will be included in the request, as-is. If <code>token</code> is a <code>BearerToken</code>, then <code>token_type_hint</code> must be either:</p> <ul> <li><code>None</code>: the access_token will be instrospected and no token_type_hint will be included in the request</li> <li><code>access_token</code>: same as <code>None</code>, but the token_type_hint will be included</li> <li>or <code>refresh_token</code>: only available if a Refresh Token is present in the BearerToken.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to instrospect</p> required <code>token_type_hint</code> <code>str | None</code> <p>the <code>token_type_hint</code> to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def introspect_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **introspect_kwargs: Any,\n) -&gt; Any:\n    \"\"\"Send a request to the Introspection Endpoint.\n\n    Parameter `token` can be:\n\n    - a `str`\n    - a `BearerToken` instance\n\n    You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n    be included in the request, as-is.\n    If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n    - `None`: the access_token will be instrospected and no token_type_hint will be included\n    in the request\n    - `access_token`: same as `None`, but the token_type_hint will be included\n    - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n    Args:\n        token: the token to instrospect\n        token_type_hint: the `token_type_hint` to include in the request.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n    Returns:\n        the response as returned by the Introspection Endpoint.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if isinstance(token, BearerToken):\n        if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n            token = token.access_token\n        elif token_type_hint == TokenType.REFRESH_TOKEN:\n            if token.refresh_token is None:\n                msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                raise ValueError(msg)\n            else:\n                token = token.refresh_token\n        else:\n            msg = (\n                \"Invalid `token_type_hint`. To test arbitrary `token_type_hint` values,\"\n                \" you must provide `token` as a `str`.\"\n            )\n            raise ValueError(msg)\n\n    data = dict(introspect_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        \"introspection_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_introspection_response,\n        on_failure=self.on_introspection_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n    \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response. This decodes the JSON content if possible, otherwise it\n    returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exceptions. A subclass can return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response) -&gt; Any:\n    \"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n\n    Returns:\n        usually raises exceptions. A subclass can return a default response instead.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception as exc:\n        raise UnknownIntrospectionError(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', *, client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>str | None</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>None | str | Iterable[str]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>str | None</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>str | None</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>str | None</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>str | None</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>str | None</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>int | None</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Jwk | dict[str, Any] | None</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(  # noqa: PLR0913\n    self,\n    scope: None | str | Iterable[str] = \"openid\",\n    *,\n    client_notification_token: str | None = None,\n    acr_values: None | str | Iterable[str] = None,\n    login_hint_token: str | None = None,\n    id_token_hint: str | None = None,\n    login_hint: str | None = None,\n    binding_message: str | None = None,\n    user_code: str | None = None,\n    requested_expiry: int | None = None,\n    private_jwk: Jwk | dict[str, Any] | None = None,\n    alg: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n\n    \"\"\"\n    if not (login_hint or login_hint_token or id_token_hint):\n        msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise ValueError(msg)\n\n    if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n        msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise ValueError(msg)\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            msg = \"Unsupported `scope` value\"\n            raise ValueError(msg) from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            msg = \"Unsupported `acr_values`\"\n            raise ValueError(msg) from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    return self._request(\n        \"backchannel_authentication_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_backchannel_authentication_response,\n        on_failure=self.on_backchannel_authentication_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self, response: requests.Response\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n    error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.authorize_device","title":"<code>authorize_device(requests_kwargs=None, **data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(\n    self, requests_kwargs: dict[str, Any] | None = None, **data: Any\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        a Device Authorization Response\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    return self._request(\n        \"device_authorization_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_device_authorization_response,\n        on_failure=self.on_device_authorization_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n\n    \"\"\"\n    device_authorization_response = DeviceAuthorizationResponse(**response.json())\n    return device_authorization_response\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint, when that response is\n    an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys(requests_kwargs=None)</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a <code>jwskate.JwkSet</code>. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no <code>jwks_uri</code> is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n    \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n    available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no `jwks_uri` is configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    jwks = self._request(\n        \"jwks_uri\",\n        auth=None,\n        method=\"GET\",\n        on_success=lambda resp: resp.json(),\n        on_failure=lambda resp: resp.raise_for_status(),\n        **requests_kwargs,\n    )\n    self.authorization_server_jwks.update(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, session=None, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client based on Authorization Server Metadata.</p> <p>This will retrieve the standardised metadata document available at <code>url</code>, and will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialise an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>the url where the server metadata will be retrieved</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a <code>requests.Session</code> to use to retrieve the document and initialise the client with</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one from the retrieved document</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters to pass to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an OAuth2Client with endpoint initialised based on the obtained metadata</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if neither <code>url</code> nor <code>issuer</code> are suitable urls</p> <code>HTTPError</code> <p>if an error happens while fetching the documents</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: str | None = None,\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n    This will retrieve the standardised metadata document available at `url`, and will extract\n    all Endpoint Uris from that document, will fetch the current public keys from its\n    `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n    Args:\n         url: the url where the server metadata will be retrieved\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         session: a `requests.Session` to use to retrieve the document and initialise the client with\n         issuer: if an issuer is given, check that it matches the one from the retrieved document\n         testing: if True, don't try to validate the endpoint urls that are part of the document\n         **kwargs: additional keyword parameters to pass to OAuth2Client\n\n    Returns:\n        an OAuth2Client with endpoint initialised based on the obtained metadata\n\n    Raises:\n        ValueError: if neither `url` nor `issuer` are suitable urls\n        requests.HTTPError: if an error happens while fetching the documents\n\n    \"\"\"\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        msg = \"Please specify at least one of `issuer` or `url`\"\n        raise ValueError(msg)\n\n    validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri:\n        jwks = JwkSet(session.get(jwks_uri).json())\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, session=None, https=True, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client, based on the server metadata from <code>discovery</code>.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>dict[str, Any]</code> <p>a dict of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one mentioned in the document</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>authorization_server_jwks</code> <code>JwkSet | dict[str, Any] | None</code> <p>the current authorization server JWKS keys</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use to retrieve the document and initialise the client with</p> <code>None</code> <code>https</code> <code>bool</code> <p>(deprecated) if <code>True</code>, validates that urls in the discovery document use the https scheme</p> <code>True</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional args that will be passed to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an <code>OAuth2Client</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_document(  # noqa: PLR0913\n    cls,\n    discovery: dict[str, Any],\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    https: bool = True,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client, based on the server metadata from `discovery`.\n\n    Args:\n         discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n         issuer: if an issuer is given, check that it matches the one mentioned in the document\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         authorization_server_jwks: the current authorization server JWKS keys\n         session: a requests Session to use to retrieve the document and initialise the client with\n         https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n         testing: if True, don't try to validate the endpoint urls that are part of the document\n         **kwargs: additional args that will be passed to OAuth2Client\n\n    Returns:\n        an `OAuth2Client`\n\n    \"\"\"\n    if not https:\n        warnings.warn(\n            \"The https parameter is deprecated.\"\n            \" To disable endpoint uri validation, set `testing=True` when initializing your OAuth2Client.\",\n            stacklevel=1,\n        )\n        testing = True\n    if issuer and discovery.get(\"issuer\") != issuer:\n        msg = \"Mismatching issuer value in discovery document: \"\n        raise ValueError(\n            msg,\n            issuer,\n            discovery.get(\"issuer\"),\n        )\n    elif issuer is None:\n        issuer = discovery.get(\"issuer\")\n\n    token_endpoint = discovery.get(\"token_endpoint\")\n    if token_endpoint is None:\n        msg = \"token_endpoint not found in that discovery document\"\n        raise ValueError(msg)\n    authorization_endpoint = discovery.get(\"authorization_endpoint\")\n    revocation_endpoint = discovery.get(\"revocation_endpoint\")\n    introspection_endpoint = discovery.get(\"introspection_endpoint\")\n    userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri is not None:\n        validate_endpoint_uri(jwks_uri, https=https)\n    authorization_response_iss_parameter_supported = discovery.get(\n        \"authorization_response_iss_parameter_supported\", False\n    )\n\n    return cls(\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        introspection_endpoint=introspection_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        jwks_uri=jwks_uri,\n        authorization_server_jwks=authorization_server_jwks,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        session=session,\n        issuer=issuer,\n        authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>             Bases: <code>AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends [requests.auth.AuthBase].</p> <p>This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class BaseClientAuthenticationMethod(requests.auth.AuthBase):\n    \"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase].\n\n    This base class only checks that requests are suitable to add Client Authentication parameters\n    to, and doesn't modify the request.\n\n    \"\"\"\n\n    def __init__(self, client_id: str):\n        self.client_id = str(client_id)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            msg = \"This request is not suitable for OAuth 2.0 Client Authentication\"\n            raise RuntimeError(msg)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientAssertionAuthenticationMethod","title":"<code>ClientAssertionAuthenticationMethod</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion-based client authentication methods.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the client_id to use</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> required <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> required <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> required <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n    \"\"\"Base class for assertion-based client authentication methods.\n\n    Args:\n        client_id: the client_id to use\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        alg: str,\n        lifetime: int,\n        jti_gen: Callable[[], str],\n        aud: str | None = None,\n    ) -&gt; None:\n        super().__init__(client_id)\n        self.alg = alg\n        self.lifetime = lifetime\n        self.jti_gen = jti_gen\n        self.aud = aud\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        raise NotImplementedError()  # pragma: no cover\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        if audience is None:\n            msg = \"No url defined for this request. This should never happen...\"  # pragma: no cover\n            raise ValueError(msg)  # pragma: no cover\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        client_assertion = self.client_assertion(audience)\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_assertion\"] = [client_assertion.encode()]\n        params[b\"client_assertion_type\"] = [b\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    raise NotImplementedError()  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the Authorization header, with the \"Basic\" scheme, in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p><code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p><code>client_secret</code> to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretBasic(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the Authorization header, with\n    the \"Basic\" scheme, in each authenticated request to the AS.\n\n    Args:\n        client_id: `client_id` to use.\n        client_secret: `client_secret` to use.\n\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str):\n        super().__init__(client_id)\n        self.client_secret = str(client_secret)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such: `Authorization: Basic\n        BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>             Bases: <code>ClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, the client generates and signs a client assertion that is symmetrically signed with its Client Secret. The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>'HS256'</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], Any]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: uuid4()</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretJwt(ClientAssertionAuthenticationMethod):\n    \"\"\"Implement `client_secret_jwt` client authentication method.\n\n    With this method, the client generates and signs a client assertion that is symmetrically\n    signed with its Client Secret. The assertion is then sent to the AS in a `client_assertion`\n    field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        alg: str = \"HS256\",\n        lifetime: int = 60,\n        jti_gen: Callable[[], Any] = lambda: uuid4(),\n        aud: str | None = None,\n    ) -&gt; None:\n        super().__init__(client_id, alg, lifetime, jti_gen, aud)\n        self.client_secret = str(client_secret)\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated  request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p><code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p><code>client_secret</code> to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretPost(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_post` client authentication method.\n\n     With this method, the client inserts its client_id and client_secret in each authenticated\n     request to the AS.\n\n    Args:\n        client_id: `client_id` to use.\n        client_secret: `client_secret` to use.\n\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        super().__init__(client_id)\n        self.client_secret = str(client_secret)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if isinstance(request.body, (str, bytes))\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_secret\"] = [self.client_secret.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>             Bases: <code>ClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the private JWK to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>RS256</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], Any]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: uuid4()</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class PrivateKeyJwt(ClientAssertionAuthenticationMethod):\n    \"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is asymmetrically\n    signed with a private key, on each direct request to the Authorization Server.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private JWK to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Jwk | dict[str, Any],\n        alg: str = SignatureAlgs.RS256,\n        lifetime: int = 60,\n        jti_gen: Callable[[], Any] = lambda: uuid4(),\n        aud: str | None = None,\n    ) -&gt; None:\n        if not isinstance(private_jwk, Jwk):\n            private_jwk = Jwk(private_jwk)\n\n        if not private_jwk.is_private or private_jwk.is_symmetric:\n            msg = \"Private Key JWT client authentication method uses asymmetric signing thus requires a private key.\"\n            raise ValueError(msg)\n\n        alg = private_jwk.alg or alg\n        if not alg:\n            msg = \"An asymmetric signing alg is required, either as part of the private JWK, or passed as parameter.\"\n            raise ValueError(msg)\n        kid = private_jwk.get(\"kid\")\n        if not kid:\n            msg = \"Asymmetric signing requires the private JWK to have a Key ID (kid).\"\n            raise ValueError(msg)\n\n        super().__init__(client_id, alg, lifetime, jti_gen, aud)\n        self.private_jwk = private_jwk\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.PublicApp","title":"<code>PublicApp</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the client_id to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class PublicApp(BaseClientAuthenticationMethod):\n    \"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Args:\n        client_id: the client_id to use.\n\n    \"\"\"\n\n    def __init__(self, client_id: str) -&gt; None:\n        self.client_id = client_id\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_id` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>             Bases: <code>TokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow-down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> <p>auth=(\"client_id\", \"client_secret\") ) pool_job = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")</p> <pre><code>token = None while token is None: token = pool_job() ```\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationPoolingJob(TokenEndpointPoolingJob):\n    \"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a Device\n    Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow-down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\",\n    auth=(\"client_id\", \"client_secret\") ) pool_job = DeviceAuthorizationPoolingJob(client=client,\n    device_code=\"my_device_code\")\n\n        token = None while token is None: token = pool_job() ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ):\n        super().__init__(\n            client=client,\n            interval=interval,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs,\n            **token_kwargs,\n        )\n        self.device_code = device_code\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls [OAuth2Client.device_code(device_code)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>str | None</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n    \"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code.\n            Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: str | None = None,\n        expires_at: datetime | None = None,\n        interval: int | None = None,\n        **kwargs: Any,\n    ):\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n    \"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are\n    returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n\n    \"\"\"\n\n    def __init__(self, error: str, description: str | None = None, uri: str | None = None):\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n    \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n    \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.EndpointError","title":"<code>EndpointError</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the raw requests.PreparedResponse containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n    \"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned by the AS in the OAuth\n    2.0 standardised way.\n\n    Args:\n        response: the raw requests.PreparedResponse containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ):\n        super().__init__(response)\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n    \"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is expired.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>             Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n    \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n    \"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(Exception):\n    \"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n    \"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>             Bases: <code>InvalidJwt</code></p> <p>Raised when trying to validate an invalid ID Token value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidIdToken(InvalidJwt):\n    \"\"\"Raised when trying to validate an invalid ID Token value.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n    \"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingAcr","title":"<code>MismatchingAcr</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAcr(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingAudience","title":"<code>MismatchingAudience</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAudience(InvalidIdToken):\n    \"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingAzp","title":"<code>MismatchingAzp</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAzp(InvalidIdToken):\n    \"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected\n    value.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingNonce","title":"<code>MismatchingNonce</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingNonce(InvalidIdToken):\n    \"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the\n    value passed in the Authorization Request.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIdToken(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID\n    Token either.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response containing the error</p> required Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n\n    \"\"\"\n\n    def __init__(self, response: requests.Response):\n        self.response = response\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n        \"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.OAuth2Error.request","title":"<code>request: requests.PreparedRequest</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.RevocationError","title":"<code>RevocationError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n    \"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.ServerError","title":"<code>ServerError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n    \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.SlowDown","title":"<code>SlowDown</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n    \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n    \"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when an otherwise unknown error is returned by the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n    \"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>             Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n    \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.TokenEndpointPoolingJob","title":"<code>TokenEndpointPoolingJob</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client that will be used to pool the token endpoint.</p> required <code>interval</code> <code>int | None</code> <p>initial pooling interval, in seconds. If <code>None</code>, default to <code>5</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>when a SlowDown is received, this number of seconds will be added to the pooling interval.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying calls to requests.request</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token request</p> <code>{}</code> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>class TokenEndpointPoolingJob(ABC):\n    \"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows. This needs an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used\n            to pool the token endpoint.\n        interval: initial pooling interval, in seconds. If `None`, default to `5`.\n        slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is\n            received, this number of seconds will be added to the pooling interval.\n        requests_kwargs: additional parameters for the underlying calls to [requests.request][]\n        **token_kwargs: additional parameters for the token request\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ):\n        self.client = client\n        self.interval = interval or 5\n        self.slow_down_interval = slow_down_interval\n        self.requests_kwargs = requests_kwargs\n        self.token_kwargs = token_kwargs\n\n    def __call__(self) -&gt; BearerToken | None:\n        \"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling\n        interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So\n        you can call it immediately after initiating the BackChannel flow, and it will wait before\n        initiating the first call.\n\n        This implements the logic to handle\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or\n        [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or\n            `None` if the Authorization is still pending.\n\n        \"\"\"\n        time.sleep(self.interval)\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.interval += self.slow_down_interval\n        except AuthorizationPending:\n            pass\n        return None\n\n    @abstractmethod\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Abstract method for the token endpoint call.\n\n        This must be implemented by subclasses. This method must Must raise\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n        the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n        the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.TokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>  <code>abstractmethod</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>This must be implemented by subclasses. This method must Must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@abstractmethod\ndef token_request(self) -&gt; BearerToken:\n    \"\"\"Abstract method for the token endpoint call.\n\n    This must be implemented by subclasses. This method must Must raise\n    [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n    the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n    the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken","title":"<code>BearerToken</code>","text":"<p>             Bases: <code>AccessToken</code></p> <p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>str | None</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>str | bytes | IdToken | JweCompact | None</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@frozen(init=False)\nclass BearerToken(AccessToken):\n    \"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters, such as expiration date and\n    refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as\n    datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in\n    the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as\n            returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n\n    \"\"\"\n\n    TOKEN_TYPE: ClassVar[str] = AccessTokenType.BEARER.value\n\n    access_token: str\n    expires_at: datetime | None = None\n    scope: str | None = None\n    refresh_token: str | None = None\n    token_type: str = TOKEN_TYPE\n    id_token: IdToken | jwskate.JweCompact | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ):\n        if token_type.title() != self.TOKEN_TYPE.title():\n            msg = f\"Token Type is not '{self.TOKEN_TYPE}'!\"\n            raise ValueError(msg, token_type)\n        id_token_jwt: IdToken | jwskate.JweCompact | None = None\n        if isinstance(id_token, (str, bytes)):\n            try:\n                id_token_jwt = IdToken(id_token)\n            except jwskate.InvalidJwt:\n                try:\n                    id_token_jwt = jwskate.JweCompact(id_token)\n                except jwskate.InvalidJwe:\n                    msg = \"ID Token is invalid because it is  neither a JWT or a JWE.\"\n                    raise InvalidIdToken(msg) from None\n        else:\n            id_token_jwt = id_token\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token_jwt,\n            kwargs=kwargs,\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds,\n                then consider it expired already.\n\n        Returns:\n            One of:\n\n            - `True` if the access token is expired\n            - `False` if it is still valid\n            - `None` if there is no expires_in hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n        \"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in an HTTP Authorization Header\n\n        \"\"\"\n        return f\"Bearer {self.access_token}\"\n\n    def validate_id_token(self, client: OAuth2Client, azr: AuthorizationResponse) -&gt; Self:  # noqa: C901, PLR0915\n        \"\"\"Validate that a token response is valid, and return the ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        If the ID Token is encrypted, this decrypts it and returns the clear-text ID Token.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken()\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"ID Token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, self)\n        elif isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"ID Token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"ID Token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        if id_token.get_header(\"alg\") is None and client.id_token_signed_response_alg is None:\n            msg = (\n                \"ID Token does not contain an `alg` parameter to specify the signature\"\n                \" algorithm, and no algorithm has been configured for the client (using param\"\n                \" id_token_signed_response_alg`.\"\n            )\n            raise InvalidIdToken(msg)\n        elif client.id_token_signed_response_alg is not None and id_token.alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg)\n\n        id_token_alg = id_token.alg or client.id_token_signed_response_alg\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIssuer(id_token.issuer, azr.issuer, self)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingAudience(id_token.audiences, client.client_id, self)\n\n        if id_token.get_claim(\"azp\") is not None and id_token.azp != client.client_id:\n            raise MismatchingAzp(id_token.azp, client.client_id, self)\n\n        if id_token.is_expired():\n            raise ExpiredIdToken(id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingNonce()\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingAcr(id_token.acr, azr.acr_values)\n\n        hash_function: Callable[[str], str]  # method used to calculate at_hash, s_hash, etc.\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"ID Token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg)\n            id_token.verify_signature(jwskate.SymmetricJwk.from_bytes(client.client_secret), alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"ID Token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = (\n                    \"ID Token does not contain a Key ID (kid) to specify the asymmetric key \"\n                    \"to use for signature verification.\"\n                )\n                raise InvalidIdToken(msg)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = (\n                    f\"ID Token is asymmetrically signed but its Key ID '{id_token.kid}' \"\n                    \"is not part of the Authorization Server JWKS.\"\n                )\n                raise InvalidIdToken(msg) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"ID Token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg)\n\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n\n            hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"Mismatching 'at_hash' value: expected '{expected_at_hash}', got '{at_hash}'\"\n                raise InvalidIdToken(msg)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"Mismatching 'c_hash' value: expected '{expected_c_hash}', got '{c_hash}'\"\n                raise InvalidIdToken(msg)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"ID Token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"Mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}'\"\n                raise InvalidIdToken(msg)\n\n        if azr.max_age is not None:\n            try:\n                auth_time = id_token.auth_time\n            except AttributeError:\n                msg = (\n                    \"A `max_age` parameter was included in the authorization request, \"\n                    \"but the ID Token does not contain an `auth_time` claim.\"\n                )\n                raise InvalidIdToken(msg) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.seconds &gt; azr.max_age + 60:\n                msg = (\n                    \"User authentication happened too long ago. The `auth_time` parameter from\"\n                    \" the ID Token indicate that the last Authentication Time was at\"\n                    f\" {auth_time} ({auth_age.seconds} sec ago), but the authorization request\"\n                    f\" `max_age` parameter specified that it must be maximum {azr.max_age} sec\"\n                    \" ago.\"\n                )\n                raise InvalidIdToken(msg)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n\n        \"\"\"\n        return self.access_token\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict of parameters.\n\n        That is suitable for serialization or to init another BearerToken.\n\n        \"\"\"\n        d = asdict(self)\n        d.pop(\"expires_at\")\n        d[\"expires_in\"] = self.expires_in\n        d.update(**d.pop(\"kwargs\", {}))\n        return {key: val for key, val in d.items() if val is not None}\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return int(self.expires_at.timestamp() - datetime.now(tz=timezone.utc).timestamp())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return custom attributes from this BearerToken.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n\n        \"\"\"\n        return self.kwargs.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.expires_in","title":"<code>expires_in: int | None</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>One of:</p> <code>bool | None</code> <ul> <li><code>True</code> if the access token is expired</li> </ul> <code>bool | None</code> <ul> <li><code>False</code> if it is still valid</li> </ul> <code>bool | None</code> <ul> <li><code>None</code> if there is no expires_in hint.</li> </ul> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds,\n            then consider it expired already.\n\n    Returns:\n        One of:\n\n        - `True` if the access token is expired\n        - `False` if it is still valid\n        - `None` if there is no expires_in hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in an HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n    \"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in an HTTP Authorization Header\n\n    \"\"\"\n    return f\"Bearer {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr)</code>","text":"<p>Validate that a token response is valid, and return the ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>If the ID Token is encrypted, this decrypts it and returns the clear-text ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def validate_id_token(self, client: OAuth2Client, azr: AuthorizationResponse) -&gt; Self:  # noqa: C901, PLR0915\n    \"\"\"Validate that a token response is valid, and return the ID Token.\n\n    This will validate the id_token as described in [OIDC 1.0\n    $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n    If the ID Token is encrypted, this decrypts it and returns the clear-text ID Token.\n\n    \"\"\"\n    if not self.id_token:\n        raise MissingIdToken()\n\n    raw_id_token = self.id_token\n\n    if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n        msg = \"ID Token is encrypted while it should be clear-text\"\n        raise InvalidIdToken(msg, self)\n    elif isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n        msg = \"ID Token is clear-text while it should be encrypted\"\n        raise InvalidIdToken(msg, self)\n\n    if isinstance(raw_id_token, jwskate.JweCompact):\n        enc_jwk = client.id_token_decryption_key\n        if enc_jwk is None:\n            msg = \"ID Token is encrypted but client does not have a decryption key\"\n            raise InvalidIdToken(msg, self)\n        nested_id_token = raw_id_token.decrypt(enc_jwk)\n        id_token = IdToken(nested_id_token)\n    else:\n        id_token = raw_id_token\n\n    if id_token.get_header(\"alg\") is None and client.id_token_signed_response_alg is None:\n        msg = (\n            \"ID Token does not contain an `alg` parameter to specify the signature\"\n            \" algorithm, and no algorithm has been configured for the client (using param\"\n            \" id_token_signed_response_alg`.\"\n        )\n        raise InvalidIdToken(msg)\n    elif client.id_token_signed_response_alg is not None and id_token.alg != client.id_token_signed_response_alg:\n        raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg)\n\n    id_token_alg = id_token.alg or client.id_token_signed_response_alg\n\n    if azr.issuer and id_token.issuer != azr.issuer:\n        raise MismatchingIssuer(id_token.issuer, azr.issuer, self)\n\n    if id_token.audiences and client.client_id not in id_token.audiences:\n        raise MismatchingAudience(id_token.audiences, client.client_id, self)\n\n    if id_token.get_claim(\"azp\") is not None and id_token.azp != client.client_id:\n        raise MismatchingAzp(id_token.azp, client.client_id, self)\n\n    if id_token.is_expired():\n        raise ExpiredIdToken(id_token)\n\n    if azr.nonce and id_token.nonce != azr.nonce:\n        raise MismatchingNonce()\n\n    if azr.acr_values and id_token.acr not in azr.acr_values:\n        raise MismatchingAcr(id_token.acr, azr.acr_values)\n\n    hash_function: Callable[[str], str]  # method used to calculate at_hash, s_hash, etc.\n\n    if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n        if not client.client_secret:\n            msg = \"ID Token is symmetrically signed but this client does not have a Client Secret.\"\n            raise InvalidIdToken(msg)\n        id_token.verify_signature(jwskate.SymmetricJwk.from_bytes(client.client_secret), alg=id_token_alg)\n    elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n        if not client.authorization_server_jwks:\n            msg = \"ID Token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n            raise InvalidIdToken(msg)\n\n        if id_token.get_header(\"kid\") is None:\n            msg = (\n                \"ID Token does not contain a Key ID (kid) to specify the asymmetric key \"\n                \"to use for signature verification.\"\n            )\n            raise InvalidIdToken(msg)\n        try:\n            verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n        except KeyError:\n            msg = (\n                f\"ID Token is asymmetrically signed but its Key ID '{id_token.kid}' \"\n                \"is not part of the Authorization Server JWKS.\"\n            )\n            raise InvalidIdToken(msg) from None\n\n        if id_token_alg not in verification_jwk.supported_signing_algorithms():\n            msg = \"ID Token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n            raise InvalidIdToken(msg)\n\n        id_token.verify_signature(verification_jwk, alg=id_token_alg)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n    at_hash = id_token.get_claim(\"at_hash\")\n    if at_hash is not None:\n        expected_at_hash = hash_function(self.access_token)\n        if expected_at_hash != at_hash:\n            msg = f\"Mismatching 'at_hash' value: expected '{expected_at_hash}', got '{at_hash}'\"\n            raise InvalidIdToken(msg)\n\n    c_hash = id_token.get_claim(\"c_hash\")\n    if c_hash is not None:\n        expected_c_hash = hash_function(azr.code)\n        if expected_c_hash != c_hash:\n            msg = f\"Mismatching 'c_hash' value: expected '{expected_c_hash}', got '{c_hash}'\"\n            raise InvalidIdToken(msg)\n\n    s_hash = id_token.get_claim(\"s_hash\")\n    if s_hash is not None:\n        if azr.state is None:\n            msg = \"ID Token has a 's_hash' claim but no state was included in the request.\"\n            raise InvalidIdToken(msg)\n        expected_s_hash = hash_function(azr.state)\n        if expected_s_hash != s_hash:\n            msg = f\"Mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}'\"\n            raise InvalidIdToken(msg)\n\n    if azr.max_age is not None:\n        try:\n            auth_time = id_token.auth_time\n        except AttributeError:\n            msg = (\n                \"A `max_age` parameter was included in the authorization request, \"\n                \"but the ID Token does not contain an `auth_time` claim.\"\n            )\n            raise InvalidIdToken(msg) from None\n        auth_age = datetime.now(tz=timezone.utc) - auth_time\n        if auth_age.seconds &gt; azr.max_age + 60:\n            msg = (\n                \"User authentication happened too long ago. The `auth_time` parameter from\"\n                \" the ID Token indicate that the last Authentication Time was at\"\n                f\" {auth_time} ({auth_age.seconds} sec ago), but the authorization request\"\n                f\" `max_age` parameter specified that it must be maximum {azr.max_age} sec\"\n                \" ago.\"\n            )\n            raise InvalidIdToken(msg)\n\n    return self.__class__(\n        access_token=self.access_token,\n        expires_at=self.expires_at,\n        scope=self.scope,\n        refresh_token=self.refresh_token,\n        token_type=self.token_type,\n        id_token=id_token,\n        **self.kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerToken.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict of parameters.</p> <p>That is suitable for serialization or to init another BearerToken.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict of parameters.\n\n    That is suitable for serialization or to init another BearerToken.\n\n    \"\"\"\n    d = asdict(self)\n    d.pop(\"expires_at\")\n    d[\"expires_in\"] = self.expires_in\n    d.update(**d.pop(\"kwargs\", {}))\n    return {key: val for key, val in d.items() if val is not None}\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Callable[[BearerToken], str] | None</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Callable[[str], BearerToken] | None</code> <p>a function to deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n    \"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize\n    BearerTokens. Default implementations are provided with use gzip and base64url on the serialized\n    JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function to deserialize a serialized token representation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[BearerToken], str] | None = None,\n        loader: Callable[[str], BearerToken] | None = None,\n    ):\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n        \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        return BinaPy.serialize_to(\"json\", token.as_dict()).to(\"deflate\").to(\"b64u\").ascii()\n\n    def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n        \"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n            token_class: class to use to deserialize the Token\n\n        Returns:\n            a BearerToken\n\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n        \"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n        \"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n    \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    return BinaPy.serialize_to(\"json\", token.as_dict()).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <code>token_class</code> <code>type[BearerToken]</code> <p>class to use to deserialize the Token</p> <code>BearerToken</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n    \"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n        token_class: class to use to deserialize the Token\n\n    Returns:\n        a BearerToken\n\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n    \"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n    \"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.IdToken","title":"<code>IdToken</code>","text":"<p>             Bases: <code>SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n    \"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded\n    beforehand.\n\n    \"\"\"\n\n    @property\n    def auth_time(self) -&gt; datetime:\n        \"\"\"The last user authentication time.\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time:\n            return self.timestamp_to_datetime(auth_time)\n        msg = \"This ID Token doesn't have an `auth_time` attribute.\"\n        raise AttributeError(msg)\n\n    @classmethod\n    def hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n        \"\"\"Returns a callable that generates valid OIDC hashes, such as at_hash, c_hash, s_hash.\n\n        Args:\n            key: the ID token signature verification public key\n            alg: the ID token signature algorithm\n\n        Returns:\n            a callable that takes a string as input and produces a valid hash as a str output\n\n        \"\"\"\n        alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n        if alg_class == jwskate.EdDsa:\n            if key.crv == \"Ed25519\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n            elif key.crv == \"Ed448\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n        return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.IdToken.auth_time","title":"<code>auth_time: datetime</code>  <code>property</code>","text":"<p>The last user authentication time.</p>"},{"location":"api/#requests_oauth2client.IdToken.hash_method","title":"<code>hash_method(key, alg=None)</code>  <code>classmethod</code>","text":"<p>Returns a callable that generates valid OIDC hashes, such as at_hash, c_hash, s_hash.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk</code> <p>the ID token signature verification public key</p> required <code>alg</code> <code>str | None</code> <p>the ID token signature algorithm</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[str], str]</code> <p>a callable that takes a string as input and produces a valid hash as a str output</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@classmethod\ndef hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n    \"\"\"Returns a callable that generates valid OIDC hashes, such as at_hash, c_hash, s_hash.\n\n    Args:\n        key: the ID token signature verification public key\n        alg: the ID token signature algorithm\n\n    Returns:\n        a callable that takes a string as input and produces a valid hash as a str output\n\n    \"\"\"\n    alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n    if alg_class == jwskate.EdDsa:\n        if key.crv == \"Ed25519\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n        elif key.crv == \"Ed448\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n    else:\n        hash_alg = alg_class.hashing_alg.name\n        hash_size = alg_class.hashing_alg.digest_size\n\n        def hash_method(token: str) -&gt; str:\n            return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n    return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20 server metadata can\n    be retrieved.\n\n    The returned URL is built as specified in\n    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can\n    be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery\n    1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.well_known_uri","title":"<code>well_known_uri(origin, name, *, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be</p> <code>str</code> <p>found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, *, at_root: bool = True) -&gt; str:\n    \"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC\n    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID\n            Connect Discovery\n            1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be\n        found.\n\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client","title":"<code>api_client</code>","text":"<p><code>ApiClient</code> main module.</p>"},{"location":"api/#requests_oauth2client.api_client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for REST API calls.</p> <p>Additional features compared to using a requests.Session directly:</p> <ul> <li>You must set a root url at creation time, which then allows passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code>  or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc.</p> <p>An <code>HTTPError</code> will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Usage <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init its own session and provide additional configuration\n# parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\",\n    proxies={\"https\": \"https://localhost:3128\"},\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>the base api url, that is the root for all the target API endpoints.</p> required <code>auth</code> <code>AuthBase | None</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>int | None</code> <p>the default timeout, in seconds, to use for each request from this <code>ApiClient</code>. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>what to do with parameters with value <code>None</code> in <code>data</code> or <code>json</code> fields.</p> <ul> <li>if <code>\"exclude\"</code> (default), fields whose values are <code>None</code> are not included in the request.</li> <li>if <code>\"include\"</code>, they are included with string value <code>None</code>. Note that this is the default behavior of <code>requests</code>.</li> <li>if \"empty\", they are included with an empty value (as an empty string).</li> </ul> <code>'exclude'</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>a tuple of (true_value, false_value). Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and <code>requests</code> serializes <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behaviour.</p> <code>('true', 'false')</code> <code>session</code> <code>Session | None</code> <p>a preconfigured <code>requests.Session</code> to use with this <code>ApiClient</code>.</p> <code>None</code> <code>**session_kwargs</code> <code>Any</code> <p>additional kwargs to configure the underlying <code>requests.Session</code>.</p> <code>{}</code> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>@frozen(init=False)\nclass ApiClient:\n    \"\"\"A Wrapper around [requests.Session][] with extra features for REST API calls.\n\n    Additional features compared to using a [requests.Session][] directly:\n\n    - You must set a root url at creation time, which then allows passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the\n    [Session][requests.Session], instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be\n    automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable\n    for the target API, like `\"true\"`  or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default\n    values `\"True\"` or `\"False\"`.\n\n    `base_url` will serve as root for relative urls passed to\n    [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request],\n    [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n\n    An `HTTPError` will be raised everytime an API call returns an error code (&gt;= 400), unless\n    you set `raise_for_status` to `False`. Additional parameters passed at init time, including\n    `auth` will be used to configure the [Session][requests.Session].\n\n    Usage:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init its own session and provide additional configuration\n        # parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\",\n            proxies={\"https\": \"https://localhost:3128\"},\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that is the root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this `ApiClient`.\n            Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an\n            error code (&gt;= 400).\n        none_fields: what to do with parameters with value `None` in `data` or `json` fields.\n\n            - if `\"exclude\"` (default), fields whose values are `None` are not included in the request.\n            - if `\"include\"`, they are included with string value `None`. Note that this is\n            the default behavior of `requests`.\n            - if \"empty\", they are included with an empty value (as an empty string).\n        bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with\n            a boolean value (`True` or `False`) will be serialized to the corresponding value.\n            This can be useful since some APIs expect a `'true'` or `'false'` value as boolean,\n            and `requests` serializes `True` to `'True'` and `False` to `'False'`.\n            Set it to `None` to restore default requests behaviour.\n        session: a preconfigured `requests.Session` to use with this `ApiClient`.\n        **session_kwargs: additional kwargs to configure the underlying `requests.Session`.\n\n    \"\"\"\n\n    base_url: str\n    auth: requests.auth.AuthBase | None = None\n    timeout: int | None = 60\n    raise_for_status: bool = True\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\"\n    bool_fields: tuple[Any, Any] | None = \"true\", \"false\"\n    session: requests.Session = field(factory=requests.Session)\n\n    def __init__(\n        self,\n        base_url: str,\n        *,\n        auth: requests.auth.AuthBase | None = None,\n        timeout: int | None = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: tuple[Any, Any] | None = (\"true\", \"false\"),\n        session: requests.Session | None = None,\n        **session_kwargs: Any,\n    ):\n        session = session or requests.Session()\n        for key, val in session_kwargs.items():\n            setattr(session, key, val)\n\n        if bool_fields is None:\n            bool_fields = (True, False)\n\n        self.__attrs_init__(\n            base_url=base_url,\n            auth=auth,\n            raise_for_status=raise_for_status,\n            none_fields=none_fields,\n            bool_fields=bool_fields,\n            timeout=timeout,\n            session=session,\n        )\n\n    def request(  # noqa: C901, PLR0913, D417\n        self,\n        method: str,\n        url: None | str | bytes | Iterable[str | bytes | int] = None,\n        *,\n        params: None | bytes | MutableMapping[str, str] = None,\n        data: (\n            Iterable[bytes]\n            | str\n            | bytes\n            | list[tuple[Any, Any]]\n            | tuple[tuple[Any, Any], ...]\n            | Mapping[Any, Any]\n            | None\n        ) = None,\n        headers: MutableMapping[str, str] | None = None,\n        cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n        files: MutableMapping[str, IO[Any]] | None = None,\n        auth: (\n            None\n            | tuple[str, str]\n            | requests.auth.AuthBase\n            | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n        ) = None,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        allow_redirects: bool = False,\n        proxies: MutableMapping[str, str] | None = None,\n        hooks: None\n        | (\n            MutableMapping[\n                str,\n                (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n            ]\n        ) = None,\n        stream: bool | None = None,\n        verify: str | bool | None = None,\n        cert: str | tuple[str, str] | None = None,\n        json: Mapping[str, Any] | None = None,\n        raise_for_status: bool | None = None,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n        bool_fields: tuple[Any, Any] | None = None,\n    ) -&gt; requests.Response:\n        \"\"\"Overridden `request` method with extra features.\n\n        Features added compared to plain request():\n\n        - takes a relative path instead of a full url, which will be appended to the\n          base_url\n        - it can raise an exception when the API returns a non-success status code\n        - allow_redirects is False by default (since API usually don't use redirects)\n        - `data` or `json` fields with value `None` can either be included or excluded from the\n          request\n        - boolean fields can be serialized to `'true'` or `'false'` instead of `'True'` and\n          `'False'`\n\n        Args:\n          method: the HTTP method to use\n          url: the url where the request will be sent to. Can be a path, as str ;\n            that path will be joined to the configured API url. Can also be an iterable of path\n            segments, that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from `ApiClient.__init__`,\n            but this will be applied for this request only.\n          none_fields: like the parameter of the same name from `ApiClient.__init__`,\n            but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from `ApiClient.__init__`,\n            but this will be applied for this request only.\n\n        Returns:\n          a [requests.Response][] as returned by requests\n\n        \"\"\"\n        url = self.to_absolute_url(url)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            try:\n                true_value, false_value = bool_fields\n            except ValueError:\n                msg = \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\"\n                raise ValueError(msg) from None\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth or self.auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(self, relative_url: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n        \"\"\"Convert a relative url to an absolute url.\n\n        Given a `relative_url`, return the matching absolute url, based on the `base_url` that is\n        configured for this API.\n\n        The result of this method is different from a standard `urljoin()`, because a relative_url\n        that starts with a \"/\" will not override the path from the base url. You can also pass an\n        iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n        may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n        any other type (which will be converted to `str` first, using the `str() function`). See the\n        table below for example results which would exhibit most cases:\n\n        | base_url | relative_url | result_url |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | b\"/path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | \"path\" | \"https://myhost.com/root/path\" |\n        | \"https://myhost.com/root\" | None | \"https://myhost.com/root\" |\n        | \"https://myhost.com/root\" |  (\"user\", 1, \"resource\") | \"https://myhost.com/root/user/1/resource\" |\n        | \"https://myhost.com/root\" | \"https://otherhost.org/foo\" | ValueError |\n\n        Args:\n          relative_url: a relative url\n\n        Returns:\n          the resulting absolute url\n\n        \"\"\"\n        url = relative_url\n\n        if self.base_url:\n            if url is not None:\n                if not isinstance(url, (str, bytes)):\n                    try:\n                        url = \"/\".join(\n                            [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part]\n                        )\n                    except Exception as exc:\n                        msg = (\n                            \"Unexpected url type, please pass a relative path as string or\"\n                            \" bytes, or an iterable of string-able objects\"\n                        )\n                        raise TypeError(\n                            msg,\n                            type(url),\n                        ) from exc\n\n                if isinstance(url, bytes):\n                    url = url.decode()\n\n                if \"://\" in url:\n                    msg = \"url must be relative to root_url\"\n                    raise ValueError(msg)\n\n                url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n            else:\n                url = self.base_url\n\n        if url is None or not isinstance(url, str):\n            msg = \"Unable to determine an absolute url.\"\n            raise ValueError(msg)\n\n        return url\n\n    def get(\n        self,\n        url: None | str | bytes | Iterable[str | bytes | int] = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a GET request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            url: a url where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: Optional arguments that [request()][requests.request] takes.\n\n        Returns:\n            a [Response][requests.Response] object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"GET\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a POST request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: an url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: Optional arguments that ``request`` takes.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"POST\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: an url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: Optional arguments that ``request`` takes.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PATCH\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"PUT\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        url: str | bytes | Iterable[str | bytes] | None = None,\n        raise_for_status: bool | None = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n        \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time. It takes the same\n        parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n        \"\"\"\n        return self.request(\"DELETE\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new ApiClient initialised on the new base url\n\n        Usage:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n        \"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new ApiClient initialised on the new base url\n\n        Usage:\n            ```python\n            from requests_oauth2client import ApiClient\n\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; ApiClient:\n        \"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as\n        `requests.Session`. The underlying request.Session will be closed on exit.\n\n        Usage:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n\n        \"\"\"\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n        \"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.request","title":"<code>request(method, url=None, *, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>Overridden <code>request</code> method with extra features.</p> <p>Features added compared to plain request():</p> <ul> <li>takes a relative path instead of a full url, which will be appended to the   base_url</li> <li>it can raise an exception when the API returns a non-success status code</li> <li>allow_redirects is False by default (since API usually don't use redirects)</li> <li><code>data</code> or <code>json</code> fields with value <code>None</code> can either be included or excluded from the   request</li> <li>boolean fields can be serialized to <code>'true'</code> or <code>'false'</code> instead of <code>'True'</code> and   <code>'False'</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the HTTP method to use</p> required <code>url</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>the url where the request will be sent to. Can be a path, as str ; that path will be joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <code>None</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty'] | None</code> <p>like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <code>None</code> <code>bool_fields</code> <code>tuple[Any, Any] | None</code> <p>like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>a requests.Response as returned by requests</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901, PLR0913, D417\n    self,\n    method: str,\n    url: None | str | bytes | Iterable[str | bytes | int] = None,\n    *,\n    params: None | bytes | MutableMapping[str, str] = None,\n    data: (\n        Iterable[bytes]\n        | str\n        | bytes\n        | list[tuple[Any, Any]]\n        | tuple[tuple[Any, Any], ...]\n        | Mapping[Any, Any]\n        | None\n    ) = None,\n    headers: MutableMapping[str, str] | None = None,\n    cookies: None | RequestsCookieJar | MutableMapping[str, str] = None,\n    files: MutableMapping[str, IO[Any]] | None = None,\n    auth: (\n        None\n        | tuple[str, str]\n        | requests.auth.AuthBase\n        | Callable[[requests.PreparedRequest], requests.PreparedRequest]\n    ) = None,\n    timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n    allow_redirects: bool = False,\n    proxies: MutableMapping[str, str] | None = None,\n    hooks: None\n    | (\n        MutableMapping[\n            str,\n            (Iterable[Callable[[requests.Response], Any]] | Callable[[requests.Response], Any]),\n        ]\n    ) = None,\n    stream: bool | None = None,\n    verify: str | bool | None = None,\n    cert: str | tuple[str, str] | None = None,\n    json: Mapping[str, Any] | None = None,\n    raise_for_status: bool | None = None,\n    none_fields: Literal[\"include\", \"exclude\", \"empty\"] | None = None,\n    bool_fields: tuple[Any, Any] | None = None,\n) -&gt; requests.Response:\n    \"\"\"Overridden `request` method with extra features.\n\n    Features added compared to plain request():\n\n    - takes a relative path instead of a full url, which will be appended to the\n      base_url\n    - it can raise an exception when the API returns a non-success status code\n    - allow_redirects is False by default (since API usually don't use redirects)\n    - `data` or `json` fields with value `None` can either be included or excluded from the\n      request\n    - boolean fields can be serialized to `'true'` or `'false'` instead of `'True'` and\n      `'False'`\n\n    Args:\n      method: the HTTP method to use\n      url: the url where the request will be sent to. Can be a path, as str ;\n        that path will be joined to the configured API url. Can also be an iterable of path\n        segments, that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from `ApiClient.__init__`,\n        but this will be applied for this request only.\n      none_fields: like the parameter of the same name from `ApiClient.__init__`,\n        but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from `ApiClient.__init__`,\n        but this will be applied for this request only.\n\n    Returns:\n      a [requests.Response][] as returned by requests\n\n    \"\"\"\n    url = self.to_absolute_url(url)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        try:\n            true_value, false_value = bool_fields\n        except ValueError:\n            msg = \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\"\n            raise ValueError(msg) from None\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        url,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth or self.auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(relative_url=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>relative_url</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this method is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for example results which would exhibit most cases:</p> base_url relative_url result_url \"https://myhost.com/root\" \"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" \"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" b\"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" \"path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" None \"https://myhost.com/root\" \"https://myhost.com/root\" (\"user\", 1, \"resource\") \"https://myhost.com/root/user/1/resource\" \"https://myhost.com/root\" \"https://otherhost.org/foo\" ValueError <p>Parameters:</p> Name Type Description Default <code>relative_url</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(self, relative_url: None | str | bytes | Iterable[str | bytes | int] = None) -&gt; str:\n    \"\"\"Convert a relative url to an absolute url.\n\n    Given a `relative_url`, return the matching absolute url, based on the `base_url` that is\n    configured for this API.\n\n    The result of this method is different from a standard `urljoin()`, because a relative_url\n    that starts with a \"/\" will not override the path from the base url. You can also pass an\n    iterable of path parts as relative url, which will be properly joined with \"/\". Those parts\n    may be `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or\n    any other type (which will be converted to `str` first, using the `str() function`). See the\n    table below for example results which would exhibit most cases:\n\n    | base_url | relative_url | result_url |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | \"/path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | b\"/path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | \"path\" | \"https://myhost.com/root/path\" |\n    | \"https://myhost.com/root\" | None | \"https://myhost.com/root\" |\n    | \"https://myhost.com/root\" |  (\"user\", 1, \"resource\") | \"https://myhost.com/root/user/1/resource\" |\n    | \"https://myhost.com/root\" | \"https://otherhost.org/foo\" | ValueError |\n\n    Args:\n      relative_url: a relative url\n\n    Returns:\n      the resulting absolute url\n\n    \"\"\"\n    url = relative_url\n\n    if self.base_url:\n        if url is not None:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [urlencode(part.decode() if isinstance(part, bytes) else str(part)) for part in url if part]\n                    )\n                except Exception as exc:\n                    msg = (\n                        \"Unexpected url type, please pass a relative path as string or\"\n                        \" bytes, or an iterable of string-able objects\"\n                    )\n                    raise TypeError(\n                        msg,\n                        type(url),\n                    ) from exc\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            if \"://\" in url:\n                msg = \"url must be relative to root_url\"\n                raise ValueError(msg)\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n        else:\n            url = self.base_url\n\n    if url is None or not isinstance(url, str):\n        msg = \"Unable to determine an absolute url.\"\n        raise ValueError(msg)\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.get","title":"<code>get(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>None | str | bytes | Iterable[str | bytes | int]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that request() takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    url: None | str | bytes | Iterable[str | bytes | int] = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a GET request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        url: a url where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: Optional arguments that [request()][requests.request] takes.\n\n    Returns:\n        a [Response][requests.Response] object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"GET\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.post","title":"<code>post(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>an url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that <code>request</code> takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a POST request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: an url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: Optional arguments that ``request`` takes.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"POST\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.patch","title":"<code>patch(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>an url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that <code>request</code> takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: an url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: Optional arguments that ``request`` takes.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PATCH\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.put","title":"<code>put(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"PUT\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.delete","title":"<code>delete(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | bytes | Iterable[str | bytes] | None</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>bool | None</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>if <code>raises_for_status</code> is <code>True</code> and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    url: str | bytes | Iterable[str | bytes] | None = None,\n    raise_for_status: bool | None = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n    \"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time. It takes the same\n    parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is `True` and an error response is returned.\n\n    \"\"\"\n    return self.request(\"DELETE\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth","title":"<code>auth</code>","text":"<p>This module contains <code>requests</code>-compatible Auth Handlers that implement OAuth 2.0.</p>"},{"location":"api/#requests_oauth2client.auth.BearerAuth","title":"<code>BearerAuth</code>","text":"<p>             Bases: <code>AuthBase</code></p> <p>An Auth Handler that includes a Bearer Token in API calls, as defined in RFC6750$2.1.</p> <p>As a prerequisite to using this <code>AuthBase</code>, you have to obtain an access token manually. You most likely don't want to do that by yourself, but instead use an instance of OAuth2Client to do that for you. See the others Auth Handlers in this module, which will automatically obtain access tokens from an OAuth 2.x server.</p> Usage <pre><code>auth = BearerAuth(\"my_access_token\")\nresp = requests.get(\"https://my.api.local/resource\", auth=auth)\n</code></pre> <p>The HTTP request will look like: <pre><code>GET /resource HTTP/1.1\nHost: my.api.local\nAuthorization: Bearer my_access_token\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken | None</code> <p>a BearerToken or a string to use as token for this Auth Handler. If <code>None</code>, this Auth Handler is a no-op.</p> <code>None</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class BearerAuth(requests.auth.AuthBase):\n    \"\"\"An Auth Handler that includes a Bearer Token in API calls, as defined in [RFC6750$2.1].\n\n    As a prerequisite to using this `AuthBase`, you have to obtain an access token manually.\n    You most likely don't want to do that by yourself, but instead use an instance of\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to do that for you.\n    See the others Auth Handlers in this module, which will automatically obtain\n    access tokens from an OAuth 2.x server.\n\n    [RFC6750$2.1]: https://datatracker.ietf.org/doc/html/rfc6750#section-2.1\n\n    Usage:\n        ```python\n        auth = BearerAuth(\"my_access_token\")\n        resp = requests.get(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n        The HTTP request will look like:\n        ```\n        GET /resource HTTP/1.1\n        Host: my.api.local\n        Authorization: Bearer my_access_token\n        ```\n\n    Args:\n        token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string\n            to use as token for this Auth Handler. If `None`, this Auth Handler is a no-op.\n\n    \"\"\"\n\n    def __init__(self, token: str | BearerToken | None = None) -&gt; None:\n        self.token = token  # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed\n\n    @property\n    def token(self) -&gt; BearerToken | None:\n        \"\"\"Return the [BearerToken] that is used for authorization against the API.\n\n        Returns:\n            the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this\n            AuthHandler.\n\n        \"\"\"\n        return self._token\n\n    @token.setter\n    def token(self, token: str | BearerToken | None) -&gt; None:\n        \"\"\"Change the access token used with this AuthHandler.\n\n        Accepts a [BearerToken][requests_oauth2client.tokens.BearerToken] or an access token as\n        `str`.\n\n        Args:\n            token: an access token to use for this Auth Handler\n\n        \"\"\"\n        if token is not None and not isinstance(token, BearerToken):\n            token = BearerToken(token)\n        self._token = token\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in the request.\n\n        If the configured token is an instance of BearerToken with an expires_at attribute, raises\n        [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access\n        token is expired.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in\n            Authorization Header\n\n        \"\"\"\n        if self.token is None:\n            return request\n        if self.token.is_expired():\n            raise ExpiredAccessToken(self.token)\n        request.headers[\"Authorization\"] = self.token.authorization_header()\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BearerAuth.token","title":"<code>token: BearerToken | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the [BearerToken] that is used for authorization against the API.</p> <p>Returns:</p> Type Description <code>BearerToken | None</code> <p>the configured BearerToken used with this</p> <code>BearerToken | None</code> <p>AuthHandler.</p>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RenewableTokenAuth","title":"<code>BaseOAuth2RenewableTokenAuth</code>","text":"<p>             Bases: <code>BearerAuth</code></p> <p>Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.</p> <p>In addition to adding a properly formatted <code>Authorization</code> header, this will obtain a new token once the current token is expired. Expiration is detected based on the <code>expires_in</code> hint returned by the AS. A configurable <code>leeway</code>, in number of seconds, will make sure that a new token is obtained some seconds before the actual expiration is reached. This may help in situations where the client, AS and RS have slightly offset clocks.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client</p> required <code>token</code> <code>None | BearerToken | str</code> <p>an initial Access Token, if you have one already. In most cases, leave <code>None</code>.</p> <code>None</code> <code>leeway</code> <code>int</code> <p>expiration leeway, in number of seconds</p> <code>20</code> <code>token_kwargs</code> <code>Any</code> <p>additional kwargs to include in token requests</p> <code>{}</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class BaseOAuth2RenewableTokenAuth(BearerAuth):\n    \"\"\"Base class for BearerToken-based Auth Handlers, with an obtainable or renewable token.\n\n    In addition to adding a properly formatted `Authorization` header, this will obtain a new token\n    once the current token is expired. Expiration is detected based on the `expires_in` hint\n    returned by the AS. A configurable `leeway`, in number of seconds, will make sure that a new\n    token is obtained some seconds before the actual expiration is reached. This may help in\n    situations where the client, AS and RS have slightly offset clocks.\n\n    Args:\n        client: an OAuth2Client\n        token: an initial Access Token, if you have one already. In most cases, leave `None`.\n        leeway: expiration leeway, in number of seconds\n        token_kwargs: additional kwargs to include in token requests\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        token: None | BearerToken | str = None,\n        leeway: int = 20,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(token)\n        self.client = client\n        self.leeway = leeway\n        self.token_kwargs = token_kwargs\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        token = self.token\n        if token is None or token.is_expired(self.leeway):\n            self.renew_token()\n        return super().__call__(request)\n\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new Bearer Token.\n\n        Subclasses should implement this.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def forget_token(self) -&gt; None:\n        \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n        self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RenewableTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new Bearer Token.</p> <p>Subclasses should implement this.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n    \"\"\"Obtain a new Bearer Token.\n\n    Subclasses should implement this.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BaseOAuth2RenewableTokenAuth.forget_token","title":"<code>forget_token()</code>","text":"<p>Forget the current token, forcing a renewal on the next HTTP request.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def forget_token(self) -&gt; None:\n    \"\"\"Forget the current token, forcing a renewal on the next HTTP request.\"\"\"\n    self.token = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>             Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2ClientCredentialsAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"An Auth Handler for the Client Credentials grant.\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access Tokens from an OAuth\n    2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current\n    one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n\n    \"\"\"\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>             Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer token, and can automatically refresh it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to refresh tokens.</p> required <code>token</code> <code>None | BearerToken | str</code> <p>a access token that has been previously obtained</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken(     access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\" )  # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2AccessTokenAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"Authentication Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as\n    Bearer token, and can automatically refresh it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a\n    [BearerToken][requests_oauth2client.tokens.BearerToken] that can contain a refresh_token. If a\n    refresh_token and an expiration date are available, this Auth Handler will automatically refresh\n    the access token once it is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens.\n        token: a access token that has been previously obtained\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        token = BearerToken(\n            access_token=\"access_token\", expires_in=600, refresh_token=\"refresh_token\"\n        )  # obtain a BearerToken any way you see fit, including a refresh token\n        oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth)\n        ````\n\n    \"\"\"\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Obtain a new token, using the Refresh Token, if available.\"\"\"\n        if self.token and self.token.refresh_token and self.client is not None:\n            self.token = self.client.refresh_token(refresh_token=self.token.refresh_token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token, using the Refresh Token, if available.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Obtain a new token, using the Refresh Token, if available.\"\"\"\n    if self.token and self.token.refresh_token and self.client is not None:\n        self.token = self.client.refresh_token(refresh_token=self.token.refresh_token, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>             Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>code</code> <code>str | AuthorizationResponse</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\"  # you must obtain this code yourself resp = requests.post(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code)) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2AuthorizationCodeAuth(OAuth2AccessTokenAuth):\n    \"\"\"Authentication handler for the Authorization Code grant.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\"  # you must obtain this code yourself\n        resp = requests.post(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ````\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        code: str | AuthorizationResponse,\n        leeway: int = 20,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(client, token=None, leeway=leeway, **token_kwargs)\n        self.code: str | AuthorizationResponse | None = code\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in\n            Authorization Header\n\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n        \"\"\"Obtain the initial access token with the authorization_code grant.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Obtain the initial access token with the authorization_code grant.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n    \"\"\"Obtain the initial access token with the authorization_code grant.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ResourceOwnerPasswordAuth","title":"<code>OAuth2ResourceOwnerPasswordAuth</code>","text":"<p>             Bases: <code>BaseOAuth2RenewableTokenAuth</code></p> <p>Authentication Handler for the Resource Owner Password Flow.</p> <p>This Requests Auth handler implementation exchanges the user credentials for an Access Token, then automatically obtains a new one once it is expired.</p> <p>Note that this flow is considered deprecated, and the Authorization Code flow should be used whenever possible. Among other bad things, ROPC does not support SSO nor MFA and depends on the user typing its credentials directly inside the application instead of on a dedicated login page, which makes it totally insecure for 3rd party apps.</p> <p>It needs the username and password and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens</p> required <code>username</code> <code>str</code> <p>the username</p> required <code>password</code> <code>str</code> <p>the user password</p> required <code>leeway</code> <code>int</code> <p>an amount of time, in seconds</p> <code>20</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2ResourceOwnerPasswordAuth(BaseOAuth2RenewableTokenAuth):\n    \"\"\"Authentication Handler for the [Resource Owner Password Flow](https://www.rfc-editor.org/rfc/rfc6749#section-4.3).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges the user\n    credentials for an Access Token, then automatically obtains a new one once it is expired.\n\n    Note that this flow is considered *deprecated*, and the Authorization Code flow should be\n    used whenever possible. Among other bad things, ROPC does not support SSO nor MFA and\n    depends on the user typing its credentials directly inside the application instead of on a\n    dedicated login page, which makes it totally insecure for 3rd party apps.\n\n    It needs the username and password and an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get a token from\n    the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain\n            Access Tokens\n        username: the username\n        password: the user password\n        leeway: an amount of time, in seconds\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        username: str,\n        password: str,\n        leeway: int = 20,\n        **token_kwargs: Any,\n    ):\n        super().__init__(client=client, leeway=leeway, **token_kwargs)\n        self.username = username\n        self.password = password\n\n    @override\n    def renew_token(self) -&gt; None:\n        \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n        self.token = self.client.resource_owner_password(\n            username=self.username,\n            password=self.password,\n            **self.token_kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ResourceOwnerPasswordAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Exchange the user credentials for an Access Token.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>@override\ndef renew_token(self) -&gt; None:\n    \"\"\"Exchange the user credentials for an Access Token.\"\"\"\n    self.token = self.client.resource_owner_password(\n        username=self.username,\n        password=self.password,\n        **self.token_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>             Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = client.device_authorization() auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=auth) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2DeviceCodeAuth(OAuth2AccessTokenAuth):\n    \"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be\n    able to get a token from the AS Token Endpoint just before the first request using this Auth\n    Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ````\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        leeway: int = 20,\n        interval: int = 5,\n        expires_in: int = 360,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(client=client, leeway=leeway, token=None, **token_kwargs)\n        self.device_code: str | DeviceAuthorizationResponse | None = device_code\n        self.interval = interval\n        self.expires_in = expires_in\n\n    @override\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n        \"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            while self.token is None:\n                self.token = pooling_job()\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n    \"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        while self.token is None:\n            self.token = pooling_job()\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request","title":"<code>authorization_request</code>","text":"<p>Classes and utilities related to Authorization Requests and Responses.</p>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n    \"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n\n    \"\"\"\n\n    code_verifier_re = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n    \"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n        \"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a `code_verifier` ready to use for PKCE\n\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: str | bytes, method: str = \"S256\") -&gt; str:\n        \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `code_challenge` derived from the given verifier\n\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_re.match(verifier):\n            msg = f\"Invalid code verifier, does not match {cls.code_verifier_re}\"\n            raise ValueError(\n                msg,\n                verifier,\n            )\n\n        if method == \"S256\":\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        elif method == \"plain\":\n            return verifier\n        else:\n            msg = \"Unsupported code_challenge_method\"\n            raise ValueError(msg, method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = \"S256\") -&gt; tuple[str, str]:\n        \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a `(code_verifier, code_challenge)` tuple.\n\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(cls, verifier: str, challenge: str, method: str = \"S256\") -&gt; bool:\n        \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n\n        \"\"\"\n        return cls.code_verifier_re.match(verifier) is not None and cls.derive_challenge(verifier, method) == challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.code_verifier_re","title":"<code>code_verifier_re = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_verifier</code> ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n    \"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a `code_verifier` ready to use for PKCE\n\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method='S256')</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str | bytes</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>str</code> <p>a <code>code_challenge</code> derived from the given verifier</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: str | bytes, method: str = \"S256\") -&gt; str:\n    \"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `code_challenge` derived from the given verifier\n\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_re.match(verifier):\n        msg = f\"Invalid code verifier, does not match {cls.code_verifier_re}\"\n        raise ValueError(\n            msg,\n            verifier,\n        )\n\n    if method == \"S256\":\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    elif method == \"plain\":\n        return verifier\n    else:\n        msg = \"Unsupported code_challenge_method\"\n        raise ValueError(msg, method)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method='S256')</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and derive its <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a <code>(code_verifier, code_challenge)</code> tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = \"S256\") -&gt; tuple[str, str]:\n    \"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a `(code_verifier, code_challenge)` tuple.\n\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method='S256')</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(cls, verifier: str, challenge: str, method: str = \"S256\") -&gt; bool:\n    \"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n\n    \"\"\"\n    return cls.code_verifier_re.match(verifier) is not None and cls.derive_challenge(verifier, method) == challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.CodeChallengeMethods","title":"<code>CodeChallengeMethods</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>PKCE Code Challenge Methods.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class CodeChallengeMethods(str, Enum):\n    \"\"\"PKCE Code Challenge Methods.\"\"\"\n\n    plain = \"plain\"\n    S256 = \"S256\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:</p> <ul> <li>all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional    parameters such as <code>state</code>.</li> <li>the redirect_uri that was used for the Authorization Request</li> <li>the code_verifier matching the code_challenge that was used for the Authorization Request</li> </ul> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>the authorization code returned by the AS</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>code_verifier</code> <code>str | None</code> <p>the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>state</code> <code>str | None</code> <p>the state returned by the AS</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationResponse:\n    \"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS to the client's redirection\n    endpoint (redirect_uri) after an Authorization Request. This Response is typically created with\n    a call to `AuthorizationRequest.validate_callback()` once the call to the client Redirection\n    Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:\n\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional\n       parameters such as `state`.\n     - the redirect_uri that was used for the Authorization Request\n     - the code_verifier matching the code_challenge that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching\n    `AuthorizationRequest`. All other parameters including `code` and `state` must be those\n    extracted from the Authorization Response parameters.\n\n    Args:\n        code: the authorization code returned by the AS\n        redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest\n        code_verifier: the code_verifier matching the code_challenge that was passed as\n            parameter in the AuthorizationRequest\n        state: the state returned by the AS\n        **kwargs: other parameters as returned by the AS\n\n    \"\"\"\n\n    code: str\n    redirect_uri: str | None = None\n    code_verifier: str | None = None\n    state: str | None = None\n    nonce: str | None = None\n    acr_values: tuple[str, ...] | None = None\n    max_age: int | None = None\n    issuer: str | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    def __init__(\n        self,\n        *,\n        code: str,\n        redirect_uri: str | None = None,\n        code_verifier: str | None = None,\n        state: str | None = None,\n        nonce: str | None = None,\n        acr_values: str | Sequence[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        **kwargs: str,\n    ):\n        if not acr_values:\n            acr_values = None\n        elif isinstance(acr_values, str):\n            acr_values = tuple(acr_values.split(\" \"))\n        else:\n            acr_values = tuple(acr_values)\n\n        self.__attrs_init__(\n            code=code,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n            state=state,\n            nonce=nonce,\n            acr_values=acr_values,\n            max_age=max_age,\n            issuer=issuer,\n            kwargs=kwargs,\n        )\n\n    def __getattr__(self, item: str) -&gt; str | None:\n        \"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n\n        \"\"\"\n        return self.kwargs.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represent an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if <code>...</code> (default), a random <code>state</code> parameter will be generated for you.   You may pass your own <code>state</code> as <code>str</code>, or set it to <code>None</code> so that the <code>state</code> parameter   will not be included in the request. You may access that state in the <code>state</code> attribute   from this request.</li> <li><code>nonce</code>: if <code>...</code> (default) and <code>scope</code> includes 'openid', a random <code>nonce</code> will be   generated and included in the request. You may access that <code>nonce</code> in the <code>nonce</code> attribute   from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>,   a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated,   and the <code>code_challenge</code> will be included in the request.   You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the   appropriate <code>code_challenge</code> will be included in the request, according to the   <code>code_challenge_method</code>.</li> <li><code>authorization_response_iss_parameter_supported</code> and <code>issuer</code>:    those are used for Server Issuer Identification. If <code>\u00ecssuer</code> is set and an issuer is    included in the Authorization Response, then the consistency between those 2 values will be    checked when using <code>validate_callback()</code>. If issuer is not included in the response, and    <code>authorization_response_iss_parameter_supported</code> is <code>False</code> (default), then no issuer check    is performed. Set <code>authorization_response_iss_parameter_supported</code>    to <code>True</code> to enforce server identification: if no issuer is included in the Authorization    Response, then an error will be raised instead.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>'code'</code> <code>state</code> <code>str | ellipsis | None</code> <p>the state to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>the nonce to include in the request, or <code>...</code> to autogenerate one (default).</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>str | None</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>'S256'</code> <code>acr_values</code> <code>str | Iterable[str] | None</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass AuthorizationRequest:\n    \"\"\"Represent an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a\n    state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization\n    Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    - `state`: if `...` (default), a random `state` parameter will be generated for you.\n      You may pass your own `state` as `str`, or set it to `None` so that the `state` parameter\n      will not be included in the request. You may access that state in the `state` attribute\n      from this request.\n    - `nonce`: if `...` (default) and `scope` includes 'openid', a random `nonce` will be\n      generated and included in the request. You may access that `nonce` in the `nonce` attribute\n      from this request.\n    - `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`,\n      a valid `code_challenge` and `code_verifier` for PKCE will be automatically generated,\n      and the `code_challenge` will be included in the request.\n      You may pass your own `code_verifier` as a `str` parameter, in which case the\n      appropriate `code_challenge` will be included in the request, according to the\n      `code_challenge_method`.\n    - `authorization_response_iss_parameter_supported` and `issuer`:\n       those are used for Server Issuer Identification. If `\u00ecssuer` is set and an issuer is\n       included in the Authorization Response, then the consistency between those 2 values will be\n       checked when using `validate_callback()`. If issuer is not included in the response, and\n       `authorization_response_iss_parameter_supported` is `False` (default), then no issuer check\n       is performed. Set `authorization_response_iss_parameter_supported`\n       to `True` to enforce server identification: if no issuer is included in the Authorization\n       Response, then an error will be raised instead.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization\n            Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `...` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `...` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request.\n            If left as `None` and `code_challenge_method` is set, a valid code_verifier\n            will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n\n    \"\"\"\n\n    authorization_endpoint: str\n\n    client_id: str = field(metadata={\"query\": True})\n    redirect_uri: str | None = field(metadata={\"query\": True}, default=None)\n    scope: tuple[str, ...] | None = field(metadata={\"query\": True}, default=(\"openid\",))\n    response_type: str = field(metadata={\"query\": True}, default=\"code\")\n    state: str | None = field(metadata={\"query\": True}, default=None)\n    nonce: str | None = field(metadata={\"query\": True}, default=None)\n    code_challenge_method: str | None = field(metadata={\"query\": True}, default=\"S256\")\n    acr_values: tuple[str, ...] | None = field(metadata={\"query\": True}, default=None)\n    max_age: int | None = field(metadata={\"query\": True}, default=None)\n    kwargs: dict[str, Any] = Factory(dict)\n\n    code_verifier: str | None = None\n    code_challenge: str | None = field(init=False, metadata={\"query\": True})\n    authorization_response_iss_parameter_supported: bool = False\n    issuer: str | None = None\n\n    exception_classes: ClassVar[dict[str, type[Exception]]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n        \"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n        \"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        authorization_endpoint: str,\n        *,\n        client_id: str,\n        redirect_uri: str | None = None,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = \"code\",\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        code_challenge_method: str | None = \"S256\",\n        acr_values: str | Iterable[str] | None = None,\n        max_age: int | None = None,\n        issuer: str | None = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            msg = (\n                \"When 'authorization_response_iss_parameter_supported' is `True`, you must\"\n                \" provide the expected `issuer` as parameter.\"\n            )\n            raise ValueError(msg)\n\n        if state is ...:\n            state = self.generate_state()\n        if state is not None and not isinstance(state, str):\n            state = str(state)  # pragma: no cover\n\n        if nonce is ...:\n            nonce = self.generate_nonce() if scope is not None and \"openid\" in scope else None\n        if nonce is not None and not isinstance(nonce, str):\n            nonce = str(nonce)  # pragma: no cover\n\n        if not scope:\n            scope = None\n\n        if scope is not None:\n            scope = tuple(scope.split(\" \")) if isinstance(scope, str) else tuple(scope)\n\n        if acr_values is not None:\n            acr_values = tuple(acr_values.split()) if isinstance(acr_values, str) else tuple(acr_values)\n\n        if max_age is not None and max_age &lt; 0:\n            msg = \"The `max_age` parameter is a number of seconds and cannot be negative.\"\n            raise ValueError(msg)\n\n        if \"code_challenge\" in kwargs:\n            msg = (\n                \"A `code_challenge` must not be passed as parameter. Pass the `code_verifier`\"\n                \" instead, and the appropriate `code_challenge` will automatically be derived\"\n                \" from it and included in the request, based on `code_challenge_method`.\"\n            )\n            raise ValueError(msg)\n\n        code_challenge: str | None = None\n        if code_challenge_method:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n            code_challenge = PkceUtils.derive_challenge(code_verifier, code_challenge_method)\n        else:\n            code_verifier = None\n\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            issuer=issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=code_challenge_method,\n            acr_values=acr_values,\n            max_age=max_age,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            kwargs=kwargs,\n        )\n        object.__setattr__(self, \"code_challenge\", code_challenge)\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the full argument dict.\n\n        This can be used to serialize this request and/or to initialize a similar request.\n\n        \"\"\"\n        d = asdict(self)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return d\n\n    @property\n    def args(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict with all the query parameters from this AuthorizationRequest.\n\n        Returns:\n            a dict of parameters\n\n        \"\"\"\n        d = {field.name: getattr(self, field.name) for field in fields(type(self)) if field.metadata.get(\"query\")}\n        if d[\"scope\"]:\n            d[\"scope\"] = \" \".join(d[\"scope\"])\n        d.update(self.kwargs)\n\n        return {key: val for key, val in d.items() if val is not None}\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization Request, and return\n        an\n        [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting\n        the returned `code` and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the\n                query parameters (still encoded as x-www-form-urlencoded).\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MismatchingIssuer: if the 'iss' received from the response does not match the\n                expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            NotImplementedError: if response_type anything else than 'code'.\n\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer()\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if \"code\" in self.response_type:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode()\n        else:\n            raise NotImplementedError()\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            **response_url.args,\n        )\n\n    def sign_request_jwt(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n    ) -&gt; SignedJwt:\n        \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed request.\n                If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Jwk | dict[str, Any],\n        alg: str | None = None,\n        lifetime: int | None = None,\n        **kwargs: Any,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, don't use an 'exp' claim.\n            kwargs: additional query parameters to include in the signed authorization request\n\n        Returns:\n            the signed Authorization Request\n\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n            **kwargs,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; JweCompact:\n        \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n\n        \"\"\"\n        claims = self.args\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Jwk | dict[str, Any],\n        enc_jwk: Jwk | dict[str, Any],\n        sign_alg: str | None = None,\n        enc_alg: str | None = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: int | None = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n        \"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n                By default, do not include an 'exp' claim.\n\n        Returns:\n            a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n        \"\"\"Error handler for Authorization Response errors.\n\n        Triggered by\n        [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n        if the response uri contains an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method\n            will most likely raise exceptions instead.\n\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(error, error_description, error_uri)\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args=self.args,\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.args","title":"<code>args: dict[str, Any]</code>  <code>property</code>","text":"<p>Return a dict with all the query parameters from this AuthorizationRequest.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>a dict of parameters</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n    \"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n    \"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the full argument dict.</p> <p>This can be used to serialize this request and/or to initialize a similar request.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the full argument dict.\n\n    This can be used to serialize this request and/or to initialize a similar request.\n\n    \"\"\"\n    d = asdict(self)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return d\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters (still encoded as x-www-form-urlencoded).</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MismatchingIssuer</code> <p>if the 'iss' received from the response does not match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>NotImplementedError</code> <p>if response_type anything else than 'code'.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization Request, and return\n    an\n    [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting\n    the returned `code` and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the\n            query parameters (still encoded as x-www-form-urlencoded).\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MismatchingIssuer: if the 'iss' received from the response does not match the\n            expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        NotImplementedError: if response_type anything else than 'code'.\n\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer()\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if \"code\" in self.response_type:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode()\n    else:\n        raise NotImplementedError()\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>an optional number of seconds of validity for the signed request. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n) -&gt; SignedJwt:\n    \"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed request.\n            If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None, **kwargs)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional query parameters to include in the signed authorization request</p> <code>{}</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Jwk | dict[str, Any],\n    alg: str | None = None,\n    lifetime: int | None = None,\n    **kwargs: Any,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the provided `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, don't use an 'exp' claim.\n        kwargs: additional query parameters to include in the signed authorization request\n\n    Returns:\n        the signed Authorization Request\n\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; JweCompact:\n    \"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n\n    \"\"\"\n    claims = self.args\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>str | None</code> <p>the alg to use to sign the request, if <code>sign_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>str | None</code> <p>the alg to use to encrypt the request, if <code>enc_jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>int | None</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>a <code>RequestParameterAuthorizationRequest</code>, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Jwk | dict[str, Any],\n    enc_jwk: Jwk | dict[str, Any],\n    sign_alg: str | None = None,\n    enc_alg: str | None = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: int | None = None,\n) -&gt; RequestParameterAuthorizationRequest:\n    \"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if `sign_jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if `enc_jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim).\n            By default, do not include an 'exp' claim.\n\n    Returns:\n        a `RequestParameterAuthorizationRequest`, with a request object as parameter\n\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method</p> <code>AuthorizationResponse</code> <p>will most likely raise exceptions instead.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n    \"\"\"Error handler for Authorization Response errors.\n\n    Triggered by\n    [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback]\n    if the response uri contains an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method\n        will most likely raise exceptions instead.\n\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(error, error_description, error_uri)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>str</code> <p>the request JWT</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request: str\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ):\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request=request,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": self.request, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request_uri</code> <code>str</code> <p>the request_uri</p> required <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for this request</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>extra parameters to include in the request</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@frozen(init=False)\nclass RequestUriParameterAuthorizationRequest:\n    \"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request_uri: the request_uri\n        expires_at: the expiration date for this request\n        kwargs: extra parameters to include in the request\n\n    \"\"\"\n\n    authorization_endpoint: str\n    client_id: str\n    request_uri: str\n    expires_at: datetime | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request_uri: str,\n        expires_at: datetime | None = None,\n        **kwargs: Any,\n    ):\n        self.__attrs_init__(\n            authorization_endpoint=authorization_endpoint,\n            client_id=client_id,\n            request_uri=request_uri,\n            expires_at=expires_at,\n            kwargs=kwargs,\n        )\n\n    @property\n    def furl(self) -&gt; furl:\n        \"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri, **self.kwargs},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"Allow attribute access to extra parameters.\"\"\"\n        return self.kwargs[item]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n    \"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client-\n    side. This class is here to help you do that.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[AuthorizationRequest], str] | None = None,\n        loader: Callable[[str], AuthorizationRequest] | None = None,\n    ):\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n        base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        d = asdict(azr)\n        d.update(**d.pop(\"kwargs\", {}))\n        d.pop(\"code_challenge\")\n        return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n\n    @staticmethod\n    def default_loader(\n        serialized: str, azr_class: type[AuthorizationRequest] = AuthorizationRequest\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n            azr_class: the class to deserialize the Authorization Request to\n\n        Returns:\n            an AuthorizationRequest\n\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n        \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n        \"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as\n    base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    d = asdict(azr)\n    d.update(**d.pop(\"kwargs\", {}))\n    d.pop(\"code_challenge\")\n    return BinaPy.serialize_to(\"json\", d).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>  <code>staticmethod</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <code>azr_class</code> <code>type[AuthorizationRequest]</code> <p>the class to deserialize the Authorization Request to</p> <code>AuthorizationRequest</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_loader(\n    serialized: str, azr_class: type[AuthorizationRequest] = AuthorizationRequest\n) -&gt; AuthorizationRequest:\n    \"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n        azr_class: the class to deserialize the Authorization Request to\n\n    Returns:\n        an AuthorizationRequest\n\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n    \"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n    \"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication","title":"<code>backchannel_authentication</code>","text":"<p>Implementation of CIBA.</p> <p>CIBA stands for Client Initiated BackChannel Authentication and is standardised by the OpenID Fundation. https://openid.net/specs/openid-client-initiated-backchannel- authentication-core-1_0.html.</p>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n    \"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel\n    Authentication Request, such as `auth_req_id` (required), and the optional `expires_at`,\n    `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: datetime | None = None,\n        interval: int | None = 20,\n        **kwargs: Any,\n    ):\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n        derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n        this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or\n        `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n\n        \"\"\"\n        if key == \"expires_in\":\n            if self.expires_at is None:\n                return None\n            return int(self.expires_at.timestamp() - datetime.now(tz=timezone.utc).timestamp())\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is\n    derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint),\n    this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>             Bases: <code>TokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> <p>auth=(\"client_id\", \"client_secret\") ) pool_job = BackChannelAuthenticationPoolingJob( client=client, auth_req_id=\"my_auth_req_id\" )</p> <pre><code>token = None while token is None: token = pool_job() ```\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationPoolingJob(TokenEndpointPoolingJob):\n    \"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\",\n    auth=(\"client_id\", \"client_secret\") ) pool_job = BackChannelAuthenticationPoolingJob(\n    client=client, auth_req_id=\"my_auth_req_id\" )\n\n        token = None while token is None: token = pool_job() ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        *,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ):\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse) and interval is None:\n            interval = auth_req_id.interval\n\n        super().__init__(\n            client=client,\n            interval=interval,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs,\n            **token_kwargs,\n        )\n        self.auth_req_id = auth_req_id\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.ciba(self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client","title":"<code>client</code>","text":"<p>This module contains the <code>OAuth2Client</code> class.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint. Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be:</p> <ul> <li>a requests.auth.AuthBase instance (which will be used as-is)</li> <li>a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost</li> <li>a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt,</li> <li>or a <code>client_id</code> which will use PublicApp authentication.</li> </ul> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID (use either this or <code>auth</code>)</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret (use either this or <code>auth</code>)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private_key to use for client authentication (use either this or <code>auth</code>)</p> <code>None</code> <code>revocation_endpoint</code> <code>str | None</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>str | None</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>str | None</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>str | None</code> <p>the Authorization Endpoint URI, used for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>str | None</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>str | None</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>str | None</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>str | None</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>'S256'</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if <code>True</code>, don't verify the validity of the endpoint urls that are passed as parameter.</p> <code>False</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@frozen(init=False)\nclass OAuth2Client:\n    \"\"\"An OAuth 2.x Client, that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised\n    Grant Types, and to communicate with the various backend endpoints like the Revocation,\n    Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials\n    (a client_id and one of a secret or private_key) that will be used to authenticate to that endpoint.\n    Other endpoint urls, such as the Authorization Endpoint, Revocation Endpoint, etc. can be passed as\n    parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in\n    a browser. For authentication requests, see\n    [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest]. You\n    may use the method `authorization_request()` to generate `AuthorizationRequest`s with the\n    preconfigured `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint.\n            Can be:\n\n            - a [requests.auth.AuthBase][] instance (which will be used as-is)\n            - a tuple of `(client_id, client_secret)` which will initialize an instance\n            of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost]\n            - a `(client_id, jwk)` to initialize\n            a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt],\n            - or a `client_id` which will\n            use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n\n        client_id: client ID (use either this or `auth`)\n        client_secret: client secret (use either this or `auth`)\n        private_key: private_key to use for client authentication (use either this or `auth`)\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI, used for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests.\n            Useful if some extra parameters such as proxy or client certificate must be used\n            to connect to the AS.\n        testing: if `True`, don't verify the validity of the endpoint urls that are passed as parameter.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be\n            used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Usage:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            client_id=\"client_id\",\n            client_secret=\"client_secret\",\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n\n    \"\"\"\n\n    auth: requests.auth.AuthBase = field(converter=client_auth_factory)\n    token_endpoint: str = field()\n    revocation_endpoint: str | None = field()\n    introspection_endpoint: str | None = field()\n    userinfo_endpoint: str | None = field()\n    authorization_endpoint: str | None = field()\n    redirect_uri: str | None = field()\n    backchannel_authentication_endpoint: str | None = field()\n    device_authorization_endpoint: str | None = field()\n    pushed_authorization_request_endpoint: str | None = field()\n    jwks_uri: str | None = field()\n    authorization_server_jwks: JwkSet\n    issuer: str | None = field()\n    id_token_signed_response_alg: str | None = SignatureAlgs.RS256\n    id_token_encrypted_response_alg: str | None = None\n    id_token_decryption_key: Jwk | None = None\n    code_challenge_method: str | None = \"S256\"\n    authorization_response_iss_parameter_supported: bool = False\n    session: requests.Session = field(factory=requests.Session)\n    extra_metadata: dict[str, Any] = field(factory=dict)\n    testing: bool = False\n\n    bearer_token_class: type[BearerToken] = BearerToken\n\n    exception_classes: ClassVar[dict[str, type[Exception]]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    def __init__(  # noqa: PLR0913\n        self,\n        token_endpoint: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        revocation_endpoint: str | None = None,\n        introspection_endpoint: str | None = None,\n        userinfo_endpoint: str | None = None,\n        authorization_endpoint: str | None = None,\n        redirect_uri: str | None = None,\n        backchannel_authentication_endpoint: str | None = None,\n        device_authorization_endpoint: str | None = None,\n        pushed_authorization_request_endpoint: str | None = None,\n        jwks_uri: str | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        issuer: str | None = None,\n        id_token_signed_response_alg: str | None = SignatureAlgs.RS256,\n        id_token_encrypted_response_alg: str | None = None,\n        id_token_decryption_key: Jwk | dict[str, Any] | None = None,\n        code_challenge_method: str = \"S256\",\n        authorization_response_iss_parameter_supported: bool = False,\n        bearer_token_class: type[BearerToken] = BearerToken,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **extra_metadata: Any,\n    ):\n        if authorization_response_iss_parameter_supported and not issuer:\n            msg = (\n                \"If the Authorization Server supports Issuer Identification, as specified by\"\n                \" `authorization_response_iss_parameter_supported=True`, then you must specify\"\n                \" the expected `issuer` value with parameter `issuer`.\"\n            )\n            raise ValueError(msg)\n\n        auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n\n        if authorization_server_jwks is None:\n            authorization_server_jwks = JwkSet()\n        elif not isinstance(authorization_server_jwks, JwkSet):\n            authorization_server_jwks = JwkSet(authorization_server_jwks)\n\n        if id_token_decryption_key is not None and not isinstance(id_token_decryption_key, Jwk):\n            id_token_decryption_key = Jwk(id_token_decryption_key)\n\n        if id_token_decryption_key is not None and id_token_encrypted_response_alg is None:\n            if id_token_decryption_key.alg:\n                id_token_encrypted_response_alg = id_token_decryption_key.alg\n            else:\n                msg = (\n                    \"An ID Token decryption key has been provided but no decryption algorithm is defined.\"\n                    \" You can either pass an `id_token_encrypted_response_alg` parameter with the alg identifier,\"\n                    \" or include an `alg` attribute in the decryption key, if it is in Jwk format.\"\n                )\n                raise ValueError(msg)\n\n        if session is None:\n            session = requests.Session()\n\n        self.__attrs_init__(\n            testing=testing,\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            redirect_uri=redirect_uri,\n            backchannel_authentication_endpoint=backchannel_authentication_endpoint,\n            device_authorization_endpoint=device_authorization_endpoint,\n            pushed_authorization_request_endpoint=pushed_authorization_request_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            issuer=issuer,\n            session=session,\n            auth=auth,\n            id_token_signed_response_alg=id_token_signed_response_alg,\n            id_token_encrypted_response_alg=id_token_encrypted_response_alg,\n            id_token_decryption_key=id_token_decryption_key,\n            code_challenge_method=code_challenge_method,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            bearer_token_class=bearer_token_class,\n            extra_metadata=extra_metadata,\n        )\n\n    @token_endpoint.validator\n    @revocation_endpoint.validator\n    @introspection_endpoint.validator\n    @userinfo_endpoint.validator\n    @authorization_endpoint.validator\n    @backchannel_authentication_endpoint.validator\n    @device_authorization_endpoint.validator\n    @pushed_authorization_request_endpoint.validator\n    @jwks_uri.validator\n    def validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an endpoint URI is suitable for use.\n\n        If you need to disable some checks (for AS testing purposes only!), provide a different\n        method here.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_endpoint_uri(uri)\n        except ValueError as exc:\n            msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n            raise ValueError(msg) from exc\n\n    @issuer.validator\n    def validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n        \"\"\"Validate that an Issuer identifier is suitable for use.\n\n        This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n        \"\"\"\n        if self.testing or uri is None:\n            return uri\n        try:\n            return validate_issuer_uri(uri)\n        except ValueError as exc:\n            msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n            raise ValueError(msg) from exc\n\n    @property\n    def client_id(self) -&gt; str:\n        \"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        msg = \"This client uses a custom authentication method without client_id.\"\n        raise AttributeError(msg)  # pragma: no cover\n\n    @property\n    def client_secret(self) -&gt; str | None:\n        \"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n        \"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def _request(\n        self,\n        endpoint: str,\n        on_success: Callable[[requests.Response], T],\n        on_failure: Callable[[requests.Response], T],\n        accept: str = \"application/json\",\n        method: str = \"POST\",\n        **requests_kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Send a request to one of the endpoints.\n\n        This is a helper method that takes care of the following tasks:\n\n        - make sure the endpoint as been configured\n        - set `Accept: application/json` header\n        - send the HTTP POST request, then\n            - apply `on_success` to a successful response\n            - or apply `on_failure` otherwise\n        - return the result\n\n        Args:\n            endpoint: name of the endpoint to use\n            on_success: a callable to apply to successful responses\n            on_failure: a callable to apply to error responses\n            accept: the Accept header to include in the request\n            method: the HTTP method to use\n            **requests_kwargs: keyword arguments for the request\n\n        \"\"\"\n        endpoint_uri = self._require_endpoint(endpoint)\n        requests_kwargs.setdefault(\"headers\", {})\n        requests_kwargs[\"headers\"][\"Accept\"] = accept\n\n        response = self.session.request(\n            method,\n            endpoint_uri,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return on_success(response)\n\n        return on_failure(response)\n\n    def token_request(\n        self,\n        data: dict[str, Any],\n        timeout: int = 10,\n        **requests_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n          data: parameters to send to the token endpoint. Items with a `None`\n               or empty value will not be sent in the request.\n          timeout: a timeout value for the call\n          **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response, as\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n        \"\"\"\n        return self._request(\n            \"token_endpoint\",\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            on_success=self.parse_token_response,\n            on_failure=self.on_token_error,\n            **requests_kwargs,\n        )\n\n    def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n        responses returned by the Token Endpoint. Those responses contain an `access_token` and\n        additional attributes.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n            contents.\n\n        \"\"\"\n        try:\n            token_response = self.bearer_token_class(**response.json())\n        except Exception as response_class_exc:\n            try:\n                return self.on_token_error(response)\n            except Exception as token_error_exc:\n                raise token_error_exc from response_class_exc\n        else:\n            return token_response\n\n    def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n        \"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n        Token Endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a\n            [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n            behaviour if needed.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidTokenResponse(response) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: str | Iterable[str] | None = None,\n        *,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n        Returns:\n            a TokenResponse\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                msg = \"Unsupported scope value\"\n                raise ValueError(msg) from exc\n\n        data = dict(grant_type=GrantType.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: str | AuthorizationResponse,\n        *,\n        validate: bool = True,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        Args:\n             code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n             validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n             requests_kwargs: additional parameters for the call to requests\n             **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        azr: AuthorizationResponse | None = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=GrantType.AUTHORIZATION_CODE, code=code, **token_kwargs)\n        token = self.token_request(data, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            return token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        Args:\n            refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n                That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: additional parameters for the call to `requests`\n            **token_kwargs: additional parameters for the token endpoint,\n                alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n                msg = \"This BearerToken doesn't have a refresh_token\"\n                raise ValueError(msg)\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=GrantType.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: str | DeviceAuthorizationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n        or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: a device code, or a `DeviceAuthorizationResponse`\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                msg = \"This DeviceAuthorizationResponse doesn't have a device_code\"\n                raise ValueError(msg)\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantType.DEVICE_CODE,\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: str | BackChannelAuthenticationResponse,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            a `BearerToken`\n\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                msg = \"This `BackChannelAuthenticationResponse` doesn't have an `auth_req_id`\"\n                raise ValueError(msg)\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantType.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        subject_token: str | BearerToken | IdToken,\n        subject_token_type: str | None = None,\n        actor_token: None | str | BearerToken | IdToken = None,\n        actor_token_type: str | None = None,\n        requested_token_type: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n        `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: the subject token to exchange for a new token.\n            subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: the actor token to include in the request, if any.\n            actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: a token type identifier for the requested token.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError:\n            msg = \"Cannot determine the kind of 'subject_token' you provided. Please specify a 'subject_token_type'.\"\n            raise TypeError(msg) from None\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError:\n                msg = \"Cannot determine the kind of 'actor_token' you provided. Please specify an 'actor_token_type'.\"\n                raise TypeError(msg) from None\n\n        data = dict(\n            grant_type=GrantType.TOKEN_EXCHANGE,\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Jwt | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using a JWT as authorization grant.\n\n        This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=GrantType.JWT_BEARER,\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n        \"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=GrantType.RESOURCE_OWNER_PASSWORD,\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        *,\n        scope: None | str | Iterable[str] = \"openid\",\n        response_type: str = \"code\",\n        redirect_uri: str | None = None,\n        state: str | ellipsis | None = ...,  # noqa: F821\n        nonce: str | ellipsis | None = ...,  # noqa: F821\n        code_verifier: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n        \"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: the `scope` to use\n            response_type: the `response_type` to use\n            redirect_uri: the `redirect_uri` to include in the request. By default,\n                the `redirect_uri` defined at init time is used.\n            state: the `state` parameter to use. Leave default to generate a random value.\n            nonce: a `nonce`. Leave default to generate a random value.\n            code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n            **kwargs: additional parameters to include in the auth request\n\n        Returns:\n            an AuthorizationRequest with the supplied parameters\n\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n        if not redirect_uri:\n            msg = (\n                \"No 'redirect_uri' defined for this client. You must either pass a redirect_uri\"\n                \" as parameter to this method, or include a redirect_uri when initializing your\"\n                \" OAuth2Client.\"\n            )\n            raise AttributeError(msg)\n\n        if response_type != \"code\":\n            msg = \"Only response_type=code is supported.\"\n            raise ValueError(msg)\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self,\n        authorization_request: AuthorizationRequest,\n        requests_kwargs: dict[str, Any] | None = None,\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: the authorization request to send\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        return self._request(\n            \"pushed_authorization_request_endpoint\",\n            data=authorization_request.args,\n            auth=self.auth,\n            on_success=self.parse_pushed_authorization_response,\n            on_failure=self.on_pushed_authorization_request_error,\n            **requests_kwargs,\n        )\n\n    def parse_pushed_authorization_response(\n        self, response: requests.Response\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n        Args:\n            response: the `requests.Response` returned by the PAR endpoint\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest instance\n\n        \"\"\"\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n        )\n\n    def on_pushed_authorization_request_error(\n        self, response: requests.Response\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n        \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: the HTTP response as returned by the AS PAR endpoint.\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n        Raises:\n            EndpointError: a subclass of this error depending on the error returned by the AS\n            InvalidPushedAuthorizationResponse: if the returned response is not following the\n            specifications UnknownTokenEndpointError: for unknown/unhandled errors\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response) from exc\n        raise exception\n\n    def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n        \"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n        the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n\n        \"\"\"\n        return self._request(\n            \"userinfo_endpoint\",\n            auth=BearerAuth(access_token),\n            on_success=self.parse_userinfo_response,\n            on_failure=self.on_userinfo_error,\n        )\n\n    def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n        response from the UserInfo endpoint, this will extract and return its JSON content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            the parsed JSON content from this response.\n\n        \"\"\"\n        return resp.json()\n\n    def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n        \"\"\"Parse UserInfo error response.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            nothing, raises exception instead.\n\n        \"\"\"\n        resp.raise_for_status()\n\n    @classmethod\n    def get_token_type(  # noqa: C901\n        cls,\n        token_type: str | None = None,\n        token: None | str | BearerToken | IdToken = None,\n    ) -&gt; str:\n        \"\"\"Get standardized token type identifiers.\n\n        Return a standardized token type identifier, based on a short `token_type` hint and/or a\n        token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n                or \"id_token\"\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n\n        \"\"\"\n        if not (token_type or token):\n            msg = \"Cannot determine type of an empty token without a token_type hint\"\n            raise ValueError(msg)\n\n        if token_type is None:\n            if isinstance(token, str):\n                msg = \"Cannot determine the type of provided token when it is a bare str. Please specify a token_type.\"\n                raise ValueError(msg)\n            elif isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            elif isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            else:\n                msg = \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\"\n                raise TypeError(\n                    msg,\n                    type(token),\n                )\n        elif token_type == TokenType.ACCESS_TOKEN:\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                msg = \"The supplied token is not a BearerToken or a string representation of it.\"\n                raise TypeError(\n                    msg,\n                    type(token),\n                )\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        elif token_type == TokenType.REFRESH_TOKEN:\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                msg = \"The supplied BearerToken doesn't have a refresh_token.\"\n                raise ValueError(msg)\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        elif token_type == \"id_token\":\n            if token is not None and not isinstance(token, (str, IdToken)):\n                msg = \"The supplied token is not an IdToken or a string representation of it.\"\n                raise TypeError(\n                    msg,\n                    type(token),\n                )\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n        else:\n            return {\n                \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n                \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n                \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n            }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: BearerToken | str,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=TokenType.ACCESS_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: str | BearerToken,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured\n            revocation endpoint.\n\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                raise ValueError(msg)\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=TokenType.REFRESH_TOKEN,\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n            non-standardised error is returned.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                raise ValueError(msg)\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            \"revocation_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=lambda resp: True,\n            on_failure=self.on_revocation_error,\n            **requests_kwargs,\n        )\n\n    def on_revocation_error(self, response: requests.Response) -&gt; bool:\n        \"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n        revocation endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the\n            revocation response.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception:\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: str | BearerToken,\n        token_type_hint: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Send a request to the Introspection Endpoint.\n\n        Parameter `token` can be:\n\n        - a `str`\n        - a `BearerToken` instance\n\n        You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n        be included in the request, as-is.\n        If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n        - `None`: the access_token will be instrospected and no token_type_hint will be included\n        in the request\n        - `access_token`: same as `None`, but the token_type_hint will be included\n        - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n        Args:\n            token: the token to instrospect\n            token_type_hint: the `token_type_hint` to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if isinstance(token, BearerToken):\n            if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n                token = token.access_token\n            elif token_type_hint == TokenType.REFRESH_TOKEN:\n                if token.refresh_token is None:\n                    msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                    raise ValueError(msg)\n                else:\n                    token = token.refresh_token\n            else:\n                msg = (\n                    \"Invalid `token_type_hint`. To test arbitrary `token_type_hint` values,\"\n                    \" you must provide `token` as a `str`.\"\n                )\n                raise ValueError(msg)\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        return self._request(\n            \"introspection_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_introspection_response,\n            on_failure=self.on_introspection_error,\n            **requests_kwargs,\n        )\n\n    def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n        \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response. This decodes the JSON content if possible, otherwise it\n        returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response) -&gt; Any:\n        \"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n        to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n\n        Returns:\n            usually raises exceptions. A subclass can return a default response instead.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception as exc:\n            raise UnknownIntrospectionError(response) from exc\n        raise exception\n\n    def backchannel_authentication_request(  # noqa: PLR0913\n        self,\n        scope: None | str | Iterable[str] = \"openid\",\n        *,\n        client_notification_token: str | None = None,\n        acr_values: None | str | Iterable[str] = None,\n        login_hint_token: str | None = None,\n        id_token_hint: str | None = None,\n        login_hint: str | None = None,\n        binding_message: str | None = None,\n        user_code: str | None = None,\n        requested_expiry: int | None = None,\n        private_jwk: Jwk | dict[str, Any] | None = None,\n        alg: str | None = None,\n        requests_kwargs: dict[str, Any] | None = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n\n        \"\"\"\n        if not (login_hint or login_hint_token or id_token_hint):\n            msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise ValueError(msg)\n\n        if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n            msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            raise ValueError(msg)\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                msg = \"Unsupported `scope` value\"\n                raise ValueError(msg) from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                msg = \"Unsupported `acr_values`\"\n                raise ValueError(msg) from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        return self._request(\n            \"backchannel_authentication_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_backchannel_authentication_response,\n            on_failure=self.on_backchannel_authentication_error,\n            **requests_kwargs,\n        )\n\n    def parse_backchannel_authentication_response(\n        self, response: requests.Response\n    ) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response) from exc\n\n    def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n        \"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by\n        [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n        to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n        error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response) from exc\n        raise exception\n\n    def authorize_device(\n        self, requests_kwargs: dict[str, Any] | None = None, **data: Any\n    ) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n            requests_kwargs: additional parameters for `requests.request()`\n\n        Returns:\n            a Device Authorization Response\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        return self._request(\n            \"device_authorization_endpoint\",\n            data=data,\n            auth=self.auth,\n            on_success=self.parse_device_authorization_response,\n            on_failure=self.on_device_authorization_error,\n            **requests_kwargs,\n        )\n\n    def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n\n        \"\"\"\n        device_authorization_response = DeviceAuthorizationResponse(**response.json())\n        return device_authorization_response\n\n    def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n        \"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n        to parse the response returned by the Device Authorization Endpoint, when that response is\n        an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n        \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n        available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no `jwks_uri` is configured\n\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        jwks = self._request(\n            \"jwks_uri\",\n            auth=None,\n            method=\"GET\",\n            on_success=lambda resp: resp.json(),\n            on_failure=lambda resp: resp.raise_for_status(),\n            **requests_kwargs,\n        )\n        self.authorization_server_jwks.update(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: str | None = None,\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n        This will retrieve the standardised metadata document available at `url`, and will extract\n        all Endpoint Uris from that document, will fetch the current public keys from its\n        `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n        Args:\n             url: the url where the server metadata will be retrieved\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             session: a `requests.Session` to use to retrieve the document and initialise the client with\n             issuer: if an issuer is given, check that it matches the one from the retrieved document\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional keyword parameters to pass to OAuth2Client\n\n        Returns:\n            an OAuth2Client with endpoint initialised based on the obtained metadata\n\n        Raises:\n            ValueError: if neither `url` nor `issuer` are suitable urls\n            requests.HTTPError: if an error happens while fetching the documents\n\n        \"\"\"\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            msg = \"Please specify at least one of `issuer` or `url`\"\n            raise ValueError(msg)\n\n        validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri:\n            jwks = JwkSet(session.get(jwks_uri).json())\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            testing=testing,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(  # noqa: PLR0913\n        cls,\n        discovery: dict[str, Any],\n        issuer: str | None = None,\n        *,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_key: Jwk | dict[str, Any] | None = None,\n        authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n        session: requests.Session | None = None,\n        https: bool = True,\n        testing: bool = False,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n             testing: if True, don't try to validate the endpoint urls that are part of the document\n             **kwargs: additional args that will be passed to OAuth2Client\n\n        Returns:\n            an `OAuth2Client`\n\n        \"\"\"\n        if not https:\n            warnings.warn(\n                \"The https parameter is deprecated.\"\n                \" To disable endpoint uri validation, set `testing=True` when initializing your OAuth2Client.\",\n                stacklevel=1,\n            )\n            testing = True\n        if issuer and discovery.get(\"issuer\") != issuer:\n            msg = \"Mismatching issuer value in discovery document: \"\n            raise ValueError(\n                msg,\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        elif issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(\"token_endpoint\")\n        if token_endpoint is None:\n            msg = \"token_endpoint not found in that discovery document\"\n            raise ValueError(msg)\n        authorization_endpoint = discovery.get(\"authorization_endpoint\")\n        revocation_endpoint = discovery.get(\"revocation_endpoint\")\n        introspection_endpoint = discovery.get(\"introspection_endpoint\")\n        userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri is not None:\n            validate_endpoint_uri(jwks_uri, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\", False\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            testing=testing,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; OAuth2Client:\n        \"\"\"Allow using `OAuth2Client` as a context-manager.\n\n        The Authorization Server public keys are retrieved on `__enter__`.\n\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; bool:  # noqa: D105\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n        \"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            msg = (\n                f\"No '{endpoint}' defined for this client. Please provide the URL for that\"\n                f\" endpoint when initializing your {self.__class__.__name__} instance.\"\n            )\n            raise AttributeError(msg)\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_id","title":"<code>client_id: str</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_secret","title":"<code>client_secret: str | None</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_jwks","title":"<code>client_jwks: JwkSet</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.validate_endpoint_uri","title":"<code>validate_endpoint_uri(attribute, uri)</code>","text":"<p>Validate that an endpoint URI is suitable for use.</p> <p>If you need to disable some checks (for AS testing purposes only!), provide a different method here.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@token_endpoint.validator\n@revocation_endpoint.validator\n@introspection_endpoint.validator\n@userinfo_endpoint.validator\n@authorization_endpoint.validator\n@backchannel_authentication_endpoint.validator\n@device_authorization_endpoint.validator\n@pushed_authorization_request_endpoint.validator\n@jwks_uri.validator\ndef validate_endpoint_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an endpoint URI is suitable for use.\n\n    If you need to disable some checks (for AS testing purposes only!), provide a different\n    method here.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_endpoint_uri(uri)\n    except ValueError as exc:\n        msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n        raise ValueError(msg) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.validate_issuer_uri","title":"<code>validate_issuer_uri(attribute, uri)</code>","text":"<p>Validate that an Issuer identifier is suitable for use.</p> <p>This is the same check as an endpoint URI, but the path may be (and usually is) empty.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@issuer.validator\ndef validate_issuer_uri(self, attribute: Attribute[str | None], uri: str | None) -&gt; str | None:\n    \"\"\"Validate that an Issuer identifier is suitable for use.\n\n    This is the same check as an endpoint URI, but the path may be (and usually is) empty.\n\n    \"\"\"\n    if self.testing or uri is None:\n        return uri\n    try:\n        return validate_issuer_uri(uri)\n    except ValueError as exc:\n        msg = f\"Invalid value '{uri}' for '{attribute.name}': {exc}\"\n        raise ValueError(msg) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_request","title":"<code>token_request(data, timeout=10, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a <code>None</code>    or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response, as</p> <code>BearerToken</code> <p><code>BearerToken</code> instance.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self,\n    data: dict[str, Any],\n    timeout: int = 10,\n    **requests_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n      data: parameters to send to the token endpoint. Items with a `None`\n           or empty value will not be sent in the request.\n      timeout: a timeout value for the call\n      **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response, as\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n\n    \"\"\"\n    return self._request(\n        \"token_endpoint\",\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        on_success=self.parse_token_response,\n        on_failure=self.on_token_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those responses contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response</p> <code>BearerToken</code> <p>contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse\n    responses returned by the Token Endpoint. Those responses contain an `access_token` and\n    additional attributes.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response\n        contents.\n\n    \"\"\"\n    try:\n        token_response = self.bearer_token_class(**response.json())\n    except Exception as response_class_exc:\n        try:\n            return self.on_token_error(response)\n        except Exception as token_error_exc:\n            raise token_error_exc from response_class_exc\n    else:\n        return token_response\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_token_error","title":"<code>on_token_error(response)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a</p> <code>BearerToken</code> <p><code>BearerToken</code> to implement a default</p> <code>BearerToken</code> <p>behaviour if needed.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n    \"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the\n    Token Endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a\n        [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default\n        behaviour if needed.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidTokenResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, *, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>str | Iterable[str] | None</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>. Common parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a TokenResponse</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: str | Iterable[str] | None = None,\n    *,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n    Returns:\n        a TokenResponse\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            msg = \"Unsupported scope value\"\n            raise ValueError(msg) from exc\n\n    data = dict(grant_type=GrantType.CLIENT_CREDENTIALS, scope=scope, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, *, validate=True, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str | AuthorizationResponse</code> <p>an authorization code or an <code>AuthorizationResponse</code> to exchange for tokens</p> required <code>validate</code> <code>bool</code> <p>if <code>True</code>, validate the received ID Token (this works only if <code>code</code> is an AuthorizationResponse)</p> <code>True</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: str | AuthorizationResponse,\n    *,\n    validate: bool = True,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    Args:\n         code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n         validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n         requests_kwargs: additional parameters for the call to requests\n         **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    azr: AuthorizationResponse | None = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=GrantType.AUTHORIZATION_CODE, code=code, **token_kwargs)\n    token = self.token_request(data, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        return token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>a refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to <code>requests</code></p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    Args:\n        refresh_token: a refresh_token, as a string, or as a `BearerToken`.\n            That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: additional parameters for the call to `requests`\n        **token_kwargs: additional parameters for the token endpoint,\n            alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(refresh_token.refresh_token, str):\n            msg = \"This BearerToken doesn't have a refresh_token\"\n            raise ValueError(msg)\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=GrantType.REFRESH_TOKEN, refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.device_code","title":"<code>device_code(device_code, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a device code, or a <code>DeviceAuthorizationResponse</code></p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: str | DeviceAuthorizationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`. This needs a Device Code,\n    or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: a device code, or a `DeviceAuthorizationResponse`\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            msg = \"This DeviceAuthorizationResponse doesn't have a device_code\"\n            raise ValueError(msg)\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantType.DEVICE_CODE,\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str | BackChannelAuthenticationResponse</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: str | BackChannelAuthenticationResponse,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        a `BearerToken`\n\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            msg = \"This `BackChannelAuthenticationResponse` doesn't have an `auth_req_id`\"\n            raise ValueError(msg)\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantType.CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION,\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_exchange","title":"<code>token_exchange(subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>str | BearerToken | IdToken</code> <p>the subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>str | None</code> <p>a token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>None | str | BearerToken | IdToken</code> <p>the actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>str | None</code> <p>a token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>str | None</code> <p>a token type identifier for the requested token.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    subject_token: str | BearerToken | IdToken,\n    subject_token_type: str | None = None,\n    actor_token: None | str | BearerToken | IdToken = None,\n    actor_token_type: str | None = None,\n    requested_token_type: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type\n    `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: the subject token to exchange for a new token.\n        subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: the actor token to include in the request, if any.\n        actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: a token type identifier for the requested token.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError:\n        msg = \"Cannot determine the kind of 'subject_token' you provided. Please specify a 'subject_token_type'.\"\n        raise TypeError(msg) from None\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError:\n            msg = \"Cannot determine the kind of 'actor_token' you provided. Please specify an 'actor_token_type'.\"\n            raise TypeError(msg) from None\n\n    data = dict(\n        grant_type=GrantType.TOKEN_EXCHANGE,\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Jwt | str</code> <p>a JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Jwt | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using a JWT as authorization grant.\n\n    This is defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=GrantType.JWT_BEARER,\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n    \"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=GrantType.RESOURCE_OWNER_PASSWORD,\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_request","title":"<code>authorization_request(*, scope='openid', response_type='code', redirect_uri=None, state=..., nonce=..., code_verifier=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the <code>scope</code> to use</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the <code>response_type</code> to use</p> <code>'code'</code> <code>redirect_uri</code> <code>str | None</code> <p>the <code>redirect_uri</code> to include in the request. By default, the <code>redirect_uri</code> defined at init time is used.</p> <code>None</code> <code>state</code> <code>str | ellipsis | None</code> <p>the <code>state</code> parameter to use. Leave default to generate a random value.</p> <code>...</code> <code>nonce</code> <code>str | ellipsis | None</code> <p>a <code>nonce</code>. Leave default to generate a random value.</p> <code>...</code> <code>code_verifier</code> <code>str | None</code> <p>the PKCE <code>code_verifier</code> to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters to include in the auth request</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest with the supplied parameters</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    *,\n    scope: None | str | Iterable[str] = \"openid\",\n    response_type: str = \"code\",\n    redirect_uri: str | None = None,\n    state: str | ellipsis | None = ...,  # noqa: F821\n    nonce: str | ellipsis | None = ...,  # noqa: F821\n    code_verifier: str | None = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n    \"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: the `scope` to use\n        response_type: the `response_type` to use\n        redirect_uri: the `redirect_uri` to include in the request. By default,\n            the `redirect_uri` defined at init time is used.\n        state: the `state` parameter to use. Leave default to generate a random value.\n        nonce: a `nonce`. Leave default to generate a random value.\n        code_verifier: the PKCE `code_verifier` to use. Leave default to generate a random value.\n        **kwargs: additional parameters to include in the auth request\n\n    Returns:\n        an AuthorizationRequest with the supplied parameters\n\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n    if not redirect_uri:\n        msg = (\n            \"No 'redirect_uri' defined for this client. You must either pass a redirect_uri\"\n            \" as parameter to this method, or include a redirect_uri when initializing your\"\n            \" OAuth2Client.\"\n        )\n        raise AttributeError(msg)\n\n    if response_type != \"code\":\n        msg = \"Only response_type=code is supported.\"\n        raise ValueError(msg)\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request, requests_kwargs=None)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>the authorization request to send</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>the <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self,\n    authorization_request: AuthorizationRequest,\n    requests_kwargs: dict[str, Any] | None = None,\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: the authorization request to send\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    return self._request(\n        \"pushed_authorization_request_endpoint\",\n        data=authorization_request.args,\n        auth=self.auth,\n        on_success=self.parse_pushed_authorization_response,\n        on_failure=self.on_pushed_authorization_request_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_pushed_authorization_response","title":"<code>parse_pushed_authorization_response(response)</code>","text":"<p>Parse the response obtained by <code>pushed_authorization_request()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the <code>requests.Response</code> returned by the PAR endpoint</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest instance</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_pushed_authorization_response(\n    self, response: requests.Response\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Parse the response obtained by `pushed_authorization_request()`.\n\n    Args:\n        response: the `requests.Response` returned by the PAR endpoint\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest instance\n\n    \"\"\"\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response as returned by the AS PAR endpoint.</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest, if the error is recoverable</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>a subclass of this error depending on the error returned by the AS</p> <code>InvalidPushedAuthorizationResponse</code> <p>if the returned response is not following the</p> <code>specifications UnknownTokenEndpointError</code> <p>for unknown/unhandled errors</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self, response: requests.Response\n) -&gt; RequestUriParameterAuthorizationRequest:\n    \"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: the HTTP response as returned by the AS PAR endpoint.\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n    Raises:\n        EndpointError: a subclass of this error depending on the error returned by the AS\n        InvalidPushedAuthorizationResponse: if the returned response is not following the\n        specifications UnknownTokenEndpointError: for unknown/unhandled errors\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: BearerToken | str) -&gt; Any:\n    \"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns\n    the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n\n    \"\"\"\n    return self._request(\n        \"userinfo_endpoint\",\n        auth=BearerAuth(access_token),\n        on_success=self.parse_userinfo_response,\n        on_failure=self.on_userinfo_error,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the\n    response from the UserInfo endpoint, this will extract and return its JSON content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        the parsed JSON content from this response.\n\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_userinfo_error","title":"<code>on_userinfo_error(resp)</code>","text":"<p>Parse UserInfo error response.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>nothing, raises exception instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_userinfo_error(self, resp: requests.Response) -&gt; Any:\n    \"\"\"Parse UserInfo error response.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        nothing, raises exception instead.\n\n    \"\"\"\n    resp.raise_for_status()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardized token type identifiers.</p> <p>Return a standardized token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>str | None</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\"</p> <code>None</code> <code>token</code> <code>None | str | BearerToken | IdToken</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef get_token_type(  # noqa: C901\n    cls,\n    token_type: str | None = None,\n    token: None | str | BearerToken | IdToken = None,\n) -&gt; str:\n    \"\"\"Get standardized token type identifiers.\n\n    Return a standardized token type identifier, based on a short `token_type` hint and/or a\n    token value.\n\n    Args:\n        token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\"\n            or \"id_token\"\n        token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n    Returns:\n        the token_type as defined in the Token Exchange RFC8693.\n\n    \"\"\"\n    if not (token_type or token):\n        msg = \"Cannot determine type of an empty token without a token_type hint\"\n        raise ValueError(msg)\n\n    if token_type is None:\n        if isinstance(token, str):\n            msg = \"Cannot determine the type of provided token when it is a bare str. Please specify a token_type.\"\n            raise ValueError(msg)\n        elif isinstance(token, BearerToken):\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        elif isinstance(token, IdToken):\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n        else:\n            msg = \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\"\n            raise TypeError(\n                msg,\n                type(token),\n            )\n    elif token_type == TokenType.ACCESS_TOKEN:\n        if token is not None and not isinstance(token, (str, BearerToken)):\n            msg = \"The supplied token is not a BearerToken or a string representation of it.\"\n            raise TypeError(\n                msg,\n                type(token),\n            )\n        return \"urn:ietf:params:oauth:token-type:access_token\"\n    elif token_type == TokenType.REFRESH_TOKEN:\n        if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n            msg = \"The supplied BearerToken doesn't have a refresh_token.\"\n            raise ValueError(msg)\n        return \"urn:ietf:params:oauth:token-type:refresh_token\"\n    elif token_type == \"id_token\":\n        if token is not None and not isinstance(token, (str, IdToken)):\n            msg = \"The supplied token is not an IdToken or a string representation of it.\"\n            raise TypeError(\n                msg,\n                type(token),\n            )\n        return \"urn:ietf:params:oauth:token-type:id_token\"\n    else:\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>BearerToken | str</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: BearerToken | str,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=TokenType.ACCESS_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str | BearerToken</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured</p> <code>bool</code> <p>revocation endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: str | BearerToken,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured\n        revocation endpoint.\n\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            msg = \"The supplied BearerToken doesn't have a refresh token.\"\n            raise ValueError(msg)\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=TokenType.REFRESH_TOKEN,\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>str | None</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds, <code>False</code> if no revocation endpoint is present or a</p> <code>bool</code> <p>non-standardised error is returned.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n    \"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation succeeds, `False` if no revocation endpoint is present or a\n        non-standardised error is returned.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == TokenType.REFRESH_TOKEN and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            msg = \"The supplied BearerToken doesn't have a refresh token.\"\n            raise ValueError(msg)\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        \"revocation_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=lambda resp: True,\n        on_failure=self.on_revocation_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Revocation Endpoint</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the</p> <code>bool</code> <p>revocation response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response) -&gt; bool:\n    \"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the\n    revocation endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the\n        revocation response.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception:\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the Introspection Endpoint.</p> <p>Parameter <code>token</code> can be:</p> <ul> <li>a <code>str</code></li> <li>a <code>BearerToken</code> instance</li> </ul> <p>You may pass any arbitrary <code>token</code> and <code>token_type_hint</code> values as <code>str</code>. Those will be included in the request, as-is. If <code>token</code> is a <code>BearerToken</code>, then <code>token_type_hint</code> must be either:</p> <ul> <li><code>None</code>: the access_token will be instrospected and no token_type_hint will be included in the request</li> <li><code>access_token</code>: same as <code>None</code>, but the token_type_hint will be included</li> <li>or <code>refresh_token</code>: only available if a Refresh Token is present in the BearerToken.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str | BearerToken</code> <p>the token to instrospect</p> required <code>token_type_hint</code> <code>str | None</code> <p>the <code>token_type_hint</code> to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def introspect_token(\n    self,\n    token: str | BearerToken,\n    token_type_hint: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **introspect_kwargs: Any,\n) -&gt; Any:\n    \"\"\"Send a request to the Introspection Endpoint.\n\n    Parameter `token` can be:\n\n    - a `str`\n    - a `BearerToken` instance\n\n    You may pass any arbitrary `token` and `token_type_hint` values as `str`. Those will\n    be included in the request, as-is.\n    If `token` is a `BearerToken`, then `token_type_hint` must be either:\n\n    - `None`: the access_token will be instrospected and no token_type_hint will be included\n    in the request\n    - `access_token`: same as `None`, but the token_type_hint will be included\n    - or `refresh_token`: only available if a Refresh Token is present in the BearerToken.\n\n    Args:\n        token: the token to instrospect\n        token_type_hint: the `token_type_hint` to include in the request.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n    Returns:\n        the response as returned by the Introspection Endpoint.\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if isinstance(token, BearerToken):\n        if token_type_hint is None or token_type_hint == TokenType.ACCESS_TOKEN:\n            token = token.access_token\n        elif token_type_hint == TokenType.REFRESH_TOKEN:\n            if token.refresh_token is None:\n                msg = \"The supplied BearerToken doesn't have a refresh token.\"\n                raise ValueError(msg)\n            else:\n                token = token.refresh_token\n        else:\n            msg = (\n                \"Invalid `token_type_hint`. To test arbitrary `token_type_hint` values,\"\n                \" you must provide `token` as a `str`.\"\n            )\n            raise ValueError(msg)\n\n    data = dict(introspect_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    return self._request(\n        \"introspection_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_introspection_response,\n        on_failure=self.on_introspection_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n    \"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response. This decodes the JSON content if possible, otherwise it\n    returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exceptions. A subclass can return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response) -&gt; Any:\n    \"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token]\n    to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n\n    Returns:\n        usually raises exceptions. A subclass can return a default response instead.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception as exc:\n        raise UnknownIntrospectionError(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', *, client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>None | str | Iterable[str]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>str | None</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>None | str | Iterable[str]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>str | None</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>str | None</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>str | None</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>str | None</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>str | None</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>int | None</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Jwk | dict[str, Any] | None</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>str | None</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(  # noqa: PLR0913\n    self,\n    scope: None | str | Iterable[str] = \"openid\",\n    *,\n    client_notification_token: str | None = None,\n    acr_values: None | str | Iterable[str] = None,\n    login_hint_token: str | None = None,\n    id_token_hint: str | None = None,\n    login_hint: str | None = None,\n    binding_message: str | None = None,\n    user_code: str | None = None,\n    requested_expiry: int | None = None,\n    private_jwk: Jwk | dict[str, Any] | None = None,\n    alg: str | None = None,\n    requests_kwargs: dict[str, Any] | None = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n\n    \"\"\"\n    if not (login_hint or login_hint_token or id_token_hint):\n        msg = \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise ValueError(msg)\n\n    if (login_hint_token and id_token_hint) or (login_hint and id_token_hint) or (login_hint_token and login_hint):\n        msg = \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        raise ValueError(msg)\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            msg = \"Unsupported `scope` value\"\n            raise ValueError(msg) from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            msg = \"Unsupported `acr_values`\"\n            raise ValueError(msg) from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    return self._request(\n        \"backchannel_authentication_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_backchannel_authentication_response,\n        on_failure=self.on_backchannel_authentication_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self, response: requests.Response\n) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(self, response: requests.Response) -&gt; BackChannelAuthenticationResponse:\n    \"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by\n    [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request]\n    to parse the response returned by the BackChannel Authentication Endpoint, when it is an\n    error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorize_device","title":"<code>authorize_device(requests_kwargs=None, **data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for <code>requests.request()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(\n    self, requests_kwargs: dict[str, Any] | None = None, **data: Any\n) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n        requests_kwargs: additional parameters for `requests.request()`\n\n    Returns:\n        a Device Authorization Response\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    return self._request(\n        \"device_authorization_endpoint\",\n        data=data,\n        auth=self.auth,\n        on_success=self.parse_device_authorization_response,\n        on_failure=self.on_device_authorization_error,\n        **requests_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n\n    \"\"\"\n    device_authorization_response = DeviceAuthorizationResponse(**response.json())\n    return device_authorization_response\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(self, response: requests.Response) -&gt; DeviceAuthorizationResponse:\n    \"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device]\n    to parse the response returned by the Device Authorization Endpoint, when that response is\n    an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys(requests_kwargs=None)</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a <code>jwskate.JwkSet</code>. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no <code>jwks_uri</code> is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self, requests_kwargs: dict[str, Any] | None = None) -&gt; JwkSet:\n    \"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a `jwskate.JwkSet`. They are also\n    available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no `jwks_uri` is configured\n\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    jwks = self._request(\n        \"jwks_uri\",\n        auth=None,\n        method=\"GET\",\n        on_success=lambda resp: resp.json(),\n        on_failure=lambda resp: resp.raise_for_status(),\n        **requests_kwargs,\n    )\n    self.authorization_server_jwks.update(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, session=None, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client based on Authorization Server Metadata.</p> <p>This will retrieve the standardised metadata document available at <code>url</code>, and will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialise an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>the url where the server metadata will be retrieved</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a <code>requests.Session</code> to use to retrieve the document and initialise the client with</p> <code>None</code> <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one from the retrieved document</p> <code>None</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters to pass to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an OAuth2Client with endpoint initialised based on the obtained metadata</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if neither <code>url</code> nor <code>issuer</code> are suitable urls</p> <code>HTTPError</code> <p>if an error happens while fetching the documents</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: str | None = None,\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n    This will retrieve the standardised metadata document available at `url`, and will extract\n    all Endpoint Uris from that document, will fetch the current public keys from its\n    `jwks_uri`, then will initialise an OAuth2Client based on those endpoints.\n\n    Args:\n         url: the url where the server metadata will be retrieved\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         session: a `requests.Session` to use to retrieve the document and initialise the client with\n         issuer: if an issuer is given, check that it matches the one from the retrieved document\n         testing: if True, don't try to validate the endpoint urls that are part of the document\n         **kwargs: additional keyword parameters to pass to OAuth2Client\n\n    Returns:\n        an OAuth2Client with endpoint initialised based on the obtained metadata\n\n    Raises:\n        ValueError: if neither `url` nor `issuer` are suitable urls\n        requests.HTTPError: if an error happens while fetching the documents\n\n    \"\"\"\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        msg = \"Please specify at least one of `issuer` or `url`\"\n        raise ValueError(msg)\n\n    validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri:\n        jwks = JwkSet(session.get(jwks_uri).json())\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, *, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, session=None, https=True, testing=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client, based on the server metadata from <code>discovery</code>.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>dict[str, Any]</code> <p>a dict of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>str | None</code> <p>if an issuer is given, check that it matches the one mentioned in the document</p> <code>None</code> <code>auth</code> <code>AuthBase | tuple[str, str] | str | None</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>private key to sign client assertions</p> <code>None</code> <code>authorization_server_jwks</code> <code>JwkSet | dict[str, Any] | None</code> <p>the current authorization server JWKS keys</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>a requests Session to use to retrieve the document and initialise the client with</p> <code>None</code> <code>https</code> <code>bool</code> <p>(deprecated) if <code>True</code>, validates that urls in the discovery document use the https scheme</p> <code>True</code> <code>testing</code> <code>bool</code> <p>if True, don't try to validate the endpoint urls that are part of the document</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>additional args that will be passed to OAuth2Client</p> <code>{}</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an <code>OAuth2Client</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_document(  # noqa: PLR0913\n    cls,\n    discovery: dict[str, Any],\n    issuer: str | None = None,\n    *,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    authorization_server_jwks: JwkSet | dict[str, Any] | None = None,\n    session: requests.Session | None = None,\n    https: bool = True,\n    testing: bool = False,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client, based on the server metadata from `discovery`.\n\n    Args:\n         discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n         issuer: if an issuer is given, check that it matches the one mentioned in the document\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         authorization_server_jwks: the current authorization server JWKS keys\n         session: a requests Session to use to retrieve the document and initialise the client with\n         https: (deprecated) if `True`, validates that urls in the discovery document use the https scheme\n         testing: if True, don't try to validate the endpoint urls that are part of the document\n         **kwargs: additional args that will be passed to OAuth2Client\n\n    Returns:\n        an `OAuth2Client`\n\n    \"\"\"\n    if not https:\n        warnings.warn(\n            \"The https parameter is deprecated.\"\n            \" To disable endpoint uri validation, set `testing=True` when initializing your OAuth2Client.\",\n            stacklevel=1,\n        )\n        testing = True\n    if issuer and discovery.get(\"issuer\") != issuer:\n        msg = \"Mismatching issuer value in discovery document: \"\n        raise ValueError(\n            msg,\n            issuer,\n            discovery.get(\"issuer\"),\n        )\n    elif issuer is None:\n        issuer = discovery.get(\"issuer\")\n\n    token_endpoint = discovery.get(\"token_endpoint\")\n    if token_endpoint is None:\n        msg = \"token_endpoint not found in that discovery document\"\n        raise ValueError(msg)\n    authorization_endpoint = discovery.get(\"authorization_endpoint\")\n    revocation_endpoint = discovery.get(\"revocation_endpoint\")\n    introspection_endpoint = discovery.get(\"introspection_endpoint\")\n    userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri is not None:\n        validate_endpoint_uri(jwks_uri, https=https)\n    authorization_response_iss_parameter_supported = discovery.get(\n        \"authorization_response_iss_parameter_supported\", False\n    )\n\n    return cls(\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        introspection_endpoint=introspection_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        jwks_uri=jwks_uri,\n        authorization_server_jwks=authorization_server_jwks,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        session=session,\n        issuer=issuer,\n        authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n        testing=testing,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.GrantType","title":"<code>GrantType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardized <code>grant_type</code> values.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class GrantType(str, Enum):\n    \"\"\"An enum of standardized `grant_type` values.\"\"\"\n\n    CLIENT_CREDENTIALS = \"client_credentials\"\n    AUTHORIZATION_CODE = \"authorization_code\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RESOURCE_OWNER_PASSWORD = \"password\"\n    TOKEN_EXCHANGE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    JWT_BEARER = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n    CLIENT_INITIATED_BACKCHANNEL_AUTHENTICATION = \"urn:openid:params:grant-type:ciba\"\n    DEVICE_CODE = \"urn:ietf:params:oauth:grant-type:device_code\"\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication","title":"<code>client_authentication</code>","text":"<p>This module implements OAuth 2.0 Client Authentication Methods.</p> <p>An OAuth 2.0 Client must authenticate to the AS whenever it sends a request to the Token Endpoint, by including appropriate credentials. This module contains helper classes and methods that implement the standardized and commonly used Client Authentication Methods.</p>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>             Bases: <code>AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends [requests.auth.AuthBase].</p> <p>This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class BaseClientAuthenticationMethod(requests.auth.AuthBase):\n    \"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase].\n\n    This base class only checks that requests are suitable to add Client Authentication parameters\n    to, and doesn't modify the request.\n\n    \"\"\"\n\n    def __init__(self, client_id: str):\n        self.client_id = str(client_id)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            msg = \"This request is not suitable for OAuth 2.0 Client Authentication\"\n            raise RuntimeError(msg)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the Authorization header, with the \"Basic\" scheme, in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p><code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p><code>client_secret</code> to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretBasic(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the Authorization header, with\n    the \"Basic\" scheme, in each authenticated request to the AS.\n\n    Args:\n        client_id: `client_id` to use.\n        client_secret: `client_secret` to use.\n\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str):\n        super().__init__(client_id)\n        self.client_secret = str(client_secret)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such: `Authorization: Basic\n        BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated  request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p><code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p><code>client_secret</code> to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretPost(BaseClientAuthenticationMethod):\n    \"\"\"Implement `client_secret_post` client authentication method.\n\n     With this method, the client inserts its client_id and client_secret in each authenticated\n     request to the AS.\n\n    Args:\n        client_id: `client_id` to use.\n        client_secret: `client_secret` to use.\n\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        super().__init__(client_id)\n        self.client_secret = str(client_secret)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if isinstance(request.body, (str, bytes))\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_secret\"] = [self.client_secret.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod","title":"<code>ClientAssertionAuthenticationMethod</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion-based client authentication methods.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the client_id to use</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> required <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> required <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> required <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n    \"\"\"Base class for assertion-based client authentication methods.\n\n    Args:\n        client_id: the client_id to use\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        alg: str,\n        lifetime: int,\n        jti_gen: Callable[[], str],\n        aud: str | None = None,\n    ) -&gt; None:\n        super().__init__(client_id)\n        self.alg = alg\n        self.lifetime = lifetime\n        self.jti_gen = jti_gen\n        self.aud = aud\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        raise NotImplementedError()  # pragma: no cover\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        if audience is None:\n            msg = \"No url defined for this request. This should never happen...\"  # pragma: no cover\n            raise ValueError(msg)  # pragma: no cover\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        client_assertion = self.client_assertion(audience)\n        params[b\"client_id\"] = [self.client_id.encode()]\n        params[b\"client_assertion\"] = [client_assertion.encode()]\n        params[b\"client_assertion_type\"] = [b\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    raise NotImplementedError()  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>             Bases: <code>ClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, the client generates and signs a client assertion that is symmetrically signed with its Client Secret. The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>'HS256'</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], Any]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: uuid4()</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretJwt(ClientAssertionAuthenticationMethod):\n    \"\"\"Implement `client_secret_jwt` client authentication method.\n\n    With this method, the client generates and signs a client assertion that is symmetrically\n    signed with its Client Secret. The assertion is then sent to the AS in a `client_assertion`\n    field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        alg: str = \"HS256\",\n        lifetime: int = 60,\n        jti_gen: Callable[[], Any] = lambda: uuid4(),\n        aud: str | None = None,\n    ) -&gt; None:\n        super().__init__(client_id, alg, lifetime, jti_gen, aud)\n        self.client_secret = str(client_secret)\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>             Bases: <code>ClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Jwk | dict[str, Any]</code> <p>the private JWK to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>RS256</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], Any]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda: uuid4()</code> <code>aud</code> <code>str | None</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class PrivateKeyJwt(ClientAssertionAuthenticationMethod):\n    \"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is asymmetrically\n    signed with a private key, on each direct request to the Authorization Server.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private JWK to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Jwk | dict[str, Any],\n        alg: str = SignatureAlgs.RS256,\n        lifetime: int = 60,\n        jti_gen: Callable[[], Any] = lambda: uuid4(),\n        aud: str | None = None,\n    ) -&gt; None:\n        if not isinstance(private_jwk, Jwk):\n            private_jwk = Jwk(private_jwk)\n\n        if not private_jwk.is_private or private_jwk.is_symmetric:\n            msg = \"Private Key JWT client authentication method uses asymmetric signing thus requires a private key.\"\n            raise ValueError(msg)\n\n        alg = private_jwk.alg or alg\n        if not alg:\n            msg = \"An asymmetric signing alg is required, either as part of the private JWK, or passed as parameter.\"\n            raise ValueError(msg)\n        kid = private_jwk.get(\"kid\")\n        if not kid:\n            msg = \"Asymmetric signing requires the private JWK to have a Key ID (kid).\"\n            raise ValueError(msg)\n\n        super().__init__(client_id, alg, lifetime, jti_gen, aud)\n        self.private_jwk = private_jwk\n\n    def client_assertion(self, audience: str) -&gt; str:\n        \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n\n        \"\"\"\n        iat = int(datetime.now(tz=timezone.utc).timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n    \"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n\n    \"\"\"\n    iat = int(datetime.now(tz=timezone.utc).timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp","title":"<code>PublicApp</code>","text":"<p>             Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the client_id to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class PublicApp(BaseClientAuthenticationMethod):\n    \"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Args:\n        client_id: the client_id to use.\n\n    \"\"\"\n\n    def __init__(self, client_id: str) -&gt; None:\n        self.client_id = client_id\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n        \"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_id` field.\n\n        \"\"\"\n        request = super().__call__(request)\n        params = (\n            parse_qs(request.body, strict_parsing=True, keep_blank_values=True)  # type: ignore[type-var]\n            if request.body\n            else {}\n        )\n        params[b\"client_id\"] = [self.client_id.encode()]\n        request.prepare_body(params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.client_auth_factory","title":"<code>client_auth_factory(auth, *, client_id=None, client_secret=None, private_key=None, default_auth_handler=ClientSecretPost)</code>","text":"<p>Initialize the appropriate Auth Handler based on the provided parameters.</p> <p>This initializes a <code>ClientAuthenticationMethod</code> subclass based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>can be:</p> <ul> <li>a <code>requests.auth.AuthBase</code> instance (which will be used directly)</li> <li>a tuple of (client_id, client_secret) which will be used to initialize an instance of   <code>default_auth_handler</code>,</li> <li>a tuple of (client_id, jwk), used to initialize a <code>PrivateKeyJwk</code> (<code>jwk</code> being an   instance of <code>jwskate.Jwk</code> or a <code>dict</code>),</li> <li>a <code>client_id</code>, as <code>str</code>,</li> <li>or <code>None</code>, to pass <code>client_id</code> and other credentials as dedicated parameters, see   below.</li> </ul> required <code>client_id</code> <code>str | None</code> <p>the Client ID to use for this client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret to use for this client, if any (for clients using an authentication method based on a secret)</p> <code>None</code> <code>private_key</code> <code>Jwk | dict[str, Any] | None</code> <p>the private key to use for private_key_jwt authentication method</p> <code>None</code> <code>default_auth_handler</code> <code>type[ClientSecretPost] | type[ClientSecretBasic] | type[ClientSecretJwt]</code> <p>if a client_id and client_secret are provided, initialize an instance of this class with those 2 parameters. You can choose between <code>ClientSecretBasic</code>, <code>ClientSecretPost</code>, or <code>ClientSecretJwt</code>.</p> <code>ClientSecretPost</code> <p>Returns:</p> Type Description <code>AuthBase</code> <p>an Auth Handler that will manage client authentication to the AS Token Endpoint or other</p> <code>AuthBase</code> <p>backend endpoints.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_auth_factory(\n    auth: requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_key: Jwk | dict[str, Any] | None = None,\n    default_auth_handler: type[ClientSecretPost] | type[ClientSecretBasic] | type[ClientSecretJwt] = ClientSecretPost,\n) -&gt; requests.auth.AuthBase:\n    \"\"\"Initialize the appropriate Auth Handler based on the provided parameters.\n\n    This initializes a `ClientAuthenticationMethod` subclass based on the provided parameters.\n\n    Args:\n        auth: can be:\n\n            - a `requests.auth.AuthBase` instance (which will be used directly)\n            - a tuple of (client_id, client_secret) which will be used to initialize an instance of\n              `default_auth_handler`,\n            - a tuple of (client_id, jwk), used to initialize a `PrivateKeyJwk` (`jwk` being an\n              instance of `jwskate.Jwk` or a `dict`),\n            - a `client_id`, as `str`,\n            - or `None`, to pass `client_id` and other credentials as dedicated parameters, see\n              below.\n        client_id: the Client ID to use for this client\n        client_secret: the Client Secret to use for this client, if any (for clients using\n            an authentication method based on a secret)\n        private_key: the private key to use for private_key_jwt authentication method\n        default_auth_handler: if a client_id and client_secret are provided, initialize an\n            instance of this class with those 2 parameters.\n            You can choose between `ClientSecretBasic`, `ClientSecretPost`, or `ClientSecretJwt`.\n\n    Returns:\n        an Auth Handler that will manage client authentication to the AS Token Endpoint or other\n        backend endpoints.\n\n    \"\"\"\n    if auth is not None and (client_id is not None or client_secret is not None or private_key is not None):\n        msg = (\n            \"Please use either `auth` parameter to provide an authentication method, or use\"\n            \" `client_id` and one of `client_secret` or `private_key`.\"\n        )\n        raise ValueError(msg)\n\n    if isinstance(auth, str):\n        client_id = auth\n    elif isinstance(auth, requests.auth.AuthBase):\n        return auth\n    elif isinstance(auth, tuple) and len(auth) == 2:  # noqa: PLR2004\n        client_id, credential = auth\n        if isinstance(credential, (Jwk, dict)):\n            private_key = credential\n        elif isinstance(credential, str):\n            client_secret = credential\n        else:\n            msg = \"This credential type is not supported:\"\n            raise TypeError(msg, type(credential), credential)\n\n    if client_id is None:\n        msg = \"A client_id must be provided.\"\n        raise ValueError(msg)\n\n    if private_key is not None:\n        return PrivateKeyJwt(str(client_id), private_key)\n    elif client_secret is None:\n        return PublicApp(str(client_id))\n    else:\n        return default_auth_handler(str(client_id), str(client_secret))\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization","title":"<code>device_authorization</code>","text":"<p>Implements the Device Authorization Flow as defined in RFC8628.</p> <p>See RFC8628.</p>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>str | None</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>datetime | None</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>int | None</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n    \"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code.\n            Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: str | None = None,\n        expires_at: datetime | None = None,\n        interval: int | None = None,\n        **kwargs: Any,\n    ):\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n            no `expires_in` hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>bool | None</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is</p> <code>bool | None</code> <p>no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is\n        no `expires_in` hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>             Bases: <code>TokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>str | DeviceAuthorizationResponse</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>int | None</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow-down request.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> <p>auth=(\"client_id\", \"client_secret\") ) pool_job = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")</p> <pre><code>token = None while token is None: token = pool_job() ```\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationPoolingJob(TokenEndpointPoolingJob):\n    \"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a Device\n    Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is\n            a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns\n            a slow-down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Usage: ```python client = OAuth2Client( token_endpoint=\"https://my.as.local/token\",\n    auth=(\"client_id\", \"client_secret\") ) pool_job = DeviceAuthorizationPoolingJob(client=client,\n    device_code=\"my_device_code\")\n\n        token = None while token is None: token = pool_job() ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        device_code: str | DeviceAuthorizationResponse,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ):\n        super().__init__(\n            client=client,\n            interval=interval,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs,\n            **token_kwargs,\n        )\n        self.device_code = device_code\n\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls [OAuth2Client.device_code(device_code)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n    \"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    return self.client.device_code(self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery","title":"<code>discovery</code>","text":"<p>Implements Metadata discovery documents URLS.</p> <p>This is as defined in RFC8615 and OpenID Connect Discovery 1.0.</p>"},{"location":"api/#requests_oauth2client.discovery.well_known_uri","title":"<code>well_known_uri(origin, name, *, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be</p> <code>str</code> <p>found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, *, at_root: bool = True) -&gt; str:\n    \"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC\n    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID\n            Connect Discovery\n            1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be\n        found.\n\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC discovery document can\n    be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery\n    1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is</p> <code>str</code> <p>made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n    \"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20 server metadata can\n    be retrieved.\n\n    The returned URL is built as specified in\n    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is\n        made.\n\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions","title":"<code>exceptions</code>","text":"<p>This module contains all exception classes from <code>requests_oauth2client</code>.</p>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the HTTP response containing the error</p> required Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n\n    \"\"\"\n\n    def __init__(self, response: requests.Response):\n        self.response = response\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n        \"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error.request","title":"<code>request: requests.PreparedRequest</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.exceptions.EndpointError","title":"<code>EndpointError</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>the raw requests.PreparedResponse containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n    \"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned by the AS in the OAuth\n    2.0 standardised way.\n\n    Args:\n        response: the raw requests.PreparedResponse containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        error: str,\n        description: str | None = None,\n        uri: str | None = None,\n    ):\n        super().__init__(response)\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n    \"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n    \"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when an otherwise unknown error is returned by the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n    \"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n    \"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n    \"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n    \"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.RevocationError","title":"<code>RevocationError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n    \"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>             Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n    \"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n    \"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n    \"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n    \"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SlowDown","title":"<code>SlowDown</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>             Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n    \"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>             Bases: <code>InvalidJwt</code></p> <p>Raised when trying to validate an invalid ID Token value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidIdToken(InvalidJwt):\n    \"\"\"Raised when trying to validate an invalid ID Token value.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>str | None</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>str | None</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n    \"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are\n    returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n\n    \"\"\"\n\n    def __init__(self, error: str, description: str | None = None, uri: str | None = None):\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>             Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n    \"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>             Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n    \"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(Exception):\n    \"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIdToken(InvalidAuthResponse):\n    \"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID\n    Token either.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the\n    value passed in the Authorization Request.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>             Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n    \"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected\n    value.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingNonce","title":"<code>MismatchingNonce</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingNonce(InvalidIdToken):\n    \"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingAcr","title":"<code>MismatchingAcr</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAcr(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingAudience","title":"<code>MismatchingAudience</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAudience(InvalidIdToken):\n    \"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingAzp","title":"<code>MismatchingAzp</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAzp(InvalidIdToken):\n    \"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>             Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n    \"\"\"Raised when the returned ID Token is expired.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>             Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n    \"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n    \"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>             Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n    \"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.flask","title":"<code>flask</code>","text":"<p>This module contains helper classes for the Flask Framework.</p> <p>See Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>             Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC grant that stores its token in Flask session.</p> <p>It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant (and can get a new one once the first one is expired), and stores the retrieved token, serialized in Flask <code>session</code>, so that each user has a different access token.</p> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):\n    \"\"\"A `requests` Auth handler for CC grant that stores its token in Flask session.\n\n    It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant\n    (and can get a new one once the first one is expired), and stores the retrieved token,\n    serialized in Flask `session`, so that each user has a different access token.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth","title":"<code>auth</code>","text":"<p>Helper classes for the Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin","title":"<code>FlaskSessionAuthMixin</code>","text":"<p>A Mixin for auth handlers to store their tokens in Flask session.</p> <p>Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens used for backend API access will be persisted between multiple requests to the front-end Flask app.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>the key that will be used to store the access token in session.</p> required <code>serializer</code> <code>BearerTokenSerializer | None</code> <p>the serializer that will be used to store the access token in session.</p> <code>None</code> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskSessionAuthMixin:\n    \"\"\"A Mixin for auth handlers to store their tokens in Flask session.\n\n    Storing tokens in Flask session does ensure that each user of a Flask application has a\n    different access token, and that tokens used for backend API access will be persisted between\n    multiple requests to the front-end Flask app.\n\n    Args:\n        session_key: the key that will be used to store the access token in session.\n        serializer: the serializer that will be used to store the access token in session.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        session_key: str,\n        serializer: BearerTokenSerializer | None = None,\n        *args: Any,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(*args, **token_kwargs)\n        self.serializer = serializer or BearerTokenSerializer()\n        self.session_key = session_key\n\n    @property\n    def token(self) -&gt; BearerToken | None:\n        \"\"\"Return the Access Token stored in session.\n\n        Returns:\n            The current `BearerToken` for this session, if any.\n\n        \"\"\"\n        serialized_token = session.get(self.session_key)\n        if serialized_token is None:\n            return None\n        return self.serializer.loads(serialized_token)\n\n    @token.setter\n    def token(self, token: BearerToken | str | None) -&gt; None:\n        \"\"\"Store an Access Token in session.\n\n        Args:\n            token: the token to store\n\n        \"\"\"\n        if isinstance(token, str):\n            token = BearerToken(token)  # pragma: no cover\n        if token:\n            serialized_token = self.serializer.dumps(token)\n            session[self.session_key] = serialized_token\n        elif session and self.session_key in session:\n            session.pop(self.session_key, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin.token","title":"<code>token: BearerToken | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the Access Token stored in session.</p> <p>Returns:</p> Type Description <code>BearerToken | None</code> <p>The current <code>BearerToken</code> for this session, if any.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>             Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC grant that stores its token in Flask session.</p> <p>It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant (and can get a new one once the first one is expired), and stores the retrieved token, serialized in Flask <code>session</code>, so that each user has a different access token.</p> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):\n    \"\"\"A `requests` Auth handler for CC grant that stores its token in Flask session.\n\n    It will automatically get Access Tokens from an OAuth 2.x AS with the Client Credentials grant\n    (and can get a new one once the first one is expired), and stores the retrieved token,\n    serialized in Flask `session`, so that each user has a different access token.\n\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling","title":"<code>pooling</code>","text":"<p>Contains base classes for pooling jobs.</p>"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob","title":"<code>TokenEndpointPoolingJob</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client that will be used to pool the token endpoint.</p> required <code>interval</code> <code>int | None</code> <p>initial pooling interval, in seconds. If <code>None</code>, default to <code>5</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>when a SlowDown is received, this number of seconds will be added to the pooling interval.</p> <code>5</code> <code>requests_kwargs</code> <code>dict[str, Any] | None</code> <p>additional parameters for the underlying calls to requests.request</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token request</p> <code>{}</code> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>class TokenEndpointPoolingJob(ABC):\n    \"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows. This needs an\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used\n            to pool the token endpoint.\n        interval: initial pooling interval, in seconds. If `None`, default to `5`.\n        slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is\n            received, this number of seconds will be added to the pooling interval.\n        requests_kwargs: additional parameters for the underlying calls to [requests.request][]\n        **token_kwargs: additional parameters for the token request\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        interval: int | None = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: dict[str, Any] | None = None,\n        **token_kwargs: Any,\n    ):\n        self.client = client\n        self.interval = interval or 5\n        self.slow_down_interval = slow_down_interval\n        self.requests_kwargs = requests_kwargs\n        self.token_kwargs = token_kwargs\n\n    def __call__(self) -&gt; BearerToken | None:\n        \"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling\n        interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So\n        you can call it immediately after initiating the BackChannel flow, and it will wait before\n        initiating the first call.\n\n        This implements the logic to handle\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] or\n        [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or\n            `None` if the Authorization is still pending.\n\n        \"\"\"\n        time.sleep(self.interval)\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.interval += self.slow_down_interval\n        except AuthorizationPending:\n            pass\n        return None\n\n    @abstractmethod\n    def token_request(self) -&gt; BearerToken:\n        \"\"\"Abstract method for the token endpoint call.\n\n        This must be implemented by subclasses. This method must Must raise\n        [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n        the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n        the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>  <code>abstractmethod</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>This must be implemented by subclasses. This method must Must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@abstractmethod\ndef token_request(self) -&gt; BearerToken:\n    \"\"\"Abstract method for the token endpoint call.\n\n    This must be implemented by subclasses. This method must Must raise\n    [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after\n    the pooling interval, or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase\n    the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens","title":"<code>tokens</code>","text":"<p>This module contains classes that represent Tokens used in OAuth2.0 / OIDC.</p>"},{"location":"api/#requests_oauth2client.tokens.TokenType","title":"<code>TokenType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardised <code>token_type</code> values.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class TokenType(str, Enum):\n    \"\"\"An enum of standardised `token_type` values.\"\"\"\n\n    ACCESS_TOKEN = \"access_token\"\n    REFRESH_TOKEN = \"refresh_token\"\n    ID_TOKEN = \"id_token\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.AccessTokenType","title":"<code>AccessTokenType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>An enum of standardised <code>access_token</code> types.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class AccessTokenType(str, Enum):\n    \"\"\"An enum of standardised `access_token` types.\"\"\"\n\n    BEARER = \"Bearer\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken","title":"<code>IdToken</code>","text":"<p>             Bases: <code>SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n    \"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded\n    beforehand.\n\n    \"\"\"\n\n    @property\n    def auth_time(self) -&gt; datetime:\n        \"\"\"The last user authentication time.\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time:\n            return self.timestamp_to_datetime(auth_time)\n        msg = \"This ID Token doesn't have an `auth_time` attribute.\"\n        raise AttributeError(msg)\n\n    @classmethod\n    def hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n        \"\"\"Returns a callable that generates valid OIDC hashes, such as at_hash, c_hash, s_hash.\n\n        Args:\n            key: the ID token signature verification public key\n            alg: the ID token signature algorithm\n\n        Returns:\n            a callable that takes a string as input and produces a valid hash as a str output\n\n        \"\"\"\n        alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n        if alg_class == jwskate.EdDsa:\n            if key.crv == \"Ed25519\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n            elif key.crv == \"Ed448\":\n\n                def hash_method(token: str) -&gt; str:\n                    return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n        return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken.auth_time","title":"<code>auth_time: datetime</code>  <code>property</code>","text":"<p>The last user authentication time.</p>"},{"location":"api/#requests_oauth2client.tokens.IdToken.hash_method","title":"<code>hash_method(key, alg=None)</code>  <code>classmethod</code>","text":"<p>Returns a callable that generates valid OIDC hashes, such as at_hash, c_hash, s_hash.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Jwk</code> <p>the ID token signature verification public key</p> required <code>alg</code> <code>str | None</code> <p>the ID token signature algorithm</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[str], str]</code> <p>a callable that takes a string as input and produces a valid hash as a str output</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@classmethod\ndef hash_method(cls, key: jwskate.Jwk, alg: str | None = None) -&gt; Callable[[str], str]:\n    \"\"\"Returns a callable that generates valid OIDC hashes, such as at_hash, c_hash, s_hash.\n\n    Args:\n        key: the ID token signature verification public key\n        alg: the ID token signature algorithm\n\n    Returns:\n        a callable that takes a string as input and produces a valid hash as a str output\n\n    \"\"\"\n    alg_class = jwskate.select_alg_class(key.SIGNATURE_ALGORITHMS, jwk_alg=key.alg, alg=alg)\n    if alg_class == jwskate.EdDsa:\n        if key.crv == \"Ed25519\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").decode()\n\n        elif key.crv == \"Ed448\":\n\n            def hash_method(token: str) -&gt; str:\n                return BinaPy(token).to(\"shake256\", 456).to(\"b64u\").decode()\n\n    else:\n        hash_alg = alg_class.hashing_alg.name\n        hash_size = alg_class.hashing_alg.digest_size\n\n        def hash_method(token: str) -&gt; str:\n            return BinaPy(token).to(hash_alg)[: hash_size // 2].to(\"b64u\").decode()\n\n    return hash_method\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.AccessToken","title":"<code>AccessToken</code>","text":"<p>Base class for Access Tokens.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class AccessToken:\n    \"\"\"Base class for Access Tokens.\"\"\"\n\n    TOKEN_TYPE: ClassVar[str]\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken","title":"<code>BearerToken</code>","text":"<p>             Bases: <code>AccessToken</code></p> <p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>datetime | None</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>str | None</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>str | bytes | IdToken | JweCompact | None</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@frozen(init=False)\nclass BearerToken(AccessToken):\n    \"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters, such as expiration date and\n    refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as\n    datetime in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in\n    the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as\n            returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n\n    \"\"\"\n\n    TOKEN_TYPE: ClassVar[str] = AccessTokenType.BEARER.value\n\n    access_token: str\n    expires_at: datetime | None = None\n    scope: str | None = None\n    refresh_token: str | None = None\n    token_type: str = TOKEN_TYPE\n    id_token: IdToken | jwskate.JweCompact | None = None\n    kwargs: dict[str, Any] = Factory(dict)\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: datetime | None = None,\n        scope: str | None = None,\n        refresh_token: str | None = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: str | bytes | IdToken | jwskate.JweCompact | None = None,\n        **kwargs: Any,\n    ):\n        if token_type.title() != self.TOKEN_TYPE.title():\n            msg = f\"Token Type is not '{self.TOKEN_TYPE}'!\"\n            raise ValueError(msg, token_type)\n        id_token_jwt: IdToken | jwskate.JweCompact | None = None\n        if isinstance(id_token, (str, bytes)):\n            try:\n                id_token_jwt = IdToken(id_token)\n            except jwskate.InvalidJwt:\n                try:\n                    id_token_jwt = jwskate.JweCompact(id_token)\n                except jwskate.InvalidJwe:\n                    msg = \"ID Token is invalid because it is  neither a JWT or a JWE.\"\n                    raise InvalidIdToken(msg) from None\n        else:\n            id_token_jwt = id_token\n        self.__attrs_init__(\n            access_token=access_token,\n            expires_at=expires_at,\n            scope=scope,\n            refresh_token=refresh_token,\n            token_type=token_type,\n            id_token=id_token_jwt,\n            kwargs=kwargs,\n        )\n\n    def is_expired(self, leeway: int = 0) -&gt; bool | None:\n        \"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds,\n                then consider it expired already.\n\n        Returns:\n            One of:\n\n            - `True` if the access token is expired\n            - `False` if it is still valid\n            - `None` if there is no expires_in hint.\n\n        \"\"\"\n        if self.expires_at:\n            return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n        \"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in an HTTP Authorization Header\n\n        \"\"\"\n        return f\"Bearer {self.access_token}\"\n\n    def validate_id_token(self, client: OAuth2Client, azr: AuthorizationResponse) -&gt; Self:  # noqa: C901, PLR0915\n        \"\"\"Validate that a token response is valid, and return the ID Token.\n\n        This will validate the id_token as described in [OIDC 1.0\n        $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        If the ID Token is encrypted, this decrypts it and returns the clear-text ID Token.\n\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken()\n\n        raw_id_token = self.id_token\n\n        if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n            msg = \"ID Token is encrypted while it should be clear-text\"\n            raise InvalidIdToken(msg, self)\n        elif isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n            msg = \"ID Token is clear-text while it should be encrypted\"\n            raise InvalidIdToken(msg, self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                msg = \"ID Token is encrypted but client does not have a decryption key\"\n                raise InvalidIdToken(msg, self)\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        if id_token.get_header(\"alg\") is None and client.id_token_signed_response_alg is None:\n            msg = (\n                \"ID Token does not contain an `alg` parameter to specify the signature\"\n                \" algorithm, and no algorithm has been configured for the client (using param\"\n                \" id_token_signed_response_alg`.\"\n            )\n            raise InvalidIdToken(msg)\n        elif client.id_token_signed_response_alg is not None and id_token.alg != client.id_token_signed_response_alg:\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg)\n\n        id_token_alg = id_token.alg or client.id_token_signed_response_alg\n\n        if azr.issuer and id_token.issuer != azr.issuer:\n            raise MismatchingIssuer(id_token.issuer, azr.issuer, self)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingAudience(id_token.audiences, client.client_id, self)\n\n        if id_token.get_claim(\"azp\") is not None and id_token.azp != client.client_id:\n            raise MismatchingAzp(id_token.azp, client.client_id, self)\n\n        if id_token.is_expired():\n            raise ExpiredIdToken(id_token)\n\n        if azr.nonce and id_token.nonce != azr.nonce:\n            raise MismatchingNonce()\n\n        if azr.acr_values and id_token.acr not in azr.acr_values:\n            raise MismatchingAcr(id_token.acr, azr.acr_values)\n\n        hash_function: Callable[[str], str]  # method used to calculate at_hash, s_hash, etc.\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                msg = \"ID Token is symmetrically signed but this client does not have a Client Secret.\"\n                raise InvalidIdToken(msg)\n            id_token.verify_signature(jwskate.SymmetricJwk.from_bytes(client.client_secret), alg=id_token_alg)\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                msg = \"ID Token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                raise InvalidIdToken(msg)\n\n            if id_token.get_header(\"kid\") is None:\n                msg = (\n                    \"ID Token does not contain a Key ID (kid) to specify the asymmetric key \"\n                    \"to use for signature verification.\"\n                )\n                raise InvalidIdToken(msg)\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                msg = (\n                    f\"ID Token is asymmetrically signed but its Key ID '{id_token.kid}' \"\n                    \"is not part of the Authorization Server JWKS.\"\n                )\n                raise InvalidIdToken(msg) from None\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                msg = \"ID Token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                raise InvalidIdToken(msg)\n\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n\n            hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                msg = f\"Mismatching 'at_hash' value: expected '{expected_at_hash}', got '{at_hash}'\"\n                raise InvalidIdToken(msg)\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                msg = f\"Mismatching 'c_hash' value: expected '{expected_c_hash}', got '{c_hash}'\"\n                raise InvalidIdToken(msg)\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                msg = \"ID Token has a 's_hash' claim but no state was included in the request.\"\n                raise InvalidIdToken(msg)\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                msg = f\"Mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}'\"\n                raise InvalidIdToken(msg)\n\n        if azr.max_age is not None:\n            try:\n                auth_time = id_token.auth_time\n            except AttributeError:\n                msg = (\n                    \"A `max_age` parameter was included in the authorization request, \"\n                    \"but the ID Token does not contain an `auth_time` claim.\"\n                )\n                raise InvalidIdToken(msg) from None\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.seconds &gt; azr.max_age + 60:\n                msg = (\n                    \"User authentication happened too long ago. The `auth_time` parameter from\"\n                    \" the ID Token indicate that the last Authentication Time was at\"\n                    f\" {auth_time} ({auth_age.seconds} sec ago), but the authorization request\"\n                    f\" `max_age` parameter specified that it must be maximum {azr.max_age} sec\"\n                    \" ago.\"\n                )\n                raise InvalidIdToken(msg)\n\n        return self.__class__(\n            access_token=self.access_token,\n            expires_at=self.expires_at,\n            scope=self.scope,\n            refresh_token=self.refresh_token,\n            token_type=self.token_type,\n            id_token=id_token,\n            **self.kwargs,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n\n        \"\"\"\n        return self.access_token\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict of parameters.\n\n        That is suitable for serialization or to init another BearerToken.\n\n        \"\"\"\n        d = asdict(self)\n        d.pop(\"expires_at\")\n        d[\"expires_in\"] = self.expires_in\n        d.update(**d.pop(\"kwargs\", {}))\n        return {key: val for key, val in d.items() if val is not None}\n\n    @property\n    def expires_in(self) -&gt; int | None:\n        \"\"\"Number of seconds until expiration.\"\"\"\n        if self.expires_at:\n            return int(self.expires_at.timestamp() - datetime.now(tz=timezone.utc).timestamp())\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n        \"\"\"Return custom attributes from this BearerToken.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n\n        \"\"\"\n        return self.kwargs.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.expires_in","title":"<code>expires_in: int | None</code>  <code>property</code>","text":"<p>Number of seconds until expiration.</p>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>One of:</p> <code>bool | None</code> <ul> <li><code>True</code> if the access token is expired</li> </ul> <code>bool | None</code> <ul> <li><code>False</code> if it is still valid</li> </ul> <code>bool | None</code> <ul> <li><code>None</code> if there is no expires_in hint.</li> </ul> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; bool | None:\n    \"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds,\n            then consider it expired already.\n\n    Returns:\n        One of:\n\n        - `True` if the access token is expired\n        - `False` if it is still valid\n        - `None` if there is no expires_in hint.\n\n    \"\"\"\n    if self.expires_at:\n        return datetime.now(tz=timezone.utc) + timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in an HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n    \"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in an HTTP Authorization Header\n\n    \"\"\"\n    return f\"Bearer {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr)</code>","text":"<p>Validate that a token response is valid, and return the ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>If the ID Token is encrypted, this decrypts it and returns the clear-text ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def validate_id_token(self, client: OAuth2Client, azr: AuthorizationResponse) -&gt; Self:  # noqa: C901, PLR0915\n    \"\"\"Validate that a token response is valid, and return the ID Token.\n\n    This will validate the id_token as described in [OIDC 1.0\n    $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n    If the ID Token is encrypted, this decrypts it and returns the clear-text ID Token.\n\n    \"\"\"\n    if not self.id_token:\n        raise MissingIdToken()\n\n    raw_id_token = self.id_token\n\n    if isinstance(raw_id_token, jwskate.JweCompact) and client.id_token_encrypted_response_alg is None:\n        msg = \"ID Token is encrypted while it should be clear-text\"\n        raise InvalidIdToken(msg, self)\n    elif isinstance(raw_id_token, IdToken) and client.id_token_encrypted_response_alg is not None:\n        msg = \"ID Token is clear-text while it should be encrypted\"\n        raise InvalidIdToken(msg, self)\n\n    if isinstance(raw_id_token, jwskate.JweCompact):\n        enc_jwk = client.id_token_decryption_key\n        if enc_jwk is None:\n            msg = \"ID Token is encrypted but client does not have a decryption key\"\n            raise InvalidIdToken(msg, self)\n        nested_id_token = raw_id_token.decrypt(enc_jwk)\n        id_token = IdToken(nested_id_token)\n    else:\n        id_token = raw_id_token\n\n    if id_token.get_header(\"alg\") is None and client.id_token_signed_response_alg is None:\n        msg = (\n            \"ID Token does not contain an `alg` parameter to specify the signature\"\n            \" algorithm, and no algorithm has been configured for the client (using param\"\n            \" id_token_signed_response_alg`.\"\n        )\n        raise InvalidIdToken(msg)\n    elif client.id_token_signed_response_alg is not None and id_token.alg != client.id_token_signed_response_alg:\n        raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg)\n\n    id_token_alg = id_token.alg or client.id_token_signed_response_alg\n\n    if azr.issuer and id_token.issuer != azr.issuer:\n        raise MismatchingIssuer(id_token.issuer, azr.issuer, self)\n\n    if id_token.audiences and client.client_id not in id_token.audiences:\n        raise MismatchingAudience(id_token.audiences, client.client_id, self)\n\n    if id_token.get_claim(\"azp\") is not None and id_token.azp != client.client_id:\n        raise MismatchingAzp(id_token.azp, client.client_id, self)\n\n    if id_token.is_expired():\n        raise ExpiredIdToken(id_token)\n\n    if azr.nonce and id_token.nonce != azr.nonce:\n        raise MismatchingNonce()\n\n    if azr.acr_values and id_token.acr not in azr.acr_values:\n        raise MismatchingAcr(id_token.acr, azr.acr_values)\n\n    hash_function: Callable[[str], str]  # method used to calculate at_hash, s_hash, etc.\n\n    if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n        if not client.client_secret:\n            msg = \"ID Token is symmetrically signed but this client does not have a Client Secret.\"\n            raise InvalidIdToken(msg)\n        id_token.verify_signature(jwskate.SymmetricJwk.from_bytes(client.client_secret), alg=id_token_alg)\n    elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n        if not client.authorization_server_jwks:\n            msg = \"ID Token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n            raise InvalidIdToken(msg)\n\n        if id_token.get_header(\"kid\") is None:\n            msg = (\n                \"ID Token does not contain a Key ID (kid) to specify the asymmetric key \"\n                \"to use for signature verification.\"\n            )\n            raise InvalidIdToken(msg)\n        try:\n            verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n        except KeyError:\n            msg = (\n                f\"ID Token is asymmetrically signed but its Key ID '{id_token.kid}' \"\n                \"is not part of the Authorization Server JWKS.\"\n            )\n            raise InvalidIdToken(msg) from None\n\n        if id_token_alg not in verification_jwk.supported_signing_algorithms():\n            msg = \"ID Token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n            raise InvalidIdToken(msg)\n\n        id_token.verify_signature(verification_jwk, alg=id_token_alg)\n\n        hash_function = IdToken.hash_method(verification_jwk, id_token_alg)\n\n    at_hash = id_token.get_claim(\"at_hash\")\n    if at_hash is not None:\n        expected_at_hash = hash_function(self.access_token)\n        if expected_at_hash != at_hash:\n            msg = f\"Mismatching 'at_hash' value: expected '{expected_at_hash}', got '{at_hash}'\"\n            raise InvalidIdToken(msg)\n\n    c_hash = id_token.get_claim(\"c_hash\")\n    if c_hash is not None:\n        expected_c_hash = hash_function(azr.code)\n        if expected_c_hash != c_hash:\n            msg = f\"Mismatching 'c_hash' value: expected '{expected_c_hash}', got '{c_hash}'\"\n            raise InvalidIdToken(msg)\n\n    s_hash = id_token.get_claim(\"s_hash\")\n    if s_hash is not None:\n        if azr.state is None:\n            msg = \"ID Token has a 's_hash' claim but no state was included in the request.\"\n            raise InvalidIdToken(msg)\n        expected_s_hash = hash_function(azr.state)\n        if expected_s_hash != s_hash:\n            msg = f\"Mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}'\"\n            raise InvalidIdToken(msg)\n\n    if azr.max_age is not None:\n        try:\n            auth_time = id_token.auth_time\n        except AttributeError:\n            msg = (\n                \"A `max_age` parameter was included in the authorization request, \"\n                \"but the ID Token does not contain an `auth_time` claim.\"\n            )\n            raise InvalidIdToken(msg) from None\n        auth_age = datetime.now(tz=timezone.utc) - auth_time\n        if auth_age.seconds &gt; azr.max_age + 60:\n            msg = (\n                \"User authentication happened too long ago. The `auth_time` parameter from\"\n                \" the ID Token indicate that the last Authentication Time was at\"\n                f\" {auth_time} ({auth_age.seconds} sec ago), but the authorization request\"\n                f\" `max_age` parameter specified that it must be maximum {azr.max_age} sec\"\n                \" ago.\"\n            )\n            raise InvalidIdToken(msg)\n\n    return self.__class__(\n        access_token=self.access_token,\n        expires_at=self.expires_at,\n        scope=self.scope,\n        refresh_token=self.refresh_token,\n        token_type=self.token_type,\n        id_token=id_token,\n        **self.kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict of parameters.</p> <p>That is suitable for serialization or to init another BearerToken.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict of parameters.\n\n    That is suitable for serialization or to init another BearerToken.\n\n    \"\"\"\n    d = asdict(self)\n    d.pop(\"expires_at\")\n    d[\"expires_in\"] = self.expires_in\n    d.update(**d.pop(\"kwargs\", {}))\n    return {key: val for key, val in d.items() if val is not None}\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Callable[[BearerToken], str] | None</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Callable[[str], BearerToken] | None</code> <p>a function to deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n    \"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize\n    BearerTokens. Default implementations are provided with use gzip and base64url on the serialized\n    JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function to deserialize a serialized token representation.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Callable[[BearerToken], str] | None = None,\n        loader: Callable[[str], BearerToken] | None = None,\n    ):\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n        \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n\n        \"\"\"\n        return BinaPy.serialize_to(\"json\", token.as_dict()).to(\"deflate\").to(\"b64u\").ascii()\n\n    def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n        \"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n            token_class: class to use to deserialize the Token\n\n        Returns:\n            a BearerToken\n\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n        \"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n        \"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n    \"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n\n    \"\"\"\n    return BinaPy.serialize_to(\"json\", token.as_dict()).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <code>token_class</code> <code>type[BearerToken]</code> <p>class to use to deserialize the Token</p> <code>BearerToken</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(self, serialized: str, token_class: type[BearerToken] = BearerToken) -&gt; BearerToken:\n    \"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n        token_class: class to use to deserialize the Token\n\n    Returns:\n        a BearerToken\n\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at, tz=timezone.utc)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n    \"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n    \"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.DPoPToken","title":"<code>DPoPToken</code>","text":"<p>             Bases: <code>AccessToken</code></p> <p>Represents a DPoP Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class DPoPToken(AccessToken):\n    \"\"\"Represents a DPoP Token.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific","title":"<code>vendor_specific</code>","text":"<p>Vendor-specific utilities.</p> <p>This module contains vendor-specific subclasses of [requests_oauth2client] classes, that make it easier to work with specific OAuth 2.x providers and/or fix compatibility issues.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0","title":"<code>Auth0</code>","text":"<p>Auth0-related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0:\n    \"\"\"Auth0-related utilities.\"\"\"\n\n    @classmethod\n    def tenant(cls, tenant: str) -&gt; str:\n        \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n        if not tenant:\n            msg = \"You must specify a tenant name.\"\n            raise ValueError(msg)\n        if (\n            \".\" not in tenant\n            or tenant.endswith(\".eu\")\n            or tenant.endswith(\".us\")\n            or tenant.endswith(\".au\")\n            or tenant.endswith(\".jp\")\n        ):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant:\n            if tenant.startswith(\"https://\"):\n                return tenant[8:]\n            msg = (\n                \"Invalid tenant name. \"\n                \"It must be a tenant name like 'mytenant.myregion' \"\n                \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n                \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n            )\n            raise ValueError(msg)\n        return tenant\n\n    @classmethod\n    def client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n        tenant = cls.tenant(tenant)\n        issuer = f\"https://{tenant}\"\n        token_endpoint = f\"{issuer}/oauth/token\"\n        authorization_endpoint = f\"{issuer}/authorize\"\n        revocation_endpoint = f\"{issuer}/oauth/revoke\"\n        userinfo_endpoint = f\"{issuer}/userinfo\"\n        jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n        return OAuth2Client(\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            issuer=issuer,\n            jwks_uri=jwks_uri,\n            **kwargs,\n        )\n\n    @classmethod\n    def management_api_client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; ApiClient:\n        \"\"\"Initialize a client for the Auth0 Management API.\n\n        See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n        target tenant name and the credentials for a client that is allowed access to the Management\n        API.\n\n        Args:\n            tenant: the tenant name.\n                Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n            auth: client credentials.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_id: the Client ID.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_secret: the Client Secret.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            private_jwk: the private key to use for client authentication.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            session: requests session.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            **kwargs: additional kwargs to pass to the ApiClient base class\n\n        Usage:\n            ```python\n            from requests_oauth2client.vendor_specific import Auth0\n\n            a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n            users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n            ```\n\n        \"\"\"\n        tenant = cls.tenant(tenant)\n        client = cls.client(\n            tenant,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n        audience = f\"https://{tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        return ApiClient(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.tenant","title":"<code>tenant(tenant)</code>  <code>classmethod</code>","text":"<p>Given a short tenant name, returns the full tenant FQDN.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef tenant(cls, tenant: str) -&gt; str:\n    \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n    if not tenant:\n        msg = \"You must specify a tenant name.\"\n        raise ValueError(msg)\n    if (\n        \".\" not in tenant\n        or tenant.endswith(\".eu\")\n        or tenant.endswith(\".us\")\n        or tenant.endswith(\".au\")\n        or tenant.endswith(\".jp\")\n    ):\n        tenant = f\"{tenant}.auth0.com\"\n    if \"://\" in tenant:\n        if tenant.startswith(\"https://\"):\n            return tenant[8:]\n        msg = (\n            \"Invalid tenant name. \"\n            \"It must be a tenant name like 'mytenant.myregion' \"\n            \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n            \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n        )\n        raise ValueError(msg)\n    return tenant\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.client","title":"<code>client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client for an Auth0 tenant.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n    tenant = cls.tenant(tenant)\n    issuer = f\"https://{tenant}\"\n    token_endpoint = f\"{issuer}/oauth/token\"\n    authorization_endpoint = f\"{issuer}/authorize\"\n    revocation_endpoint = f\"{issuer}/oauth/revoke\"\n    userinfo_endpoint = f\"{issuer}/userinfo\"\n    jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n    return OAuth2Client(\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        issuer=issuer,\n        jwks_uri=jwks_uri,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Auth0.management_api_client","title":"<code>management_api_client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a client for the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0.client</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>the Client ID. Same definition as for OAuth2Client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret. Same definition as for OAuth2Client</p> <code>None</code> <code>private_jwk</code> <code>Any | None</code> <p>the private key to use for client authentication. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Usage <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef management_api_client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; ApiClient:\n    \"\"\"Initialize a client for the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n    target tenant name and the credentials for a client that is allowed access to the Management\n    API.\n\n    Args:\n        tenant: the tenant name.\n            Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n        auth: client credentials.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_id: the Client ID.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_secret: the Client Secret.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        private_jwk: the private key to use for client authentication.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Usage:\n        ```python\n        from requests_oauth2client.vendor_specific import Auth0\n\n        a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n\n    \"\"\"\n    tenant = cls.tenant(tenant)\n    client = cls.client(\n        tenant,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n    audience = f\"https://{tenant}/api/v2/\"\n    api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n    return ApiClient(\n        base_url=audience,\n        auth=api_auth,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Ping","title":"<code>Ping</code>","text":"<p>Ping Identity related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class Ping:\n    \"\"\"Ping Identity related utilities.\"\"\"\n\n    @classmethod\n    def client(\n        cls,\n        issuer: str,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any = None,\n        session: requests.Session | None = None,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client for PingFederate.\n\n        This will configure all endpoints with PingID specific urls, without using the metadata.\n        Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n        over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n        \"\"\"\n        if not issuer.startswith(\"https://\"):\n            if \"://\" in issuer:\n                msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n                raise ValueError(msg)\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n            raise ValueError(msg)\n\n        return OAuth2Client(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.Ping.client","title":"<code>client(issuer, auth=None, client_id=None, client_secret=None, private_jwk=None, session=None)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client for PingFederate.</p> <p>This will configure all endpoints with PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code>.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    issuer: str,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any = None,\n    session: requests.Session | None = None,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an OAuth2Client for PingFederate.\n\n    This will configure all endpoints with PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n    over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n    \"\"\"\n    if not issuer.startswith(\"https://\"):\n        if \"://\" in issuer:\n            msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n            raise ValueError(msg)\n        issuer = f\"https://{issuer}\"\n    if \".\" not in issuer:\n        msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n        raise ValueError(msg)\n\n    return OAuth2Client(\n        authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n        token_endpoint=f\"{issuer}/as/token.oauth2\",\n        revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n        userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n        introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n        jwks_uri=f\"{issuer}/pf/JWKS\",\n        registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n        ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n        ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n        ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n        ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n        device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0","title":"<code>auth0</code>","text":"<p>Implements subclasses for Auth0.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0","title":"<code>Auth0</code>","text":"<p>Auth0-related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0:\n    \"\"\"Auth0-related utilities.\"\"\"\n\n    @classmethod\n    def tenant(cls, tenant: str) -&gt; str:\n        \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n        if not tenant:\n            msg = \"You must specify a tenant name.\"\n            raise ValueError(msg)\n        if (\n            \".\" not in tenant\n            or tenant.endswith(\".eu\")\n            or tenant.endswith(\".us\")\n            or tenant.endswith(\".au\")\n            or tenant.endswith(\".jp\")\n        ):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant:\n            if tenant.startswith(\"https://\"):\n                return tenant[8:]\n            msg = (\n                \"Invalid tenant name. \"\n                \"It must be a tenant name like 'mytenant.myregion' \"\n                \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n                \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n            )\n            raise ValueError(msg)\n        return tenant\n\n    @classmethod\n    def client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n        tenant = cls.tenant(tenant)\n        issuer = f\"https://{tenant}\"\n        token_endpoint = f\"{issuer}/oauth/token\"\n        authorization_endpoint = f\"{issuer}/authorize\"\n        revocation_endpoint = f\"{issuer}/oauth/revoke\"\n        userinfo_endpoint = f\"{issuer}/userinfo\"\n        jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n        return OAuth2Client(\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            issuer=issuer,\n            jwks_uri=jwks_uri,\n            **kwargs,\n        )\n\n    @classmethod\n    def management_api_client(\n        cls,\n        tenant: str,\n        auth: (\n            requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n        ) = None,\n        *,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any | None = None,\n        session: requests.Session | None = None,\n        **kwargs: Any,\n    ) -&gt; ApiClient:\n        \"\"\"Initialize a client for the Auth0 Management API.\n\n        See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n        target tenant name and the credentials for a client that is allowed access to the Management\n        API.\n\n        Args:\n            tenant: the tenant name.\n                Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n            auth: client credentials.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_id: the Client ID.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            client_secret: the Client Secret.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            private_jwk: the private key to use for client authentication.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            session: requests session.\n                Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n            **kwargs: additional kwargs to pass to the ApiClient base class\n\n        Usage:\n            ```python\n            from requests_oauth2client.vendor_specific import Auth0\n\n            a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n            users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n            ```\n\n        \"\"\"\n        tenant = cls.tenant(tenant)\n        client = cls.client(\n            tenant,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n        audience = f\"https://{tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        return ApiClient(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.tenant","title":"<code>tenant(tenant)</code>  <code>classmethod</code>","text":"<p>Given a short tenant name, returns the full tenant FQDN.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef tenant(cls, tenant: str) -&gt; str:\n    \"\"\"Given a short tenant name, returns the full tenant FQDN.\"\"\"\n    if not tenant:\n        msg = \"You must specify a tenant name.\"\n        raise ValueError(msg)\n    if (\n        \".\" not in tenant\n        or tenant.endswith(\".eu\")\n        or tenant.endswith(\".us\")\n        or tenant.endswith(\".au\")\n        or tenant.endswith(\".jp\")\n    ):\n        tenant = f\"{tenant}.auth0.com\"\n    if \"://\" in tenant:\n        if tenant.startswith(\"https://\"):\n            return tenant[8:]\n        msg = (\n            \"Invalid tenant name. \"\n            \"It must be a tenant name like 'mytenant.myregion' \"\n            \"or a full FQDN like 'mytenant.myregion.auth0.com'.\"\n            \"or an issuer like 'https://mytenant.myregion.auth0.com'\"\n        )\n        raise ValueError(msg)\n    return tenant\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.client","title":"<code>client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client for an Auth0 tenant.</p> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n    \"\"\"Initialise an OAuth2Client for an Auth0 tenant.\"\"\"\n    tenant = cls.tenant(tenant)\n    issuer = f\"https://{tenant}\"\n    token_endpoint = f\"{issuer}/oauth/token\"\n    authorization_endpoint = f\"{issuer}/authorize\"\n    revocation_endpoint = f\"{issuer}/oauth/revoke\"\n    userinfo_endpoint = f\"{issuer}/userinfo\"\n    jwks_uri = f\"{issuer}/.well-known/jwks.json\"\n\n    return OAuth2Client(\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        issuer=issuer,\n        jwks_uri=jwks_uri,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0.management_api_client","title":"<code>management_api_client(tenant, auth=None, *, client_id=None, client_secret=None, private_jwk=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a client for the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0.client</p> required <code>auth</code> <code>AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>the Client ID. Same definition as for OAuth2Client</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>the Client Secret. Same definition as for OAuth2Client</p> <code>None</code> <code>private_jwk</code> <code>Any | None</code> <p>the private key to use for client authentication. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Session | None</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Usage <pre><code>from requests_oauth2client.vendor_specific import Auth0\n\na0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>@classmethod\ndef management_api_client(\n    cls,\n    tenant: str,\n    auth: (\n        requests.auth.AuthBase | tuple[str, str] | tuple[str, Jwk] | tuple[str, dict[str, Any]] | str | None\n    ) = None,\n    *,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any | None = None,\n    session: requests.Session | None = None,\n    **kwargs: Any,\n) -&gt; ApiClient:\n    \"\"\"Initialize a client for the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2). You must provide the\n    target tenant name and the credentials for a client that is allowed access to the Management\n    API.\n\n    Args:\n        tenant: the tenant name.\n            Same definition as for [Auth0.client][requests_oauth2client.vendor_specific.auth0.Auth0.client]\n        auth: client credentials.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_id: the Client ID.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        client_secret: the Client Secret.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        private_jwk: the private key to use for client authentication.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session.\n            Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Usage:\n        ```python\n        from requests_oauth2client.vendor_specific import Auth0\n\n        a0mgmt = Auth0.management_api_client(\"mytenant.eu\", client_id=client_id, client_secret=client_secret)\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n\n    \"\"\"\n    tenant = cls.tenant(tenant)\n    client = cls.client(\n        tenant,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n    audience = f\"https://{tenant}/api/v2/\"\n    api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n    return ApiClient(\n        base_url=audience,\n        auth=api_auth,\n        session=session,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.ping","title":"<code>ping</code>","text":"<p>PingID specific client.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.Ping","title":"<code>Ping</code>","text":"<p>Ping Identity related utilities.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class Ping:\n    \"\"\"Ping Identity related utilities.\"\"\"\n\n    @classmethod\n    def client(\n        cls,\n        issuer: str,\n        auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n        client_id: str | None = None,\n        client_secret: str | None = None,\n        private_jwk: Any = None,\n        session: requests.Session | None = None,\n    ) -&gt; OAuth2Client:\n        \"\"\"Initialize an OAuth2Client for PingFederate.\n\n        This will configure all endpoints with PingID specific urls, without using the metadata.\n        Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n        over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n        \"\"\"\n        if not issuer.startswith(\"https://\"):\n            if \"://\" in issuer:\n                msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n                raise ValueError(msg)\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n            raise ValueError(msg)\n\n        return OAuth2Client(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_jwk=private_jwk,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.Ping.client","title":"<code>client(issuer, auth=None, client_id=None, client_secret=None, private_jwk=None, session=None)</code>  <code>classmethod</code>","text":"<p>Initialize an OAuth2Client for PingFederate.</p> <p>This will configure all endpoints with PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code>.</p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>@classmethod\ndef client(\n    cls,\n    issuer: str,\n    auth: requests.auth.AuthBase | tuple[str, str] | str | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    private_jwk: Any = None,\n    session: requests.Session | None = None,\n) -&gt; OAuth2Client:\n    \"\"\"Initialize an OAuth2Client for PingFederate.\n\n    This will configure all endpoints with PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage\n    over using `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`.\n\n    \"\"\"\n    if not issuer.startswith(\"https://\"):\n        if \"://\" in issuer:\n            msg = \"Invalid issuer. It must be an https:// url or a domain name without a scheme.\"\n            raise ValueError(msg)\n        issuer = f\"https://{issuer}\"\n    if \".\" not in issuer:\n        msg = \"Invalid issuer. It must contain at least a dot in the domain name.\"\n        raise ValueError(msg)\n\n    return OAuth2Client(\n        authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n        token_endpoint=f\"{issuer}/as/token.oauth2\",\n        revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n        userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n        introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n        jwks_uri=f\"{issuer}/pf/JWKS\",\n        registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n        ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n        ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n        ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n        ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n        device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_jwk=private_jwk,\n        session=session,\n    )\n</code></pre>"},{"location":"authors/","title":"Authors","text":""},{"location":"authors/#credits","title":"Credits","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>Guillaume Pujol guill.p.linux@gmail.com</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>None yet. Why not be the first?</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Detailed steps to reproduce the bug.</li> <li>Full error message whenever there is one</li> <li>Your Python version, operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>requests_oauth2client</code> could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>requests_oauth2client</code> for local development.</p> <ol> <li>Fork the <code>requests_oauth2client</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>$ git clone git@github.com:your_name_here/requests_oauth2client.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>$ tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check    https://github.com/guillp/requests_oauth2client/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ pytest tests.test_client_credentials\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Travis will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"History","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#12","title":"1.2","text":"<ul> <li><code>OAuth2AuthorizationCodeAuth</code> now accepts an AuthorizationResponse</li> <li><code>AuthorizationRequest</code> now handles <code>nonce</code> and <code>acr_values</code></li> <li><code>OAuth2Client</code> accepts <code>authorization_endpoint</code> and <code>redirect_uri</code> at init time, and has a <code>authorization_request()</code> method to generate AuthorizationRequests</li> <li><code>BearerToken</code> has a <code>validate_id_token()</code> method to handle ID Token validation has specified in OIDC</li> <li>Added <code>PingClient</code> for PingFederate by PingID</li> </ul>"},{"location":"history/#11","title":"1.1","text":"<ul> <li>ApiClient now has <code>allow_redirects=False</code> by default</li> <li>OAuth2Client now has <code>extra_metadata</code></li> <li>bugfixes, optimizations, introduce methods for easier subclassing</li> </ul>"},{"location":"history/#100","title":"1.0.0","text":"<ul> <li>First properly documented version.</li> <li>Migrated from pipenv to poetry</li> <li>Added pre-commit checks</li> <li><code>requests</code> is now automatically imported with <code>from requests_oauth2client import *</code></li> <li>ApiClient is now a wrapper around <code>requests.Session</code> instead of a subclass</li> <li><code>ApiClient.__init__()</code> now accepts extra kwargs which will be used to configure the <code>Session</code>.</li> <li>Add <code>__getitem__</code> and <code>__getattr_</code> to ApiClient</li> <li><code>AuthorizationRequest.validate_callback()</code> now returns an <code>AuthorizationResponse</code> which contains all returned   response attributes instead of just a code. To access the authorization code, get the <code>code</code> attribute from that response.</li> <li><code>OAuth2Client.authorization_code()</code> now accepts an <code>AuthorizationResponse</code> as parameter, and will   use it to include all necessary parameters for the Authorization Code Grant.</li> <li>removed <code>OAuth2Client.authorization_code_pkce()</code></li> <li>Renamed <code>ClientSecretJWT</code> and <code>PrivateKeyJWT</code> to <code>ClientSecretJwt</code> and <code>PrivateKeyJwt</code>, for consistency with <code>jwskate</code>.</li> <li>Methods from <code>requests_oauth2client.utils</code> are no longer exposed in top-level module.</li> <li>Renamed base class <code>ClientAuthenticationMethod</code> to <code>BaseClientAuthenticationMethod</code>.</li> <li>Introduced a default timeout in <code>ApiClient</code></li> <li>Splitted <code>jwskate</code> into its own independant module</li> <li>Use <code>BinaPy</code> for binary data manipulation</li> <li>Add support for Pushed Authorization Requests</li> </ul>"},{"location":"history/#-018","title":"\\&lt;= 0.18","text":"<ul> <li>Draft versions</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install requests_oauth2client, run this command in your terminal:</p> <pre><code>$ pip install requests_oauth2client\n</code></pre> <p>This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for requests_oauth2client can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/requests_oauth2client\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use requests_oauth2client in a project</p> <pre><code>from requests_oauth2client import *\n</code></pre>"}]}