{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>requests_oauth2client</code> is an OAuth 2.x client for Python, able to obtain, refresh and revoke tokens from any OAuth2.x/OIDC compliant Authorization Server. It sits upon and extends the famous requests HTTP client module.</p> <p>It can act as an OAuth 2.0 / 2.1 client, to automatically get and renew Access Tokens, based on the Client Credentials, Authorization Code, Refresh token, Token Exchange, JWT Bearer, Device Authorization, Resource Owner Password or CIBA grants. Additional grant types are easy to add if needed.</p> <p>It also supports OpenID Connect 1.0, PKCE, Client Assertions, Token Revocation, and Introspection, Resource Indicators, JWT-secured Authorization Requests, Pushed Authorization Requests, Authorization Server Issuer Identification, as well as using custom params to any endpoint, and other important features that are often overlooked in other client libraries.</p> <p>And it also includes a wrapper around requests.Session that makes it super easy to use REST-style APIs, with or without OAuth 2.x.</p> <p>Please note that despite the name, this library has no relationship with Google oauth2client library.</p> <p> </p>"},{"location":"#documentation","title":"Documentation","text":"<p>Full module documentation is available at https://guillp.github.io/requests_oauth2client/</p>"},{"location":"#installation","title":"Installation","text":"<p><code>requests_oauth2client</code> is available from PyPi, so installing it is as easy as:</p> <pre><code>pip install requests_oauth2client\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Everything from <code>requests_oauth2client</code> is available from the root module, so you can import it like this:</p> <pre><code>from requests_oauth2client import *\n</code></pre> <p>Or you can import individual objects from this package as usual. Note that importing <code>*</code> automatically imports <code>requests</code>, so no need to import it yourself.</p>"},{"location":"#calling-apis-with-access-tokens","title":"Calling APIs with Access Tokens","text":"<p>If you already managed to obtain an access token for the API you want to call, you can simply use the BearerAuth Auth Handler for requests:</p> <pre><code>import requests\nfrom requests_oauth2client import BearerAuth\n\ntoken = \"an_access_token\"\nresp = requests.get(\"https://my.protected.api/endpoint\", auth=BearerAuth(token))\n</code></pre> <p>This authentication handler will add a properly formatted <code>Authorization: Bearer &lt;access_token&gt;</code> header in the request, with your access token according to RFC6750.</p>"},{"location":"#using-an-oauth2client","title":"Using an OAuth2Client","text":"<p>OAuth2Client offers several methods that implement the communication to the various endpoints that are standardised by OAuth 2.0 and its extensions. Those endpoints include the Token Endpoint, the Revocation, Introspection, UserInfo, BackChannel Authentication and Device Authorization Endpoints.</p> <p>You have to provide the URLs for those endpoints if you intend to use them. Otherwise, only the Token Endpoint is mandatory to initialize an <code>OAuth2Client</code>.</p> <p>To initialize an OAuth2Client, you only need a Token Endpoint URI from your AS, and the credentials for your application, which are often a <code>client_id</code> and a <code>client_secret</code>, usually also provided by the AS:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre> <p>The Token Endpoint is the only endpoint that is mandatory to obtain tokens. Credentials are used to authenticate the client everytime it sends a request to its Authorization Server. Usually, those are a static Client ID and Secret, which are the direct equivalent of a username and a password, but meant for an application instead of for a human user. The default authentication method used by <code>OAuth2Client</code> is Client Secret Post, but other standardised methods such as Client Secret Basic, Client Secret JWT or Private Key JWT are supported as well. See more about client authentication methods below.</p>"},{"location":"#obtaining-tokens","title":"Obtaining tokens","text":"<p>OAuth2Client has dedicated methods to send requests to the Token Endpoint using the different standardised (and/or custom) grants. Since the Token Endpoint URL and Client Authentication Method to use are already declared for the client at init time, the only required parameters for those methods are those that will be sent in the request to the Token Endpoint.</p> <p>Those methods directly return a BearerToken if the request is successful, or raise an exception if it fails. BearerToken contains all the data as returned by the Token Endpoint, including the Access Token. It will:</p> <ul> <li>keep track of the Access Token expiration date (based on the <code>expires_in</code> hint as returned by the AS). This date is   accessible with the <code>expires_at</code> attribute.</li> <li>contain the Refresh Token, if returned by the AS, accessible with the <code>refresh_token</code> attribute.</li> <li>contain the ID Token, if returned by the AS, accessible with the <code>\u00ecd_token</code> attribute (when using the Authorization   Code flow).</li> <li>keep track of other associated metadata as well, also accessible as attributes with the same name:   <code>token.custom_attr</code>, or with subscription syntax <code>token[\"my.custom.attr\"]</code>.</li> </ul> <p>You can create such a BearerToken yourself if you need:</p> <pre><code>from requests_oauth2client import BearerToken\n\nbearer_token = BearerToken(access_token=\"an_access_token\", expires_in=60)\nprint(bearer_token)\n# {'access_token': 'an_access_token',\n#  'expires_in': 55,\n#  'token_type': 'Bearer'}\nprint(bearer_token.expires_at)\n# datetime.datetime(2021, 8, 20, 9, 56, 59, 498793)\nassert not bearer_token.is_expired()\n\nprint(bearer_token.expires_in)\n# 40\n</code></pre> <p>Note that the <code>expires_in</code> indicator here is not static. It keeps track of the token lifetime, in seconds, and is calculated as the time flies. The actual static expiration date is accessible with the <code>expires_at</code> property. You can check if a token is expired with bearer_token.is_expired().</p> <p>You can use a BearerToken instance anywhere you can use an access_token as string.</p>"},{"location":"#using-oauth2client-as-a-requests-auth-handler","title":"Using OAuth2Client as a requests Auth Handler","text":"<p>While using OAuth2Client directly is great for testing or debugging OAuth2.x flows, it is not a viable option for actual applications where tokens must be obtained, used during their lifetime then obtained again or refreshed once they are expired. <code>requests_oauth2client</code> contains several requests compatible Auth Handlers (as subclasses of requests.auth.AuthBase), that will take care of obtaining tokens when required, then will cache those tokens until they are expired, and will obtain new ones (or refresh them, when possible), once the initial token is expired. Those are best used with a requests.Session, or an ApiClient, which is a wrapper around <code>Session</code> with a few enhancements as described below.</p>"},{"location":"#client-credentials-grant","title":"Client Credentials grant","text":"<p>To send a request using the Client Credentials grant, use the aptly named .client_credentials() method, with the parameters to send in the token request as keyword parameters:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\ntoken = oauth2client.client_credentials(scope=\"myscope\")\n# or, if your AS uses resource indicator:\ntoken = oauth2client.client_credentials(scope=\"myscope\", resource=\"https://myapi.local\")\n# or, if your AS uses 'audience' as parameter to identify the requested API (Auth0 style):\ntoken = oauth2client.client_credentials(audience=\"https://myapi.local\")\n# or, if your AS uses custom parameters:\ntoken = oauth2client.client_credentials(scope=\"myscope\", custom_param=\"custom_value\")\n</code></pre> <p>Parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> or any other parameter that may be required by the AS can be passed as keyword parameters. Those will be included in the token request that is sent to the AS. <code>scope</code> is not mandatory at client level (but it might be required by your AS to serve your request).</p>"},{"location":"#as-auth-handler","title":"As Auth Handler","text":"<p>You can use the OAuth2ClientCredentialsAuth auth handler. It takes an OAuth2Client as parameter, and the additional kwargs to pass to the token endpoint:</p> <pre><code>import requests\nfrom requests_oauth2client import OAuth2Client, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nauth = OAuth2ClientCredentialsAuth(\n    oauth2client, scope=\"myscope\", resource=\"https://myapi.local\"\n)\n\n# use it like this:\nrequests.get(\"https://myapi.local/resource\", auth=auth)\n\n# or like this:\nsession = requests.Session()\nsession.auth = auth\n\nresp = session.get(\"https://myapi.local/resource\")\n</code></pre> <p>Once again, extra parameters such as <code>scope</code>, <code>resource</code> or <code>audience</code> are allowed if required.</p> <p>When you send your first request, OAuth2ClientCredentialsAuth will automatically retrieve an access token from the AS using the Client Credentials grant, then will include it in the request. Next requests will use the same token, as long as it is valid. A new token will be automatically retrieved once the previous one is expired.</p>"},{"location":"#authorization-code-grant","title":"Authorization Code Grant","text":"<p>Obtaining tokens with the Authorization code grant is made in 3 steps:</p> <ol> <li> <p>your application must open a specific url called the Authentication Request in a browser.</p> </li> <li> <p>your application must obtain and validate the Authorization Response, which is a redirection back to your    application that contains an Authorization Code as parameter. This redirect back (often called \"callback\") is    initiated by the Authorization Server after any necessary interaction with the user is complete (Registration, Login,    Profile completion, Multi-Factor Authentication, Authorization, Consent, etc.)</p> </li> <li> <p>your application must then exchange this Authorization Code for an Access Token, with a request to the Token    Endpoint.</p> </li> </ol> <p><code>requests_oauth2client</code>, and more specifically OAuth2Client will help you with all those steps, as described below.</p>"},{"location":"#generating-authorization-requests","title":"Generating Authorization Requests","text":"<p>To be able to use the Authorization Code grant, you need two urls:</p> <ul> <li>the URL for Authorization Endpoint, which is the url where you must send your Authorization Requests</li> <li>the Redirect URI, which is the url pointing to your application, where the Authorization Server will reply with   Authorization Response</li> </ul> <p>You can declare those urls when initializing your OAuth2Client instance. Then you can generate valid Authorization Requests by calling the method <code>.authorization_request()</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    redirect_uri=\"https://url.to.my.application/redirect_uri\",\n    client_id=\"client_id\",\n    client_secret=\"client_secret\",\n)\n\naz_request = client.authorization_request(scope=\"openid email profile\")\n\nprint(az_request)\n# this will look like this, with line feeds for display purposes only:\n# https://url.to.the/authorization_endpoint\n# ?client_id=client_id\n# &amp;redirect_uri=https%3A%2F%2Furl.to.my.application%2Fredirect_uri\n# &amp;response_type=code\n# &amp;scope=openid+email+profile\n# &amp;state=FBx9mWeLwoKGgG76vhi6v61-4mgxmgZhtWIa7aTffdY\n# &amp;nonce=iHZJokhkGOAojff1tdknRyz9mPZyy5vq9JDlVaUHyqk\n# &amp;code_challenge=TG7qgdyKnwUPuoQ6NNJRlLMoHbeVmJlB8g0VOcfQEkc\n# &amp;code_challenge_method=S256\n\n# you can send the user to that url with:\nimport webbrowser\n\nwebbrowser.open(az_request.uri)\n</code></pre> <p>Note that the <code>state</code>, <code>nonce</code> and <code>code_challenge</code> parameters are generated with secure random values by default. Should you wish to use your own values, you can pass them as parameters to <code>OAuth2Client.authorization_request()</code>. For PKCE, you need to pass your generated <code>code_verifier</code>, and the <code>code_challenge</code> will automatically be derived from it. If you don't want to use PKCE, you can pass <code>code_challenge_method=None</code> when initializing your <code>OAuth2Client</code>.</p>"},{"location":"#validating-the-authorization-response","title":"Validating the Authorization Response","text":"<p>Once you have redirected the user browser to the Authorization Request URI, and after the user is successfully authenticated and authorized, plus any other extra interactive step is complete, the AS will respond with a redirection to your redirect_uri. That is the Authorization Response. It contains several parameters that must be retrieved by your client. The Authorization Code is one of those parameters, but you must also validate that the state matches your request. You can do this with:</p> <pre><code># using the `az_request` as defined above\n\nresponse_uri = input(\n    \"Please enter the full url and/or params obtained on the redirect_uri: \"\n)\naz_response = az_request.validate_callback(response_uri)\n</code></pre> <p>This auth_response is an <code>AuthorizationResponse</code> instance and contains everything that is needed for your application to complete the authentication and get its tokens from the AS.</p>"},{"location":"#exchanging-code-for-tokens","title":"Exchanging code for tokens","text":"<p>Once you have obtained the AS response, containing an authorization code, your application must exchange it for actual Token(s).</p> <p>To exchange a code for Access and/or ID tokens, use the OAuth2Client.authorization_code() method. If you have obtained an AuthorizationResponse as described above, you can simply do:</p> <pre><code>token = oauth2client.authorization_code(az_response)\n</code></pre> <p>This will automatically include the <code>code</code>, <code>redirect_uri</code> and <code>code_verifier</code> parameters in the Token Request, as expected by the AS. You may include extra parameters if required, or you may pass your own parameters, without using an <code>AuthorizationResponse</code> instance, like this:</p> <pre><code>token = oauth2client.authorization_code(\n    code=code,\n    code_verifier=code_verifier,\n    redirect_uri=redirect_uri,\n    custom_param=custom_value,\n)\n</code></pre>"},{"location":"#as-auth-handler_1","title":"As Auth Handler","text":"<p>The OAuth2AuthorizationCodeAuth handler takes an OAuth2Client and an authorization code as parameter, plus whatever additional keyword parameters are required by your Authorization Server:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2AuthorizationCodeAuth\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    authorization_endpoint=\"https://url.to.the/authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2AuthorizationCodeAuth(\n        oauth2client,\n        \"my_authorization_code\",\n    ),\n)\n\n# any request using api_client will trigger exchanging the code for an access_token, which is then cached, and refreshed later if needed\nresp = api_client.post(data={...})\n</code></pre> <p>OAuth2AuthorizationCodeAuth will take care of refreshing the token automatically once it is expired, using the refresh token, if available.</p>"},{"location":"#note-on-authorizationrequest","title":"Note on AuthorizationRequest","text":"<p>Authorization Requests generated by <code>OAuth2Client.authorization_request()</code> are instance of the class <code>AuthorizationRequest</code>. You can also use that class directly to generate your requests, but in that case you need to supply your Authorization Endpoint URI, your <code>client_id</code>, <code>redirect_uri</code>, etc. You can access every parameter from an <code>AuthorizationRequest</code> instance, as well as the generated <code>code_verifier</code>, as attributes of this instance. Once an Authorization Request URL is generated, it your application responsibility to redirect or otherwise send the user to that URL. You may use the <code>webbrowser</code> module from Python standard library to do so. Here is an example for generating Authorization Requests:</p> <pre><code>from requests_oauth2client import AuthorizationRequest\n\naz_request = AuthorizationRequest(\n    \"https://url.to.the/authorization_endpoint\",\n    client_id=\"my_client_id\",\n    redirect_uri=\"http://localhost/callback\",  # this redirect_uri is specific to your app\n    scope=\"openid email profile\",\n    # extra parameters such as `resource` can be included as well if required by your AS\n    resource=\"https://my.resource.local/api\",\n)\nprint(\n    az_request\n)  # this request will look like this, with line breaks for display purposes only\n# https://url.to.the/authorization_endpoint\n# ?client_id=my_client_id\n# &amp;redirect_uri=http%3A%2F%2Flocalhost%callback\n# &amp;response_type=code\n# &amp;state=kHWL4VwcbUbtPR4mtht6yMAGG_S-ZcBh5RxI_IGDmJc\n# &amp;nonce=mSGOS1M3LYU9ncTvvutoqUR4n1EtmaC_sQ3db4dyMAc\n# &amp;scope=openid+email+profile\n# &amp;code_challenge=W3n02f6xUKoDVbmhWEWz3h780b-Ci6ucnBS_d7nogmQ\n# &amp;code_challenge_method=S256\n# &amp;resource=https%3A%2F%2Fmy.resource.local%2Fapi\n\nprint(az_request.code_verifier)\n# 'gYK-ZnQfoat2bghwed7oEz--wvn4D70ksJ5GuWO9sXXygZ7PMnUlSpBmMCcNRHxdgTS9m_roYwGxF6HQxIqZVwXmxRJUziFHUFxDrNuUIjCJCx6gBhPlpFbUXulB1fo2'\n</code></pre>"},{"location":"#device-authorization-grant","title":"Device Authorization Grant","text":"<p>Helpers for the Device Authorization Grant are also included. To get device and user codes, read the response attributes (including Device Code, User Code, Verification URI, etc.), then pooling the Token Endpoint:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    DeviceAuthorizationPoolingJob,\n    BearerToken,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nda_resp = client.authorize_device()\n\n# `da_resp` contains the Device Code, User Code, Verification URI and other info returned by the AS:\nda_resp.device_code\nda_resp.user_code\nda_resp.verification_uri\nda_resp.verification_uri_complete\nda_resp.expires_at  # just like for BearerToken, expiration is tracked by requests_oauth2client\nda_resp.interval\n\n# Send/show the Verification Uri and User Code to the user. He must use a browser to visit that url, authenticate and\n# input the User Code.\n\n# You can then request the Token endpoint to check if the user successfully authorized your device like this:\npool_job = DeviceAuthorizationPoolingJob(client, da_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>DeviceAuthorizationPoolingJob will automatically obey the pooling period. Everytime you call <code>pool_job()</code>, it will wait the appropriate number of seconds as indicated by the AS, and will apply slow_down requests.</p>"},{"location":"#as-auth-handler_2","title":"As Auth Handler","text":"<p>Use OAuth2DeviceCodeAuth as auth handler to exchange a device code for an access token:</p> <pre><code>from requests_oauth2client import ApiClient, OAuth2DeviceCodeAuth, OAuth2Client\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    device_authorization_endpoint=\"https://url.to.the/device_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\ndevice_auth_resp = client.authorize_device()\n\n# expose user_code and verification_uri or verification_uri_complete to the user\ndevice_auth_resp.user_code\ndevice_auth_resp.verification_uri\ndevice_auth_resp.verification_uri_complete\n\n# then try to send your request with a OAuth2DeviceCodeAuth handler\n# this will pool the token endpoint until the user authorize the device\napi_client = ApiClient(\n    \"https://your.protected.api/endpoint\",\n    auth=OAuth2DeviceCodeAuth(client, device_auth_resp),\n)\n\nresp = api_client.post(\n    data={...}\n)  # first call will hang until the user authorizes your app and the token endpoint returns a token.\n</code></pre>"},{"location":"#client-initiated-backchannel-authentication-ciba","title":"Client-Initiated BackChannel Authentication (CIBA)","text":"<p>To initiate a BackChannel Authentication against the dedicated endpoint, read the response attributes, and pool the Token Endpoint until the end-user successfully authenticates:</p> <pre><code>from requests_oauth2client import (\n    OAuth2Client,\n    BearerToken,\n    BackChannelAuthenticationPoolingJob,\n)\n\nclient = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    backchannel_authentication_endpoint=\"https://url.to.the/backchannel_authorization_endpoint\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\nba_resp = client.backchannel_authentication_request(\n    scope=\"openid email profile\",\n    login_hint=\"user@example.net\",\n)\n\n# `ba_resp` will contain the response attributes as returned by the AS, including an `auth_req_id`:\nba_resp.auth_req_id\nba_resp.expires_in  # decreases as times fly\nba_resp.expires_at  # a datetime to keep track of the expiration date, based on the \"expires_in\" returned by the AS\nba_resp.interval  # the pooling interval indicated by the AS\nba_resp.custom  # if the AS respond with additional attributes, they are also accessible\n\npool_job = BackChannelAuthenticationPoolingJob(client, ba_resp)\n\nresp = None\nwhile resp is None:\n    resp = pool_job()\n\nassert isinstance(resp, BearerToken)\n</code></pre> <p>Hints by the AS to slow down pooling will automatically be obeyed.</p>"},{"location":"#token-exchange","title":"Token Exchange","text":"<p>To send a token exchange request, use the OAuth2Client.token_exchange() method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\ntoken = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"urn:ietf:params:oauth:token-type:access_token\",\n)\n</code></pre> <p>As with the other grant-type specific methods, you may specify additional keyword parameters, that will be passed to the token endpoint, including any standardised attribute like <code>actor_token</code> or <code>actor_token_type</code>, or any custom parameter. There are short names for token types, that will be automatically translated to standardised types:</p> <pre><code>token = client.token_exchange(\n    subject_token=\"your_token_value\",\n    subject_token_type=\"access_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=\"your_actor_token\",\n    actor_token_type=\"id_token\",  # will be automatically replaced by \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre> <p>Or to make it even easier, types can be guessed based on the supplied subject or actor token:</p> <pre><code>from requests_oauth2client import BearerToken, ClientSecretJwt, IdToken, OAuth2Client\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\ntoken = client.token_exchange(\n    subject_token=BearerToken(\n        \"your_token_value\"\n    ),  # subject_token_type will be \"urn:ietf:params:oauth:token-type:access_token\"\n    actor_token=IdToken(\n        \"your_actor_token\"\n    ),  # actor_token_type will be \"urn:ietf:params:oauth:token-type:id_token\"\n)\n</code></pre>"},{"location":"#supported-client-authentication-methods","title":"Supported Client Authentication Methods","text":"<p><code>requests_oauth2client</code> supports several client authentication methods, as defined in multiple OAuth2.x standards. You select the appropriate method to use when initializing your OAuth2Client, with the <code>auth</code> parameter. Once initialized, a client will automatically use the configured authentication method every time it sends a requested to an endpoint that requires client authentication. You don't have anything else to do afterwards.</p>"},{"location":"#client-secret-basic","title":"Client Secret Basic","text":"<p>With client_secret_basic, <code>client_id</code> and <code>client_secret</code> are included in clear-text in the <code>Authorization</code> header when sending requests to the Token Endpoint. To use it, just pass a <code>ClientSecretBasic(client_id, client_secret)</code> as <code>auth</code> parameter:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretBasic\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretBasic(\"client_id\", \"client_secret\"),\n)\n</code></pre>"},{"location":"#client-secret-post","title":"Client Secret Post","text":"<p>With client_secret_post, <code>client_id</code> and <code>client_secret</code> are included as part of the body form data. To use it, pass a <code>ClientSecretPost(client_id, client_secret)</code> as <code>auth</code> parameter. This is the default when you pass a tuple <code>(client_id, client_secret)</code> as <code>auth</code> when initializing an <code>OAuth2Client</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretPost\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretPost(\"client_id\", \"client_secret\"),\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", \"client_secret\")\n)\n# or\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    client_id=\"my_client_id\",\n    client_secret=\"my_client_secret\",\n)\n</code></pre>"},{"location":"#client-secret-jwt","title":"Client Secret JWT","text":"<p>With client_secret_jwt, the client generates an ephemeral JWT assertion including information about itself (client_id), the AS (url of the endpoint), and an expiration date a few seconds in the future. To use it, pass a <code>ClientSecretJwt(client_id, client_secret)</code> as <code>auth</code> parameter. Assertion generation is entirely automatic, you don't have anything to do:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This method is more secure than the 2 previous, because only ephemeral credentials are transmitted, which limits the possibility for interception and replay of the Client Secret. But that Client Secret still needs to be shared between the AS and Client owner(s).</p>"},{"location":"#private-key-jwt","title":"Private Key JWT","text":"<p>With private_key_jwt, client uses a JWT assertion that is just like the one for client_secret_jwt, but it is signed with an asymmetric key. To use it, you need a private signing key, in a <code>dict</code> that matches the JWK format, or as an instance of <code>jwskate.Jwk</code>. The matching public key must be registered for your client on AS side. Once you have that, using this auth method is simple with the <code>PrivateKeyJwt(client_id, private_jwk)</code> auth handler:</p> <pre><code>from requests_oauth2client import OAuth2Client, PrivateKeyJwt\n\nprivate_jwk = {\n    \"kid\": \"mykid\",\n    \"kty\": \"RSA\",\n    \"e\": \"AQAB\",\n    \"n\": \"...\",\n    \"d\": \"...\",\n    \"p\": \"...\",\n    \"q\": \"...\",\n    \"dp\": \"...\",\n    \"dq\": \"...\",\n    \"qi\": \"...\",\n}\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PrivateKeyJwt(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=(\"client_id\", private_jwk)\n)\n# or\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", client_id=\"client_id\", private_jwk=private_jwk\n)\n</code></pre> <p>This method can be considered more secure than those relying on a client secret, because only ephemeral credentials are sent over the wire, and it uses asymmetric cryptography: the signing key is generated by the client, and only the public key is known by the AS. Transmitting that public key between owner(s) of the client and of the AS is much easier than transmitting the Client Secret, which is a shared key that must be considered as confidential.</p>"},{"location":"#none","title":"None","text":"<p>The latest Client Authentication Method, none, is for Public Clients which do not authenticate to the Token Endpoint. Those clients only include their <code>client_id</code> in body form data, without any authentication credentials. Use <code>PublicApp(client_id)</code>:</p> <pre><code>from requests_oauth2client import OAuth2Client, PublicApp\n\nclient = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", auth=PublicApp(\"app_client_id\")\n)\n</code></pre>"},{"location":"#token-revocation","title":"Token Revocation","text":"<p>OAuth2Client can send revocation requests to a Revocation Endpoint. You need to provide a Revocation Endpoint URI when creating the OAuth2Client. The OAuth2Client.revoke_token() method and its specialized aliases .revoke_access_token() and .revoke_refresh_token() are then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    revocation_endpoint=\"https://url.to.the/revocation_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\noauth2client.revoke_token(\"mytoken\", token_type_hint=\"access_token\")\noauth2client.revoke_access_token(\n    \"mytoken\"\n)  # will automatically add token_type_hint=access_token\noauth2client.revoke_refresh_token(\n    \"mytoken\"\n)  # will automatically add token_type_hint=refresh_token\n</code></pre> <p>Because Revocation Endpoints usually don't return meaningful responses, those methods return a boolean. This boolean indicates that a request was successfully sent and no error was returned. If the Authorization Server returns a non-successful HTTP code, but no standardised error message, it will return <code>False</code>. If the Authorization Server actually returns a standardised error, an exception will be raised instead, like the other methods from <code>OAuth2Client</code>.</p>"},{"location":"#token-introspection","title":"Token Introspection","text":"<p>OAuth2Client can send requests to a Token Introspection Endpoint. You need to provide an Introspection Endpoint URI when creating the <code>OAuth2Client</code>. The OAuth2Client.introspect_token() method is then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    introspection_endpoint=\"https://url.to.the/introspection_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n\nresp = oauth2client.introspect_token(\"mytoken\", token_type_hint=\"access_token\")\n</code></pre> <p>It returns whatever data is returned by the introspection endpoint (if it is a JSON, its content is returned decoded).</p>"},{"location":"#userinfo-requests","title":"UserInfo Requests","text":"<p>OAuth2Client can send requests to an UserInfo Endpoint. You need to provide an UserInfo Endpoint URI when creating the <code>OAuth2Client</code>. The OAuth2Client.userinfo()) method is then available:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client(\n    token_endpoint=\"https://url.to.the/token_endpoint\",\n    userinfo_endpoint=\"https://url.to.the/userinfo_endpoint\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\nresp = oauth2client.userinfo(\"mytoken\")\n</code></pre> <p>It returns whatever data is returned by the userinfo endpoint (if it is a JSON, its content is returned decoded).</p>"},{"location":"#initializing-an-oauth2client-from-a-discovery-document","title":"Initializing an OAuth2Client from a discovery document","text":"<p>You can initialize an OAuth2Client with the endpoint URIs mentioned in a standardised discovery document with the OAuth2Client.from_discovery_endpoint() class method:</p> <pre><code>from requests_oauth2client import OAuth2Client, ClientSecretJwt\n\noauth2client = OAuth2Client.from_discovery_endpoint(\n    \"https://url.to.the/.well-known/openid-configuration\",\n    auth=ClientSecretJwt(\"client_id\", \"client_secret\"),\n)\n</code></pre> <p>This will fetch the document from the specified URI, then will decode it and initialize an OAuth2Client pointing to the appropriate endpoint URIs.</p>"},{"location":"#specialized-api-client","title":"Specialized API Client","text":"<p>Using APIs usually involves multiple endpoints under the same root url, with a common authentication method. To make it easier, <code>requests_oauth2client</code> includes a requests.Session wrapper called ApiClient, which takes the root API url as parameter on initialization. You can then send requests to different endpoints by passing their relative path instead of the full url. ApiClient also accepts an <code>auth</code> parameter with an AuthHandler. You can pass any of the OAuth2 Auth Handler from this module, or any requests-compatible Authentication Handler. Which makes it very easy to call APIs that are protected with an OAuth2 Client Credentials Grant:</p> <pre><code>from requests_oauth2client import OAuth2Client, ApiClient, OAuth2ClientCredentialsAuth\n\noauth2client = OAuth2Client(\n    \"https://url.to.the/token_endpoint\", (\"client_id\", \"client_secret\")\n)\napi = ApiClient(\n    \"https://myapi.local/root\", auth=OAuth2ClientCredentialsAuth(oauth2client)\n)\n\n# will actually send a GET to https://myapi.local/root/resource/foo\nresp = api.get(\"/resource/foo\")\n</code></pre> <p>Note that ApiClient will never send requests \"outside\" its configured root url, unless you specifically give it a full url at request time. The leading <code>/</code> in <code>/resource</code> above is optional. A leading <code>/</code> will not \"reset\" the url path to root, which means that you can also write the relative path without the <code>/</code> and it will automatically be included:</p> <pre><code>api.get(\"resource/foo\")  # will also send a GET to https://myapi.local/root/resource/foo\n</code></pre> <p>You may also pass the path as an iterable of strings (or string-able objects), in which case they will be joined with a <code>/</code> and appended to the url path:</p> <pre><code># will send a GET to https://myapi.local/root/resource/foo\napi.get([\"resource\", \"foo\"])\n# will send a GET to https://myapi.local/root/users/1234/details\napi.get([\"users\", 1234, \"details\"])\n</code></pre> <p>You can also use a syntax based on <code>__getattr__</code> or <code>__getitem__</code>:</p> <pre><code>api.resource.get()  # will send a GET to https://myapi.local/root/resource\napi[\"my-resource\"].get()  # will send a GET to https://myapi.local/root/my-resource\n</code></pre> <p>Both <code>__getattr__</code> and <code>__getitem__</code> return a new <code>ApiClient</code> initialised on the new base_url. So you can easily call multiple sub-resources on the same API this way:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local\")\nusers_api = api.users\nuser = users_api.get(\"userid\")  # GET https://myapi.local/users/userid\nother_user = users_api.get(\"other_userid\")  # GET https://myapi.local/users/other_userid\nresources_api = api.resources\nresources = resources_api.get()  # GET https://myapi.local/resources\n</code></pre> <p>ApiClient will, by default, raise exceptions whenever a request returns an error status. You can disable that by passing <code>raise_for_status=False</code> when initializing your ApiClient:</p> <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\n    \"http://httpstat.us\", raise_for_status=False\n)  # raise_for_status defaults to True\nresp = api.get(\"500\")\nassert resp is not None\n# without raise_for_status=False, a requests.exceptions.HTTPError exception would be raised instead\n</code></pre> <p>You may override this at request time:</p> <pre><code># raise_for_status at request-time overrides the value defined at init-time\nresp = api.get(\"500\", raise_for_status=True)\n</code></pre> <p>You can access the underlying <code>requests.Session</code> with the session attribute, and you can provide an already existing and configured <code>Session</code> instance at init time:</p> <pre><code>import requests\nfrom requests_oauth2client import ApiClient\n\nsession = requests.Session()\nsession.proxies = {\"https\": \"http://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\nassert api.session == session\n</code></pre>"},{"location":"#vendor-specific-clients","title":"Vendor-Specific clients","text":"<p><code>requests_oauth2client</code> being flexible enough to handle most use cases, you should be able to use any AS by any vendor as long as it supports OAuth 2.0.</p> <p>You can however create a subclass of OAuth2Client or ApiClient to make it easier to use with specific Authorization Servers or APIs. The sub-module <code>requests_oauth2client.vendor_specific</code> includes such classes for Auth0:</p> <pre><code>from requests_oauth2client.vendor_specific import Auth0Client, Auth0ManagementApiClient\n\na0client = Auth0Client(\"mytenant.eu\", (\"client_id\", \"client_secret\"))\n# this will automatically initialize the token endpoint to https://mytenant.eu.auth0.com/oauth/token\n# and other endpoints accordingly\ntoken = a0client.client_credentials(audience=\"audience\")\n\n# this is a wrapper around Auth0 Management API\na0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (\"client_id\", \"client_secret\"))\nmyusers = a0mgmt.get(\"users\")\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#requests_oauth2client","title":"<code>requests_oauth2client</code>","text":"<p>Main module for <code>requests_oauth2client</code>.</p> <p>You can import any class from any submodule directly from this main module.</p>"},{"location":"api/#requests_oauth2client.client_authentication","title":"<code>client_authentication</code>","text":"<p>This modules implements OAuth 2.0 Client Authentication Methods.</p> <p>An OAuth 2.0 Client must authenticate to the AS whenever it sends a request to the Token Endpoint, by including appropriate credentials. This module contains helper classes and methods that implement the standardised and commonly used Client Authentication Methods.</p>"},{"location":"api/#requests_oauth2client.client_authentication.BaseClientAuthenticationMethod","title":"<code>BaseClientAuthenticationMethod</code>","text":"<p>         Bases: <code>requests.auth.AuthBase</code></p> <p>Base class for all Client Authentication methods. This extends [requests.auth.AuthBase].</p> <p>This base class only checks that requests are suitable to add Client Authentication parameters to, and doesn't modify the request.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class BaseClientAuthenticationMethod(requests.auth.AuthBase):\n\"\"\"Base class for all Client Authentication methods. This extends [requests.auth.AuthBase].\n\n    This base class only checks that requests are suitable to add Client Authentication parameters\n    to, and doesn't modify the request.\n    \"\"\"\n\n    def __init__(self, client_id: str):\n        self.client_id = str(client_id)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Check that the request is suitable for Client Authentication.\n\n        It checks:\n        * that the method is `POST`\n        * that the Content-Type is \"application/x-www-form-urlencoded\" or None\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][], unmodified\n\n        Raises:\n            RuntimeError: if the request is not suitable for OAuth 2.0 Client Authentication\n        \"\"\"\n        if request.method != \"POST\" or request.headers.get(\"Content-Type\") not in (\n            \"application/x-www-form-urlencoded\",\n            None,\n        ):\n            raise RuntimeError(\n                \"This request is not suitable for OAuth 2.0 Client Authentication\"\n            )\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretBasic","title":"<code>ClientSecretBasic</code>","text":"<p>         Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_basic</code> authentication.</p> <p>With this method, the client sends its Client ID and Secret, in the Authorization header, with the \"Basic\" scheme, in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p><code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p><code>client_secret</code> to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretBasic(BaseClientAuthenticationMethod):\n\"\"\"Implement `client_secret_basic` authentication.\n\n    With this method, the client sends its Client ID and Secret, in the Authorization header, with the \"Basic\" scheme,\n    in each authenticated request to the AS.\n\n    Args:\n        client_id: `client_id` to use.\n        client_secret: `client_secret` to use.\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str):\n        super().__init__(client_id)\n        self.client_secret = str(client_secret)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Add the appropriate `Authorization` header in each request.\n\n        The Authorization header is formatted as such:\n        `Authorization: Basic BASE64('&lt;client_id:client_secret&gt;')`\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added Authorization header.\n        \"\"\"\n        request = super().__call__(request)\n        b64encoded_credentials = (\n            BinaPy(f\"{self.client_id}:{self.client_secret}\").to(\"b64\").ascii()\n        )\n        request.headers[\"Authorization\"] = f\"Basic {b64encoded_credentials}\"\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretPost","title":"<code>ClientSecretPost</code>","text":"<p>         Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement <code>client_secret_post</code> client authentication method.</p> <p>With this method, the client inserts its client_id and client_secret in each authenticated request to the AS.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p><code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p><code>client_secret</code> to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretPost(BaseClientAuthenticationMethod):\n\"\"\"Implement `client_secret_post` client authentication method.\n\n     With this method, the client inserts its client_id and client_secret in each authenticated request to the AS.\n\n    Args:\n        client_id: `client_id` to use.\n        client_secret: `client_secret` to use.\n    \"\"\"\n\n    def __init__(self, client_id: str, client_secret: str) -&gt; None:\n        super().__init__(client_id)\n        self.client_secret = str(client_secret)\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Add the `client_id` and `client_secret` parameters in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added client credentials fields.\n        \"\"\"\n        request = super().__call__(request)\n        data = furl.Query(request.body)\n        data.set([(\"client_id\", self.client_id), (\"client_secret\", self.client_secret)])\n        request.prepare_body(data.params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod","title":"<code>ClientAssertionAuthenticationMethod</code>","text":"<p>         Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Base class for assertion based client authentication methods.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the client_id to use</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> required <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> required <code>jti_gen</code> <code>Callable[[], str]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> required <code>aud</code> <code>Optional[str]</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientAssertionAuthenticationMethod(BaseClientAuthenticationMethod):\n\"\"\"Base class for assertion based client authentication methods.\n\n    Args:\n        client_id: the client_id to use\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        alg: str,\n        lifetime: int,\n        jti_gen: Callable[[], str],\n        aud: Optional[str] = None,\n    ) -&gt; None:\n        super().__init__(client_id)\n        self.alg = alg\n        self.lifetime = lifetime\n        self.jti_gen = jti_gen\n        self.aud = aud\n\n    def client_assertion(self, audience: str) -&gt; str:\n\"\"\"Generate a Client Assertion for a specific audience.\n\n        Args:\n            audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n        \"\"\"\n        raise NotImplementedError()  # pragma: no cover\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Add a `client_assertion` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_assertion` field.\n        \"\"\"\n        request = super().__call__(request)\n        audience = self.aud or request.url\n        assert audience is not None\n        data = furl.Query(request.body)\n        client_assertion = self.client_assertion(audience)\n        data.set(\n            [\n                (\"client_id\", self.client_id),\n                (\"client_assertion\", client_assertion),\n                (\n                    \"client_assertion_type\",\n                    \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n                ),\n            ]\n        )\n        request.prepare_body(data.params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientAssertionAuthenticationMethod.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion for a specific audience.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the <code>aud</code> claim of the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n\"\"\"Generate a Client Assertion for a specific audience.\n\n    Args:\n        audience: the audience to use for the `aud` claim of the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n    \"\"\"\n    raise NotImplementedError()  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt","title":"<code>ClientSecretJwt</code>","text":"<p>         Bases: <code>ClientAssertionAuthenticationMethod</code></p> <p>Implement <code>client_secret_jwt</code> client authentication method.</p> <p>With this method, client generates and signs a client assertion that is symmetrically signed with its Client Secret.  The assertion is then sent to the AS in a <code>client_assertion</code> field with each authenticated request.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>client_secret</code> <code>str</code> <p>the <code>client_secret</code> to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>'HS256'</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], Any]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda : uuid4()</code> <code>aud</code> <code>Optional[str]</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class ClientSecretJwt(ClientAssertionAuthenticationMethod):\n\"\"\"Implement `client_secret_jwt` client authentication method.\n\n     With this method, client generates and signs a client assertion that is symmetrically signed with its Client Secret.\n     The assertion is then sent to the AS in a `client_assertion` field with each authenticated request.\n\n    Args:\n        client_id: the `client_id` to use.\n        client_secret: the `client_secret` to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        alg: str = \"HS256\",\n        lifetime: int = 60,\n        jti_gen: Callable[[], Any] = lambda: uuid4(),\n        aud: Optional[str] = None,\n    ) -&gt; None:\n        super().__init__(client_id, alg, lifetime, jti_gen, aud)\n        self.client_secret = str(client_secret)\n\n    def client_assertion(self, audience: str) -&gt; str:\n\"\"\"Generate a symmetrically signed Client Assertion.\n\n        Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion, as `str`.\n        \"\"\"\n        iat = int(datetime.now().timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.ClientSecretJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a symmetrically signed Client Assertion.</p> <p>Assertion is signed with the <code>client_secret</code> as key and the <code>alg</code> passed at init time.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion, as <code>str</code>.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n\"\"\"Generate a symmetrically signed Client Assertion.\n\n    Assertion is signed with the `client_secret` as key and the `alg` passed at init time.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion, as `str`.\n    \"\"\"\n    iat = int(datetime.now().timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwk = SymmetricJwk.from_bytes(self.client_secret.encode())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt","title":"<code>PrivateKeyJwt</code>","text":"<p>         Bases: <code>ClientAssertionAuthenticationMethod</code></p> <p>Implement <code>private_key_jwt</code> client authentication method.</p> <p>With this method, the client generates and sends a client_assertion, that is asymmetrically signed with a private key, on each direct request to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the <code>client_id</code> to use.</p> required <code>private_jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the private JWK to use to sign generated Client Assertions.</p> required <code>alg</code> <code>str</code> <p>the alg to use to sign generated Client Assertions.</p> <code>'RS256'</code> <code>lifetime</code> <code>int</code> <p>the lifetime to use for generated Client Assertions.</p> <code>60</code> <code>jti_gen</code> <code>Callable[[], Any]</code> <p>a function to generate JWT Token Ids (<code>jti</code>) for generated Client Assertions.</p> <code>lambda : uuid4()</code> <code>aud</code> <code>Optional[str]</code> <p>the audience value to use. If <code>None</code> (default), the endpoint URL will be used.k</p> <code>None</code> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class PrivateKeyJwt(ClientAssertionAuthenticationMethod):\n\"\"\"Implement `private_key_jwt` client authentication method.\n\n    With this method, the client generates and sends a client_assertion, that is\n    asymmetrically signed with a private key, on each direct request to the Authorization Server.\n\n    Args:\n        client_id: the `client_id` to use.\n        private_jwk: the private JWK to use to sign generated Client Assertions.\n        alg: the alg to use to sign generated Client Assertions.\n        lifetime: the lifetime to use for generated Client Assertions.\n        jti_gen: a function to generate JWT Token Ids (`jti`) for generated Client Assertions.\n        aud: the audience value to use. If `None` (default), the endpoint URL will be used.k\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        private_jwk: Union[Jwk, Dict[str, Any]],\n        alg: str = \"RS256\",\n        lifetime: int = 60,\n        jti_gen: Callable[[], Any] = lambda: uuid4(),\n        aud: Optional[str] = None,\n    ) -&gt; None:\n        if not isinstance(private_jwk, Jwk):\n            private_jwk = Jwk(private_jwk)\n\n        if not private_jwk.is_private or private_jwk.is_symmetric:\n            raise ValueError(\n                \"Private Key JWT client authentication method uses asymmetric signing thus requires a private key.\"\n            )\n\n        alg = private_jwk.alg or alg\n        if not alg:\n            raise ValueError(\n                \"An asymmetric signing alg is required, either as part of the private JWK, or passed as parameter.\"\n            )\n        kid = private_jwk.get(\"kid\")\n        if not kid:\n            raise ValueError(\n                \"Asymmetric signing requires the private JWK to have a Key ID (kid).\"\n            )\n\n        super().__init__(client_id, alg, lifetime, jti_gen, aud)\n        self.private_jwk = private_jwk\n\n    def client_assertion(self, audience: str) -&gt; str:\n\"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n        Args:\n            audience: the audience to use for the generated Client Assertion.\n\n        Returns:\n            a Client Assertion.\n        \"\"\"\n        iat = int(datetime.now().timestamp())\n        exp = iat + self.lifetime\n        jti = str(self.jti_gen())\n\n        jwt = Jwt.sign(\n            claims={\n                \"iss\": self.client_id,\n                \"sub\": self.client_id,\n                \"aud\": audience,\n                \"iat\": iat,\n                \"exp\": exp,\n                \"jti\": jti,\n            },\n            key=self.private_jwk,\n            alg=self.alg,\n        )\n        return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PrivateKeyJwt.client_assertion","title":"<code>client_assertion(audience)</code>","text":"<p>Generate a Client Assertion, asymmetrically signed with <code>private_jwk</code> as key.</p> <p>Parameters:</p> Name Type Description Default <code>audience</code> <code>str</code> <p>the audience to use for the generated Client Assertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>a Client Assertion.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_assertion(self, audience: str) -&gt; str:\n\"\"\"Generate a Client Assertion, asymmetrically signed with `private_jwk` as key.\n\n    Args:\n        audience: the audience to use for the generated Client Assertion.\n\n    Returns:\n        a Client Assertion.\n    \"\"\"\n    iat = int(datetime.now().timestamp())\n    exp = iat + self.lifetime\n    jti = str(self.jti_gen())\n\n    jwt = Jwt.sign(\n        claims={\n            \"iss\": self.client_id,\n            \"sub\": self.client_id,\n            \"aud\": audience,\n            \"iat\": iat,\n            \"exp\": exp,\n            \"jti\": jti,\n        },\n        key=self.private_jwk,\n        alg=self.alg,\n    )\n    return str(jwt)\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.PublicApp","title":"<code>PublicApp</code>","text":"<p>         Bases: <code>BaseClientAuthenticationMethod</code></p> <p>Implement the <code>none</code> authentication method for public apps.</p> <p>This scheme is used for Public Clients, which do not have any secret credentials. Those only send their client_id to the Authorization Server.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>the client_id to use.</p> required Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>class PublicApp(BaseClientAuthenticationMethod):\n\"\"\"Implement the `none` authentication method for public apps.\n\n    This scheme is used for Public Clients, which do not have any secret credentials. Those only\n    send their client_id to the Authorization Server.\n\n    Args:\n        client_id: the client_id to use.\n    \"\"\"\n\n    def __init__(self, client_id: str) -&gt; None:\n        self.client_id = client_id\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Add the `client_id` field in the request body.\n\n        Args:\n            request: a [requests.PreparedRequest][].\n\n        Returns:\n            a [requests.PreparedRequest][] with the added `client_id` field.\n        \"\"\"\n        request = super().__call__(request)\n        data = furl.Query(request.body)\n        data.set([(\"client_id\", self.client_id)])\n        request.prepare_body(data.params, files=None)\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.client_authentication.client_auth_factory","title":"<code>client_auth_factory(auth, *, client_id=None, client_secret=None, private_key=None, default_auth_handler=ClientSecretPost)</code>","text":"<p>Initialize the appropriate Auth Handler based on the provided parameters.</p> <p>This initializes a <code>ClientAuthenticationMethod</code> subclass based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>Union[requests.auth.AuthBase, Tuple[str, str], Tuple[str, Jwk], Tuple[str, Dict[str, Any]], str, None]</code> <p>can be: - a <code>requests.auth.AuthBase</code> instance (which will be used directly) - a tuple of (client_id, client_secret) which will be used to initialize an instance of <code>default_auth_handler</code>, - a tuple of (client_id, jwk), used to initialize a <code>PrivateKeyJwk</code> (<code>jwk</code> being an instance of <code>jwskate.Jwk</code> or a <code>dict</code>), - a <code>client_id</code>, as <code>str</code>, - or <code>None</code>, to pass <code>client_id</code> and other credentials as dedicated parameters, see below.</p> required <code>client_id</code> <code>Optional[str]</code> <p>the Client ID to use for this client</p> <code>None</code> <code>client_secret</code> <code>Optional[str]</code> <p>the Client Secret to use for this client, if any (for clients using an authentication method based on a secret)</p> <code>None</code> <code>private_key</code> <code>Union[Jwk, Dict[str, Any], None]</code> <p>the private key to use for private_key_jwt authentication method</p> <code>None</code> <code>default_auth_handler</code> <code>Union[Type[ClientSecretPost], Type[ClientSecretBasic], Type[ClientSecretJwt]]</code> <p>if a client_id and client_secret are provided, initialize an instance of this class with those 2 parameters. You can choose between <code>ClientSecretBasic</code>, <code>ClientSecretPost</code>, or <code>ClientSecretJwt</code>.</p> <code>ClientSecretPost</code> <p>Returns:</p> Type Description <code>requests.auth.AuthBase</code> <p>an Auth Handler that will manage client authentication to the AS Token Endpoint or other backend endpoints.</p> Source code in <code>requests_oauth2client/client_authentication.py</code> <pre><code>def client_auth_factory(\n    auth: Union[\n        requests.auth.AuthBase,\n        Tuple[str, str],\n        Tuple[str, Jwk],\n        Tuple[str, Dict[str, Any]],\n        str,\n        None,\n    ],\n    *,\n    client_id: Optional[str] = None,\n    client_secret: Optional[str] = None,\n    private_key: Union[Jwk, Dict[str, Any], None] = None,\n    default_auth_handler: Union[\n        Type[ClientSecretPost], Type[ClientSecretBasic], Type[ClientSecretJwt]\n    ] = ClientSecretPost,\n) -&gt; requests.auth.AuthBase:\n\"\"\"Initialize the appropriate Auth Handler based on the provided parameters.\n\n    This initializes a `ClientAuthenticationMethod` subclass based on the provided parameters.\n\n    Args:\n        auth: can be:\n            - a `requests.auth.AuthBase` instance (which will be used directly)\n            - a tuple of (client_id, client_secret) which will be used to initialize an instance of `default_auth_handler`,\n            - a tuple of (client_id, jwk), used to initialize a `PrivateKeyJwk` (`jwk` being an instance of `jwskate.Jwk` or a `dict`),\n            - a `client_id`, as `str`,\n            - or `None`, to pass `client_id` and other credentials as dedicated parameters, see below.\n        client_id: the Client ID to use for this client\n        client_secret: the Client Secret to use for this client, if any (for clients using an authentication method based on a secret)\n        private_key: the private key to use for private_key_jwt authentication method\n        default_auth_handler: if a client_id and client_secret are provided, initialize an instance of this class with those 2 parameters.\n            You can choose between `ClientSecretBasic`, `ClientSecretPost`, or `ClientSecretJwt`.\n\n    Returns:\n        an Auth Handler that will manage client authentication to the AS Token Endpoint or other backend endpoints.\n    \"\"\"\n    if auth is not None and (\n        client_id is not None or client_secret is not None or private_key is not None\n    ):\n        raise ValueError(\n            \"Please use either `auth` parameter to provide an authentication method, or use `client_id` and one of `client_secret` or `private_key`.\"\n        )\n\n    if isinstance(auth, str):\n        client_id = auth\n    elif isinstance(auth, requests.auth.AuthBase):\n        return auth\n    elif isinstance(auth, tuple) and len(auth) == 2:\n        client_id, credential = auth\n        if isinstance(credential, (Jwk, dict)):\n            private_key = credential\n        elif isinstance(credential, str):\n            client_secret = credential\n        else:\n            raise TypeError(\n                \"This credential type is not supported:\", type(credential), credential\n            )\n\n    if client_id is None:\n        raise ValueError(\"A client_id must be provided.\")\n\n    if private_key is not None:\n        return PrivateKeyJwt(str(client_id), private_key)\n    elif client_secret is None:\n        return PublicApp(str(client_id))\n    else:\n        return default_auth_handler(str(client_id), str(client_secret))\n</code></pre>"},{"location":"api/#requests_oauth2client.client","title":"<code>client</code>","text":"<p>This module contains the <code>OAuth2Client</code> class.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client","title":"<code>OAuth2Client</code>","text":"<p>An OAuth 2.x client, that can send requests to an OAuth 2.x Authorization Server.</p> <p><code>OAuth2Client</code> is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types, and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.</p> <p>To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials that will be used to authenticate to that endpoint. Other endpoint urls, such as the  can be passed as parameter as well if you intend to use them.</p> <p>This class is not intended to help with the end-user authentication or any request that goes in a browser. For authentication requests, see AuthorizationRequest. You may use the helper method <code>authorization_request()</code> to generate <code>AuthorizationRequest</code>s with the preconfigured <code>authorization_endpoint</code>, <code>client_id</code> and `redirect_uri' from this client.</p> <p>Parameters:</p> Name Type Description Default <code>token_endpoint</code> <code>str</code> <p>the Token Endpoint URI where this client will get access tokens</p> required <code>auth</code> <code>Union[requests.auth.AuthBase, Tuple[str, str], Tuple[str, Jwk], Tuple[str, Dict[str, Any]], str, None]</code> <p>the authentication handler to use for client authentication on the token endpoint. Can be a requests.auth.AuthBase instance (which will be as-is), or a tuple of <code>(client_id, client_secret)</code> which will initialize an instance of ClientSecretPost, a <code>(client_id, jwk)</code> to initialize a PrivateKeyJwt, or a <code>client_id</code> which will use PublicApp authentication.</p> <code>None</code> <code>client_id</code> <code>Optional[str]</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>Optional[str]</code> <p>client secret</p> <code>None</code> <code>private_key</code> <code>Union[Jwk, Dict[str, Any], None]</code> <p>private_key to use for client authentication</p> <code>None</code> <code>revocation_endpoint</code> <code>Optional[str]</code> <p>the Revocation Endpoint URI to use for revoking tokens</p> <code>None</code> <code>introspection_endpoint</code> <code>Optional[str]</code> <p>the Introspection Endpoint URI to use to get info about tokens</p> <code>None</code> <code>userinfo_endpoint</code> <code>Optional[str]</code> <p>the Userinfo Endpoint URI to use to get information about the user</p> <code>None</code> <code>authorization_endpoint</code> <code>Optional[str]</code> <p>the Authorization Endpoint URI for initializing Authorization Requests</p> <code>None</code> <code>redirect_uri</code> <code>Optional[str]</code> <p>the redirect_uri for this client</p> <code>None</code> <code>backchannel_authentication_endpoint</code> <code>Optional[str]</code> <p>the BackChannel Authentication URI</p> <code>None</code> <code>device_authorization_endpoint</code> <code>Optional[str]</code> <p>the Device Authorization Endpoint URI to use to authorize devices</p> <code>None</code> <code>jwks_uri</code> <code>Optional[str]</code> <p>the JWKS URI to use to obtain the AS public keys</p> <code>None</code> <code>code_challenge_method</code> <code>str</code> <p>challenge method to use for PKCE (should always be 'S256')</p> <code>'S256'</code> <code>session</code> <code>Optional[requests.Session]</code> <p>a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.</p> <code>None</code> <code>**extra_metadata</code> <code>Any</code> <p>additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the <code>extra_metadata</code> attribute.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\",\n    revocation_endpoint=\"https://my.as.local/revoke\",\n    auth=(\"client_id\", \"client_secret\"),\n)\n\n# once initialized, a client can send requests to its configured endpoints\ncc_token = client.client_credentials(scope=\"my_scope\")\nac_token = client.authorization_code(code=\"my_code\")\nclient.revoke_access_token(cc_token)\n</code></pre> Source code in <code>requests_oauth2client/client.py</code> <pre><code>class OAuth2Client:\n\"\"\"An OAuth 2.x client, that can send requests to an OAuth 2.x Authorization Server.\n\n    `OAuth2Client` is able to obtain tokens from the Token Endpoint using any of the standardised Grant Types,\n    and to communicate with the various backend endpoints like the Revocation, Introspection, and UserInfo Endpoint.\n\n    To init an OAuth2Client, you only need the url to the Token Endpoint and the Credentials that will be used to authenticate\n    to that endpoint. Other endpoint urls, such as the  can be passed as parameter as well if you intend to use them.\n\n\n    This class is not intended to help with the end-user authentication or any request that goes in a browser.\n    For authentication requests, see [AuthorizationRequest][requests_oauth2client.authorization_request.AuthorizationRequest].\n    You may use the helper method `authorization_request()` to generate `AuthorizationRequest`s with the preconfigured\n    `authorization_endpoint`, `client_id` and `redirect_uri' from this client.\n\n    Args:\n        token_endpoint: the Token Endpoint URI where this client will get access tokens\n        auth: the authentication handler to use for client authentication on the token endpoint. Can be a [requests.auth.AuthBase][] instance (which will be as-is), or a tuple of `(client_id, client_secret)` which will initialize an instance of [ClientSecretPost][requests_oauth2client.client_authentication.ClientSecretPost], a `(client_id, jwk)` to initialize a [PrivateKeyJwt][requests_oauth2client.client_authentication.PrivateKeyJwt], or a `client_id` which will use [PublicApp][requests_oauth2client.client_authentication.PublicApp] authentication.\n        client_id: client ID\n        client_secret: client secret\n        private_key: private_key to use for client authentication\n        revocation_endpoint: the Revocation Endpoint URI to use for revoking tokens\n        introspection_endpoint: the Introspection Endpoint URI to use to get info about tokens\n        userinfo_endpoint: the Userinfo Endpoint URI to use to get information about the user\n        authorization_endpoint: the Authorization Endpoint URI for initializing Authorization Requests\n        redirect_uri: the redirect_uri for this client\n        backchannel_authentication_endpoint: the BackChannel Authentication URI\n        device_authorization_endpoint: the Device Authorization Endpoint URI to use to authorize devices\n        jwks_uri: the JWKS URI to use to obtain the AS public keys\n        code_challenge_method: challenge method to use for PKCE (should always be 'S256')\n        session: a requests Session to use when sending HTTP requests. Useful if some extra parameters such as proxy or client certificate must be used to connect to the AS.\n        **extra_metadata: additional metadata for this client, unused by this class, but may be used by subclasses. Those will be accessible with the `extra_metadata` attribute.\n\n    Usage:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\",\n            revocation_endpoint=\"https://my.as.local/revoke\",\n            auth=(\"client_id\", \"client_secret\"),\n        )\n\n        # once initialized, a client can send requests to its configured endpoints\n        cc_token = client.client_credentials(scope=\"my_scope\")\n        ac_token = client.authorization_code(code=\"my_code\")\n        client.revoke_access_token(cc_token)\n        ```\n    \"\"\"\n\n    exception_classes: Dict[str, Type[Exception]] = {\n        \"server_error\": ServerError,\n        \"invalid_request\": InvalidRequest,\n        \"invalid_client\": InvalidClient,\n        \"invalid_scope\": InvalidScope,\n        \"invalid_target\": InvalidTarget,\n        \"invalid_grant\": InvalidGrant,\n        \"access_denied\": AccessDenied,\n        \"unauthorized_client\": UnauthorizedClient,\n        \"authorization_pending\": AuthorizationPending,\n        \"slow_down\": SlowDown,\n        \"expired_token\": ExpiredToken,\n        \"unsupported_token_type\": UnsupportedTokenType,\n    }\n\n    token_class: Type[BearerToken] = BearerToken\n\n    def __init__(\n        self,\n        token_endpoint: str,\n        auth: Union[\n            requests.auth.AuthBase,\n            Tuple[str, str],\n            Tuple[str, Jwk],\n            Tuple[str, Dict[str, Any]],\n            str,\n            None,\n        ] = None,\n        *,\n        client_id: Optional[str] = None,\n        client_secret: Optional[str] = None,\n        private_key: Union[Jwk, Dict[str, Any], None] = None,\n        revocation_endpoint: Optional[str] = None,\n        introspection_endpoint: Optional[str] = None,\n        userinfo_endpoint: Optional[str] = None,\n        authorization_endpoint: Optional[str] = None,\n        redirect_uri: Optional[str] = None,\n        backchannel_authentication_endpoint: Optional[str] = None,\n        device_authorization_endpoint: Optional[str] = None,\n        pushed_authorization_request_endpoint: Optional[str] = None,\n        jwks_uri: Optional[str] = None,\n        authorization_server_jwks: Union[JwkSet, Dict[str, Any], None] = None,\n        issuer: Optional[str] = None,\n        id_token_signed_response_alg: Optional[str] = \"RS256\",\n        id_token_encrypted_response_alg: Optional[str] = None,\n        id_token_decryption_key: Union[Jwk, Dict[str, Any], None] = None,\n        code_challenge_method: str = \"S256\",\n        authorization_response_iss_parameter_supported: bool = False,\n        session: Optional[requests.Session] = None,\n        **extra_metadata: Any,\n    ):\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise ValueError(\n                \"If the Authorization Server supports Issuer Identification, \"\n                \"as specified by `authorization_response_iss_parameter_supported=True`, \"\n                \"then you must specify the expected `issuer` value with parameter `issuer`.\"\n            )\n        self.token_endpoint = str(token_endpoint)\n        self.revocation_endpoint = str(revocation_endpoint) if revocation_endpoint else None\n        self.introspection_endpoint = (\n            str(introspection_endpoint) if introspection_endpoint else None\n        )\n        self.userinfo_endpoint = str(userinfo_endpoint) if userinfo_endpoint else None\n        self.authorization_endpoint = (\n            str(authorization_endpoint) if authorization_endpoint else None\n        )\n        self.redirect_uri = str(redirect_uri) if redirect_uri else None\n        self.backchannel_authentication_endpoint = (\n            str(backchannel_authentication_endpoint)\n            if backchannel_authentication_endpoint\n            else None\n        )\n        self.device_authorization_endpoint = (\n            str(device_authorization_endpoint) if device_authorization_endpoint else None\n        )\n        self.pushed_authorization_request_endpoint = (\n            str(pushed_authorization_request_endpoint)\n            if pushed_authorization_request_endpoint\n            else None\n        )\n        self.jwks_uri = str(jwks_uri) if jwks_uri else None\n        self.authorization_server_jwks = (\n            JwkSet(authorization_server_jwks) if authorization_server_jwks else None\n        )\n        self.issuer = str(issuer) if issuer else None\n        self.session = session or requests.Session()\n        self.auth = client_auth_factory(\n            auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            default_auth_handler=ClientSecretPost,\n        )\n        self.id_token_signed_response_alg = id_token_signed_response_alg\n        self.id_token_encrypted_response_alg = id_token_encrypted_response_alg\n        self.id_token_decryption_key = (\n            Jwk(id_token_decryption_key) if id_token_decryption_key else None\n        )\n        self.code_challenge_method = code_challenge_method\n        self.authorization_response_iss_parameter_supported = (\n            authorization_response_iss_parameter_supported\n        )\n        self.extra_metadata = extra_metadata\n\n    @property\n    def client_id(self) -&gt; str:\n\"\"\"Client ID.\"\"\"\n        if hasattr(self.auth, \"client_id\"):\n            return self.auth.client_id  # type: ignore[no-any-return]\n        raise AttributeError(  # pragma: no cover\n            \"This client uses a custom authentication method without client_id.\"\n        )\n\n    @property\n    def client_secret(self) -&gt; Optional[str]:\n\"\"\"Client Secret.\"\"\"\n        if hasattr(self.auth, \"client_secret\"):\n            return self.auth.client_secret  # type: ignore[no-any-return]\n        return None\n\n    @property\n    def client_jwks(self) -&gt; JwkSet:\n\"\"\"A `JwkSet` containing the public keys for this client.\n\n        Keys are:\n\n        - the public key for client assertion signature verification (if using private_key_jwt)\n        - the ID Token encryption key\n        \"\"\"\n        jwks = JwkSet()\n        if isinstance(self.auth, PrivateKeyJwt):\n            jwks.add_jwk(self.auth.private_jwk.public_jwk().with_usage_parameters())\n        if self.id_token_decryption_key:\n            jwks.add_jwk(self.id_token_decryption_key.public_jwk().with_usage_parameters())\n        return jwks\n\n    def token_request(\n        self, data: Dict[str, Any], timeout: int = 10, **requests_kwargs: Any\n    ) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint.\n\n        Authentication will be added automatically based on the defined `auth` for this client.\n\n        Args:\n             data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request.\n             timeout: a timeout value for the call\n             **requests_kwargs: additional parameters for requests.post()\n\n        Returns:\n            the token endpoint response, as [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n        \"\"\"\n        token_endpoint = self._require_endpoint(\"token_endpoint\")\n\n        requests_kwargs = {\n            key: value\n            for key, value in requests_kwargs.items()\n            if value is not None and value != \"\"\n        }\n\n        response = self.session.post(\n            token_endpoint,\n            auth=self.auth,\n            data=data,\n            timeout=timeout,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return self.parse_token_response(response)\n\n        return self.on_token_error(response)\n\n    def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n\"\"\"Parse a Response returned by the Token Endpoint.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse responses returned by the Token Endpoint.\n        Those response contain an `access_token` and additional attributes.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response contents.\n        \"\"\"\n        try:\n            token_response = self.token_class(**response.json())\n            return token_response\n        except Exception as response_class_exc:\n            try:\n                return self.on_token_error(response)\n            except Exception as token_error_exc:\n                raise token_error_exc from response_class_exc\n\n    def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n\"\"\"Error handler for `token_request()`.\n\n        Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the Token Endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] returned by the Token Endpoint.\n\n        Returns:\n            nothing, and raises an exception instead. But a subclass may return a [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default behaviour if needed.\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidTokenResponse(response) from exc\n        raise exception\n\n    def client_credentials(\n        self,\n        scope: Optional[Union[str, Iterable[str]]] = None,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n        Args:\n            scope: the scope to send with the request. Can be a str, or an iterable of str.\n                to pass that way include `scope`, `audience`, `resource`, etc.\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n        Returns:\n            a TokenResponse\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise ValueError(\"Unsupported scope value\") from exc\n\n        data = dict(grant_type=\"client_credentials\", scope=scope, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_code(\n        self,\n        code: Union[str, AuthorizationResponse],\n        validate: bool = True,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n        Args:\n             code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n             validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n             requests_kwargs: additional parameters for the call to requests\n             **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n        Returns:\n            a `BearerToken`\n        \"\"\"\n        azr: Optional[AuthorizationResponse] = None\n        if isinstance(code, AuthorizationResponse):\n            token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n            token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n            azr = code\n            code = code.code\n\n        requests_kwargs = requests_kwargs or {}\n\n        data = dict(grant_type=\"authorization_code\", code=code, **token_kwargs)\n        token = self.token_request(data, **requests_kwargs)\n        if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n            token.validate_id_token(self, azr)\n        return token\n\n    def refresh_token(\n        self,\n        refresh_token: Union[str, BearerToken],\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n        Args:\n            refresh_token: a refresh_token, as a string, or as a `BearerToken`. That `BearerToken` must have a `refresh_token`.\n            requests_kwargs: additional parameters for the call to `requests`\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `refresh_token`, etc.\n\n        Returns:\n            a `BearerToken`\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None or not isinstance(\n                refresh_token.refresh_token, str\n            ):\n                raise ValueError(\"This BearerToken doesn't have a refresh_token\")\n            refresh_token = refresh_token.refresh_token\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(grant_type=\"refresh_token\", refresh_token=refresh_token, **token_kwargs)\n        return self.token_request(data, **requests_kwargs)\n\n    def device_code(\n        self,\n        device_code: Union[str, DeviceAuthorizationResponse],\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint using the Device Code grant.\n\n        The grant_type is `urn:ietf:params:oauth:grant-type:device_code`.\n        This needs a Device Code, or a `DeviceAuthorizationResponse` as parameter.\n\n        Args:\n            device_code: a device code, or a `DeviceAuthorizationResponse`\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n        Returns:\n            a `BearerToken`\n        \"\"\"\n        if isinstance(device_code, DeviceAuthorizationResponse):\n            if device_code.device_code is None or not isinstance(device_code.device_code, str):\n                raise ValueError(\"This DeviceAuthorizationResponse doesn't have a device_code\")\n            device_code = device_code.device_code\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=\"urn:ietf:params:oauth:grant-type:device_code\",\n            device_code=device_code,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def ciba(\n        self,\n        auth_req_id: Union[str, BackChannelAuthenticationResponse],\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a CIBA request to the Token Endpoint.\n\n        A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n        Args:\n            auth_req_id: an authentication request ID, as returned by the AS\n            requests_kwargs: additional parameters for the call to requests\n            **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n        Returns:\n            a `BearerToken`\n        \"\"\"\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n            if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n                raise ValueError(\n                    \"This BackChannelAuthenticationResponse doesn't have an auth_req_id\"\n                )\n            auth_req_id = auth_req_id.auth_req_id\n\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=\"urn:openid:params:grant-type:ciba\",\n            auth_req_id=auth_req_id,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def token_exchange(\n        self,\n        subject_token: Union[str, BearerToken, IdToken],\n        subject_token_type: Optional[str] = None,\n        actor_token: Union[None, str, BearerToken, IdToken] = None,\n        actor_token_type: Optional[str] = None,\n        requested_token_type: Optional[str] = None,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a Token Exchange request.\n\n        A Token Exchange request is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n        Args:\n            subject_token: the subject token to exchange for a new token.\n            subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n                on `type(subject_token)`.\n            actor_token: the actor token to include in the request, if any.\n            actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n                on `type(actor_token)`.\n            requested_token_type: a token type identifier for the requested token.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        try:\n            subject_token_type = self.get_token_type(subject_token_type, subject_token)\n        except ValueError:\n            raise TypeError(\n                \"Cannot determine the kind of 'subject_token' you provided. \"\n                \"Please specify a 'subject_token_type'.\"\n            )\n        if actor_token:  # pragma: no branch\n            try:\n                actor_token_type = self.get_token_type(actor_token_type, actor_token)\n            except ValueError:\n                raise TypeError(\n                    \"Cannot determine the kind of 'actor_token' you provided. \"\n                    \"Please specify an 'actor_token_type'.\"\n                )\n\n        data = dict(\n            grant_type=\"urn:ietf:params:oauth:grant-type:token-exchange\",\n            subject_token=subject_token,\n            subject_token_type=subject_token_type,\n            actor_token=actor_token,\n            actor_token_type=actor_token_type,\n            requested_token_type=requested_token_type,\n            **token_kwargs,\n        )\n        return self.token_request(data, **requests_kwargs)\n\n    def jwt_bearer(\n        self,\n        assertion: Union[Jwt, str],\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a request using a JWT as authorization grant.\n\n        This is a defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n        Args:\n            assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server.\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n\n        if not isinstance(assertion, Jwt):\n            assertion = Jwt(assertion)\n\n        data = dict(\n            grant_type=\"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n            assertion=assertion,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def resource_owner_password(\n        self,\n        username: str,\n        password: str,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ) -&gt; BearerToken:\n\"\"\"Send a request using the Resource Owner Password Grant.\n\n        This Grant Type is deprecated and should only be used when there is no other choice.\n\n        Args:\n            username: the resource owner user name\n            password: the resource owner password\n            requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n            **token_kwargs: additional parameters to include in the request body.\n\n        Returns:\n            a `BearerToken` as returned by the Authorization Server\n        \"\"\"\n        requests_kwargs = requests_kwargs or {}\n        data = dict(\n            grant_type=\"password\",\n            username=username,\n            password=password,\n            **token_kwargs,\n        )\n\n        return self.token_request(data, **requests_kwargs)\n\n    def authorization_request(\n        self,\n        scope: Union[None, str, Iterable[str]] = \"openid\",\n        response_type: str = \"code\",\n        redirect_uri: Optional[str] = None,\n        state: Union[str, Literal[True], None] = True,\n        nonce: Union[str, Literal[True], None] = True,\n        code_verifier: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; AuthorizationRequest:\n\"\"\"Generate an Authorization Request for this client.\n\n        Args:\n            scope: the scope to use\n            response_type: the response_type to use\n            redirect_uri: the redirect_uri to include in the request. By default, the redirect_uri defined at init time is used.\n            state: the state parameter to use. Leave default to generate a random value.\n            nonce: a nonce. Leave default to generate a random value.\n            code_verifier: the PKCE code verifier to use. Leave default to generate a random value.\n            **kwargs: additional parameters to include in the auth request\n\n        Returns:\n            an AuthorizationRequest with the supplied parameters\n        \"\"\"\n        authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n        redirect_uri = redirect_uri or self.redirect_uri\n        if not redirect_uri:\n            raise AttributeError(\n                \"No 'redirect_uri' defined for this client. \"\n                \"You must either pass a redirect_uri as parameter to this method, \"\n                \"or include a redirect_uri when initializing your OAuth2Client.\"\n            )\n\n        if response_type != \"code\":\n            raise ValueError(\"Only response_type=code is supported.\")\n\n        return AuthorizationRequest(\n            authorization_endpoint=authorization_endpoint,\n            client_id=self.client_id,\n            redirect_uri=redirect_uri,\n            issuer=self.issuer,\n            response_type=response_type,\n            scope=scope,\n            state=state,\n            nonce=nonce,\n            code_verifier=code_verifier,\n            code_challenge_method=self.code_challenge_method,\n            **kwargs,\n        )\n\n    def pushed_authorization_request(\n        self, authorization_request: AuthorizationRequest\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n\"\"\"Send a Pushed Authorization Request.\n\n        This sends a request to the Pushed Authorization Request Endpoint, and returns a\n        `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n        Args:\n            authorization_request: the authorization request to send\n\n        Returns:\n            the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n        \"\"\"\n        pushed_authorization_request_endpoint = self._require_endpoint(\n            \"pushed_authorization_request_endpoint\"\n        )\n\n        response = self.session.post(\n            pushed_authorization_request_endpoint,\n            data=authorization_request.args,\n            auth=self.auth,\n        )\n        if not response.ok:\n            return self.on_pushed_authorization_request_error(response)\n\n        response_json = response.json()\n        request_uri = response_json.get(\"request_uri\")\n        expires_in = response_json.get(\"expires_in\")\n\n        return RequestUriParameterAuthorizationRequest(\n            authorization_endpoint=authorization_request.authorization_endpoint,\n            client_id=authorization_request.client_id,\n            request_uri=request_uri,\n            expires_in=expires_in,\n        )\n\n    def on_pushed_authorization_request_error(\n        self, response: requests.Response\n    ) -&gt; RequestUriParameterAuthorizationRequest:\n\"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n        Args:\n            response: the HTTP response as returned by the AS PAR endpoint.\n\n        Returns:\n            a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n        Raises:\n            EndpointError: a subclass of this error depending on the error returned by the AS\n            InvalidPushedAuthorizationResponse: if the returned response is not following the specifications\n            UnknownTokenEndpointError: for unknown/unhandled errors\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidPushedAuthorizationResponse(response) from exc\n        raise exception\n\n    def userinfo(self, access_token: Union[BearerToken, str]) -&gt; Any:\n\"\"\"Call the UserInfo endpoint.\n\n        This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.\n\n        Args:\n            access_token: the access token to use\n\n        Returns:\n            the [Response][requests.Response] returned by the userinfo endpoint.\n        \"\"\"\n        userinfo_endpoint = self._require_endpoint(\"userinfo_endpoint\")\n        response = self.session.post(userinfo_endpoint, auth=BearerAuth(access_token))\n        return self.parse_userinfo_response(response)\n\n    def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n\"\"\"Parse the response obtained by `userinfo()`.\n\n        Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the response from the UserInfo endpoint, this will extract and return its JSON\n        content.\n\n        Args:\n            resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n        Returns:\n            the parsed JSON content from this response.\n        \"\"\"\n        return resp.json()\n\n    @classmethod\n    def get_token_type(\n        cls,\n        token_type: Optional[str] = None,\n        token: Union[None, str, BearerToken, IdToken] = None,\n    ) -&gt; str:\n\"\"\"Get standardised token type identifiers.\n\n        Return a standardised token type identifier, based on a short `token_type`\n        hint and/or a token value.\n\n        Args:\n            token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional)\n            token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n        Returns:\n            the token_type as defined in the Token Exchange RFC8693.\n        \"\"\"\n        if not (token_type or token):\n            raise ValueError(\n                \"Cannot determine type of an empty token without a token_type hint\"\n            )\n\n        if token_type is None:\n            if isinstance(token, str):\n                raise ValueError(\n                    \"Cannot determine the type of provided token when it is a bare str. \"\n                    \"Please specify a token_type.\"\n                )\n            elif isinstance(token, BearerToken):\n                return \"urn:ietf:params:oauth:token-type:access_token\"\n            elif isinstance(token, IdToken):\n                return \"urn:ietf:params:oauth:token-type:id_token\"\n            else:\n                raise TypeError(\n                    \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\",\n                    type(token),\n                )\n        elif token_type == \"access_token\":\n            if token is not None and not isinstance(token, (str, BearerToken)):\n                raise TypeError(\n                    \"The supplied token is not a BearerToken or a string representation of it.\",\n                    type(token),\n                )\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        elif token_type == \"refresh_token\":\n            if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n                raise ValueError(\"The supplied BearerToken doesn't have a refresh_token.\")\n            return \"urn:ietf:params:oauth:token-type:refresh_token\"\n        elif token_type == \"id_token\":\n            if token is not None and not isinstance(token, (str, IdToken)):\n                raise TypeError(\n                    \"The supplied token is not an IdToken or a string representation of it.\",\n                    type(token),\n                )\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n        else:\n            return {\n                \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n                \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n                \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n            }.get(token_type, token_type)\n\n    def revoke_access_token(\n        self,\n        access_token: Union[BearerToken, str],\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n\"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n        Args:\n            access_token: the access token to revoke\n            requests_kwargs: additional parameters for the underlying requests.post() call\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint\n        \"\"\"\n        return self.revoke_token(\n            access_token,\n            token_type_hint=\"access_token\",\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_refresh_token(\n        self,\n        refresh_token: Union[str, BearerToken],\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n\"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n        Args:\n            refresh_token: the refresh token to revoke.\n            requests_kwargs: additional parameters to pass to the revocation endpoint.\n            **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation request is successful, `False` if this client has no configured revocation endpoint.\n        \"\"\"\n        if isinstance(refresh_token, BearerToken):\n            if refresh_token.refresh_token is None:\n                raise ValueError(\"The supplied BearerToken doesn't have a refresh token.\")\n            refresh_token = refresh_token.refresh_token\n\n        return self.revoke_token(\n            refresh_token,\n            token_type_hint=\"refresh_token\",\n            requests_kwargs=requests_kwargs,\n            **revoke_kwargs,\n        )\n\n    def revoke_token(\n        self,\n        token: Union[str, BearerToken],\n        token_type_hint: Optional[str] = None,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **revoke_kwargs: Any,\n    ) -&gt; bool:\n\"\"\"Send a Token Revocation request.\n\n        By default, authentication will be the same than the one used for the Token Endpoint.\n\n        Args:\n            token: the token to revoke.\n            token_type_hint: a token_type_hint to send to the revocation endpoint.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n        Returns:\n            `True` if the revocation succeeds,\n            `False` if no revocation endpoint is present or a non-standardised error is returned.\n        \"\"\"\n        if not self.revocation_endpoint:\n            return False\n\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == \"refresh_token\" and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                raise ValueError(\"The supplied BearerToken doesn't have a refresh token.\")\n            token = token.refresh_token\n\n        data = dict(revoke_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        response = self.session.post(\n            self.revocation_endpoint,\n            data=data,\n            auth=self.auth,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return True\n\n        return self.on_revocation_error(response)\n\n    def on_revocation_error(self, response: requests.Response) -&gt; bool:\n\"\"\"Error handler for `revoke_token()`.\n\n        Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the revocation endpoint returns an error.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n        Returns:\n            `False` to signal that an error occurred. May raise exceptions instead depending on the revocation response.\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, RevocationError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception:\n            return False\n        raise exception\n\n    def introspect_token(\n        self,\n        token: Union[str, BearerToken],\n        token_type_hint: Optional[str] = None,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **introspect_kwargs: Any,\n    ) -&gt; Any:\n\"\"\"Send a request to the configured Introspection Endpoint.\n\n        Args:\n            token_type_hint: the token_type_hint to include in the request.\n            requests_kwargs: additional parameters to the underling call to requests.post()\n            **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n        Returns:\n            the response as returned by the Introspection Endpoint.\n        \"\"\"\n        introspection_endpoint = self._require_endpoint(\"introspection_endpoint\")\n\n        requests_kwargs = requests_kwargs or {}\n\n        if token_type_hint == \"refresh_token\" and isinstance(token, BearerToken):\n            if token.refresh_token is None:\n                raise ValueError(\"The supplied BearerToken doesn't have a refresh token.\")\n            token = token.refresh_token\n\n        data = dict(introspect_kwargs, token=str(token))\n        if token_type_hint:\n            data[\"token_type_hint\"] = token_type_hint\n\n        response = self.session.post(\n            introspection_endpoint,\n            data=data,\n            auth=self.auth,\n            **requests_kwargs,\n        )\n        if response.ok:\n            return self.parse_introspection_response(response)\n\n        return self.on_introspection_error(response)\n\n    def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n\"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response.\n        This decodes the JSON content if possible, otherwise it returns the response as a string.\n\n        Args:\n            response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n        Returns:\n            the decoded JSON content, or a `str` with the content.\n        \"\"\"\n        try:\n            return response.json()\n        except ValueError:\n            return response.text\n\n    def on_introspection_error(self, response: requests.Response) -&gt; Any:\n\"\"\"Error handler for `introspect_token()`.\n\n        Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response in the case an error is returned.\n\n        Args:\n            response: the response as returned by the Introspection Endpoint.\n\n        Returns:\n            usually raises exeptions. A subclass can return a default response instead.\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, IntrospectionError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception as exc:\n            raise UnknownIntrospectionError(response) from exc\n        raise exception\n\n    def backchannel_authentication_request(\n        self,\n        scope: Union[None, str, Iterable[str]] = \"openid\",\n        client_notification_token: Optional[str] = None,\n        acr_values: Union[None, str, Iterable[str]] = None,\n        login_hint_token: Optional[str] = None,\n        id_token_hint: Optional[str] = None,\n        login_hint: Optional[str] = None,\n        binding_message: Optional[str] = None,\n        user_code: Optional[str] = None,\n        requested_expiry: Optional[int] = None,\n        private_jwk: Union[Jwk, Dict[str, Any], None] = None,\n        alg: Optional[str] = None,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **ciba_kwargs: Any,\n    ) -&gt; BackChannelAuthenticationResponse:\n\"\"\"Send a CIBA Authentication Request.\n\n        Args:\n             scope: the scope to include in the request.\n             client_notification_token: the Client Notification Token to include in the request.\n             acr_values: the acr values to include in the request.\n             login_hint_token: the Login Hint Token to include in the request.\n             id_token_hint: the ID Token Hint to include in the request.\n             login_hint: the Login Hint to include in the request.\n             binding_message: the Binding Message to include in the request.\n             user_code: the User Code to include in the request\n             requested_expiry: the Requested Expiry, in seconds, to include in the request.\n             private_jwk: the JWK to use to sign the request (optional)\n             alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n             requests_kwargs: additional parameters for\n             **ciba_kwargs: additional parameters to include in the request.\n\n        Returns:\n            a BackChannelAuthenticationResponse as returned by AS\n        \"\"\"\n        backchannel_authentication_endpoint = self._require_endpoint(\n            \"backchannel_authentication_endpoint\"\n        )\n\n        if not (login_hint or login_hint_token or id_token_hint):\n            raise ValueError(\n                \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            )\n\n        if (\n            (login_hint_token and id_token_hint)\n            or (login_hint and id_token_hint)\n            or (login_hint_token and login_hint)\n        ):\n            raise ValueError(\n                \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n            )\n\n        requests_kwargs = requests_kwargs or {}\n\n        if scope is not None and not isinstance(scope, str):\n            try:\n                scope = \" \".join(scope)\n            except Exception as exc:\n                raise ValueError(\"Unsupported `scope` value\") from exc\n\n        if acr_values is not None and not isinstance(acr_values, str):\n            try:\n                acr_values = \" \".join(acr_values)\n            except Exception as exc:\n                raise ValueError(\"Unsupported `acr_values`\") from exc\n\n        data = dict(\n            ciba_kwargs,\n            scope=scope,\n            client_notification_token=client_notification_token,\n            acr_values=acr_values,\n            login_hint_token=login_hint_token,\n            id_token_hint=id_token_hint,\n            login_hint=login_hint,\n            binding_message=binding_message,\n            user_code=user_code,\n            requested_expiry=requested_expiry,\n        )\n\n        if private_jwk is not None:\n            data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n        response = self.session.post(\n            backchannel_authentication_endpoint,\n            data=data,\n            auth=self.auth,\n            **requests_kwargs,\n        )\n\n        if response.ok:\n            return self.parse_backchannel_authentication_response(response)\n\n        return self.on_backchannel_authentication_error(response)\n\n    def parse_backchannel_authentication_response(\n        self, response: requests.Response\n    ) -&gt; BackChannelAuthenticationResponse:\n\"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n        Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response\n        returned by the BackChannel Authentication Endpoint.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            a `BackChannelAuthenticationResponse`\n        \"\"\"\n        try:\n            return BackChannelAuthenticationResponse(**response.json())\n        except TypeError as exc:\n            raise InvalidBackChannelAuthenticationResponse(response) from exc\n\n    def on_backchannel_authentication_error(\n        self, response: requests.Response\n    ) -&gt; BackChannelAuthenticationResponse:\n\"\"\"Error handler for `backchannel_authentication_request()`.\n\n        Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response\n        returned by the BackChannel Authentication Endpoint, when it is an error.\n\n        Args:\n            response: the response returned by the BackChannel Authentication Endpoint.\n\n        Returns:\n            usually raises an exception. But a subclass can return a default response instead.\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n            exception = exception_class(error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidBackChannelAuthenticationResponse(response) from exc\n        raise exception\n\n    def authorize_device(self, **data: Any) -&gt; DeviceAuthorizationResponse:\n\"\"\"Send a Device Authorization Request.\n\n        Args:\n            **data: additional data to send to the Device Authorization Endpoint\n\n        Returns:\n            a Device Authorization Response\n        \"\"\"\n        device_authorization_endpoint = self._require_endpoint(\"device_authorization_endpoint\")\n\n        response = self.session.post(device_authorization_endpoint, data=data, auth=self.auth)\n\n        if response.ok:\n            return self.parse_device_authorization_response(response)\n\n        return self.on_device_authorization_error(response)\n\n    def parse_device_authorization_response(\n        self, response: requests.Response\n    ) -&gt; DeviceAuthorizationResponse:\n\"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            a `DeviceAuthorizationResponse` as returned by AS\n        \"\"\"\n        device_authorization_response = DeviceAuthorizationResponse(**response.json())\n        return device_authorization_response\n\n    def on_device_authorization_error(\n        self, response: requests.Response\n    ) -&gt; DeviceAuthorizationResponse:\n\"\"\"Error handler for `authorize_device()`.\n\n        Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint, when that response is an error.\n\n        Args:\n            response: the response returned by the Device Authorization Endpoint.\n\n        Returns:\n            usually raises an Exception. But a subclass may return a default response instead.\n        \"\"\"\n        try:\n            data = response.json()\n            error = data[\"error\"]\n            error_description = data.get(\"error_description\")\n            error_uri = data.get(\"error_uri\")\n            exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n            exception = exception_class(response, error, error_description, error_uri)\n        except Exception as exc:\n            raise InvalidDeviceAuthorizationResponse(response) from exc\n        raise exception\n\n    def update_authorization_server_public_keys(self) -&gt; JwkSet:\n\"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n        Public keys are returned by this method, as a [JwkSet][jwskate.JwkSet].\n        They are also available in attribute `authorization_server_jwks`.\n\n        Returns:\n            the retrieved public keys\n\n        Raises:\n            ValueError: if no jwks_uri is configured\n        \"\"\"\n        jwks_uri = self._require_endpoint(\"jwks_uri\")\n\n        jwks = self.session.get(jwks_uri, auth=None).json()\n        self.authorization_server_jwks = JwkSet(jwks)\n        return self.authorization_server_jwks\n\n    @classmethod\n    def from_discovery_endpoint(\n        cls,\n        url: Optional[str] = None,\n        issuer: Optional[str] = None,\n        auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[str] = None,\n        private_key: Union[Jwk, Dict[str, Any], None] = None,\n        session: Optional[requests.Session] = None,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n\"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n        This will retrieve the standardised metadata document available at `url`, and will extract all Endpoint Uris\n        from that document, will fetch the current public keys from its `jwks_uri`, then will initialize an OAuth2Client\n        based on those endpoints.\n\n        Args:\n             url: the url where the server metadata will be retrieved\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             session: a requests Session to use to retrieve the document and initialise the client with\n             issuer: if an issuer is given, check that it matches the one from the retrieved document\n\n        Returns:\n            an OAuth2Client with endpoint initialized based on the obtained metadata\n\n        Raises:\n            ValueError: if neither `url` or `issuer` are suitable urls.\n            requests.HTTPError: if an error happens while fetching the documents\n        \"\"\"\n        if url is None and issuer is not None:\n            url = oidc_discovery_document_url(issuer)\n        if url is None:\n            raise ValueError(\"Please specify at least one of `issuer` or `url`\")\n\n        validate_endpoint_uri(url, path=False)\n\n        session = session or requests.Session()\n        discovery = session.get(url).json()\n\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri:\n            jwks = JwkSet(session.get(jwks_uri).json())\n\n        return cls.from_discovery_document(\n            discovery,\n            issuer=issuer,\n            auth=auth,\n            session=session,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            authorization_server_jwks=jwks,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_discovery_document(\n        cls,\n        discovery: Dict[str, Any],\n        issuer: Optional[str] = None,\n        auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[str] = None,\n        private_key: Union[Jwk, Dict[str, Any], None] = None,\n        authorization_server_jwks: Union[JwkSet, Dict[str, Any], None] = None,\n        session: Optional[requests.Session] = None,\n        https: bool = True,\n        **kwargs: Any,\n    ) -&gt; OAuth2Client:\n\"\"\"Initialise an OAuth2Client, based on the server metadata from `discovery`.\n\n        Args:\n             discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n             issuer: if an issuer is given, check that it matches the one mentioned in the document\n             auth: the authentication handler to use for client authentication\n             client_id: client ID\n             client_secret: client secret to use to authenticate the client\n             private_key: private key to sign client assertions\n             authorization_server_jwks: the current authorization server JWKS keys\n             session: a requests Session to use to retrieve the document and initialise the client with\n             https: if True, validates that urls in the discovery document use the https scheme\n\n        Returns:\n            an OAuth2Client\n        \"\"\"\n        if issuer and discovery.get(\"issuer\") != issuer:\n            raise ValueError(\n                \"Mismatching issuer value in discovery document: \",\n                issuer,\n                discovery.get(\"issuer\"),\n            )\n        elif issuer is None:\n            issuer = discovery.get(\"issuer\")\n\n        token_endpoint = discovery.get(\"token_endpoint\")\n        if token_endpoint is None:\n            raise ValueError(\"token_endpoint not found in that discovery document\")\n        validate_endpoint_uri(token_endpoint, https=https)\n        authorization_endpoint = discovery.get(\"authorization_endpoint\")\n        if authorization_endpoint is not None:\n            validate_endpoint_uri(authorization_endpoint, https=https)\n        validate_endpoint_uri(token_endpoint, https=https)\n        revocation_endpoint = discovery.get(\"revocation_endpoint\")\n        if revocation_endpoint is not None:\n            validate_endpoint_uri(revocation_endpoint, https=https)\n        introspection_endpoint = discovery.get(\"introspection_endpoint\")\n        if introspection_endpoint is not None:\n            validate_endpoint_uri(introspection_endpoint, https=https)\n        userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n        if userinfo_endpoint is not None:\n            validate_endpoint_uri(userinfo_endpoint, https=https)\n        jwks_uri = discovery.get(\"jwks_uri\")\n        if jwks_uri is not None:\n            validate_endpoint_uri(userinfo_endpoint, https=https)\n        authorization_response_iss_parameter_supported = discovery.get(\n            \"authorization_response_iss_parameter_supported\", False\n        )\n\n        return cls(\n            token_endpoint=token_endpoint,\n            authorization_endpoint=authorization_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            introspection_endpoint=introspection_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            authorization_server_jwks=authorization_server_jwks,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            private_key=private_key,\n            session=session,\n            issuer=issuer,\n            authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n            **kwargs,\n        )\n\n    def __enter__(self) -&gt; OAuth2Client:\n\"\"\"Allow using OAuth2Client as a context-manager.\n\n        The Authorization Server public keys are retrieved on __enter__.\n        \"\"\"\n        self.update_authorization_server_public_keys()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; bool:  # noqa: D105\n        return True\n\n    def _require_endpoint(self, endpoint: str) -&gt; str:\n\"\"\"Check that a required endpoint url is set.\"\"\"\n        url = getattr(self, endpoint, None)\n        if not url:\n            raise AttributeError(\n                f\"No '{endpoint}' defined for this client. \"\n                f\"Please provide the URL for that endpoint when initializing your {self.__class__.__name__} instance.\"\n            )\n\n        return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_id","title":"<code>client_id: str</code>  <code>property</code>","text":"<p>Client ID.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_secret","title":"<code>client_secret: Optional[str]</code>  <code>property</code>","text":"<p>Client Secret.</p>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_jwks","title":"<code>client_jwks: JwkSet</code>  <code>property</code>","text":"<p>A <code>JwkSet</code> containing the public keys for this client.</p> <p>Keys are:</p> <ul> <li>the public key for client assertion signature verification (if using private_key_jwt)</li> <li>the ID Token encryption key</li> </ul>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_request","title":"<code>token_request(data, timeout=10, **requests_kwargs)</code>","text":"<p>Send a request to the token endpoint.</p> <p>Authentication will be added automatically based on the defined <code>auth</code> for this client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request.</p> required <code>timeout</code> <code>int</code> <p>a timeout value for the call</p> <code>10</code> <code>**requests_kwargs</code> <code>Any</code> <p>additional parameters for requests.post()</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>the token endpoint response, as <code>BearerToken</code> instance.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_request(\n    self, data: Dict[str, Any], timeout: int = 10, **requests_kwargs: Any\n) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint.\n\n    Authentication will be added automatically based on the defined `auth` for this client.\n\n    Args:\n         data: parameters to send to the token endpoint. Items with a None or empty value will not be sent in the request.\n         timeout: a timeout value for the call\n         **requests_kwargs: additional parameters for requests.post()\n\n    Returns:\n        the token endpoint response, as [`BearerToken`][requests_oauth2client.tokens.BearerToken] instance.\n    \"\"\"\n    token_endpoint = self._require_endpoint(\"token_endpoint\")\n\n    requests_kwargs = {\n        key: value\n        for key, value in requests_kwargs.items()\n        if value is not None and value != \"\"\n    }\n\n    response = self.session.post(\n        token_endpoint,\n        auth=self.auth,\n        data=data,\n        timeout=timeout,\n        **requests_kwargs,\n    )\n    if response.ok:\n        return self.parse_token_response(response)\n\n    return self.on_token_error(response)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_token_response","title":"<code>parse_token_response(response)</code>","text":"<p>Parse a Response returned by the Token Endpoint.</p> <p>Invoked by token_request to parse responses returned by the Token Endpoint. Those response contain an <code>access_token</code> and additional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> based on the response contents.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_token_response(self, response: requests.Response) -&gt; BearerToken:\n\"\"\"Parse a Response returned by the Token Endpoint.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] to parse responses returned by the Token Endpoint.\n    Those response contain an `access_token` and additional attributes.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        a [`BearerToken`][requests_oauth2client.tokens.BearerToken] based on the response contents.\n    \"\"\"\n    try:\n        token_response = self.token_class(**response.json())\n        return token_response\n    except Exception as response_class_exc:\n        try:\n            return self.on_token_error(response)\n        except Exception as token_error_exc:\n            raise token_error_exc from response_class_exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_token_error","title":"<code>on_token_error(response)</code>","text":"<p>Error handler for <code>token_request()</code>.</p> <p>Invoked by token_request when the Token Endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the Response returned by the Token Endpoint.</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>nothing, and raises an exception instead. But a subclass may return a <code>BearerToken</code> to implement a default behaviour if needed.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_token_error(self, response: requests.Response) -&gt; BearerToken:\n\"\"\"Error handler for `token_request()`.\n\n    Invoked by [token_request][requests_oauth2client.client.OAuth2Client.token_request] when the Token Endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] returned by the Token Endpoint.\n\n    Returns:\n        nothing, and raises an exception instead. But a subclass may return a [`BearerToken`][requests_oauth2client.tokens.BearerToken] to implement a default behaviour if needed.\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidTokenResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.client_credentials","title":"<code>client_credentials(scope=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the <code>client_credentials</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Optional[Union[str, Iterable[str]]]</code> <p>the scope to send with the request. Can be a str, or an iterable of str. to pass that way include <code>scope</code>, <code>audience</code>, <code>resource</code>, etc.</p> <code>None</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>. Common parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a TokenResponse</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def client_credentials(\n    self,\n    scope: Optional[Union[str, Iterable[str]]] = None,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint using the `client_credentials` grant.\n\n    Args:\n        scope: the scope to send with the request. Can be a str, or an iterable of str.\n            to pass that way include `scope`, `audience`, `resource`, etc.\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`. Common parameters\n\n    Returns:\n        a TokenResponse\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise ValueError(\"Unsupported scope value\") from exc\n\n    data = dict(grant_type=\"client_credentials\", scope=scope, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_code","title":"<code>authorization_code(code, validate=True, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>authorization_code</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Union[str, AuthorizationResponse]</code> <p>an authorization code or an <code>AuthorizationResponse</code> to exchange for tokens</p> required <code>validate</code> <code>bool</code> <p>if <code>True</code>, validate the received ID Token (this works only if <code>code</code> is an AuthorizationResponse)</p> <code>True</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_code(\n    self,\n    code: Union[str, AuthorizationResponse],\n    validate: bool = True,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint with the `authorization_code` grant.\n\n    Args:\n         code: an authorization code or an `AuthorizationResponse` to exchange for tokens\n         validate: if `True`, validate the received ID Token (this works only if `code` is an AuthorizationResponse)\n         requests_kwargs: additional parameters for the call to requests\n         **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `code`, etc.\n\n    Returns:\n        a `BearerToken`\n    \"\"\"\n    azr: Optional[AuthorizationResponse] = None\n    if isinstance(code, AuthorizationResponse):\n        token_kwargs.setdefault(\"code_verifier\", code.code_verifier)\n        token_kwargs.setdefault(\"redirect_uri\", code.redirect_uri)\n        azr = code\n        code = code.code\n\n    requests_kwargs = requests_kwargs or {}\n\n    data = dict(grant_type=\"authorization_code\", code=code, **token_kwargs)\n    token = self.token_request(data, **requests_kwargs)\n    if validate and token.id_token and isinstance(azr, AuthorizationResponse):\n        token.validate_id_token(self, azr)\n    return token\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.refresh_token","title":"<code>refresh_token(refresh_token, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint with the <code>refresh_token</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>Union[str, BearerToken]</code> <p>a refresh_token, as a string, or as a <code>BearerToken</code>. That <code>BearerToken</code> must have a <code>refresh_token</code>.</p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the call to <code>requests</code></p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>refresh_token</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def refresh_token(\n    self,\n    refresh_token: Union[str, BearerToken],\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint with the `refresh_token` grant.\n\n    Args:\n        refresh_token: a refresh_token, as a string, or as a `BearerToken`. That `BearerToken` must have a `refresh_token`.\n        requests_kwargs: additional parameters for the call to `requests`\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `refresh_token`, etc.\n\n    Returns:\n        a `BearerToken`\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None or not isinstance(\n            refresh_token.refresh_token, str\n        ):\n            raise ValueError(\"This BearerToken doesn't have a refresh_token\")\n        refresh_token = refresh_token.refresh_token\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(grant_type=\"refresh_token\", refresh_token=refresh_token, **token_kwargs)\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.device_code","title":"<code>device_code(device_code, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request to the token endpoint using the Device Code grant.</p> <p>The grant_type is <code>urn:ietf:params:oauth:grant-type:device_code</code>. This needs a Device Code, or a <code>DeviceAuthorizationResponse</code> as parameter.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>Union[str, DeviceAuthorizationResponse]</code> <p>a device code, or a <code>DeviceAuthorizationResponse</code></p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>device_code</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def device_code(\n    self,\n    device_code: Union[str, DeviceAuthorizationResponse],\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a request to the token endpoint using the Device Code grant.\n\n    The grant_type is `urn:ietf:params:oauth:grant-type:device_code`.\n    This needs a Device Code, or a `DeviceAuthorizationResponse` as parameter.\n\n    Args:\n        device_code: a device code, or a `DeviceAuthorizationResponse`\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `device_code`, etc.\n\n    Returns:\n        a `BearerToken`\n    \"\"\"\n    if isinstance(device_code, DeviceAuthorizationResponse):\n        if device_code.device_code is None or not isinstance(device_code.device_code, str):\n            raise ValueError(\"This DeviceAuthorizationResponse doesn't have a device_code\")\n        device_code = device_code.device_code\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=\"urn:ietf:params:oauth:grant-type:device_code\",\n        device_code=device_code,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.ciba","title":"<code>ciba(auth_req_id, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a CIBA request to the Token Endpoint.</p> <p>A CIBA request is a Token Request using the <code>urn:openid:params:grant-type:ciba</code> grant.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>Union[str, BackChannelAuthenticationResponse]</code> <p>an authentication request ID, as returned by the AS</p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the call to requests</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token endpoint, alongside <code>grant_type</code>, <code>auth_req_id</code>, etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def ciba(\n    self,\n    auth_req_id: Union[str, BackChannelAuthenticationResponse],\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a CIBA request to the Token Endpoint.\n\n    A CIBA request is a Token Request using the `urn:openid:params:grant-type:ciba` grant.\n\n    Args:\n        auth_req_id: an authentication request ID, as returned by the AS\n        requests_kwargs: additional parameters for the call to requests\n        **token_kwargs: additional parameters for the token endpoint, alongside `grant_type`, `auth_req_id`, etc.\n\n    Returns:\n        a `BearerToken`\n    \"\"\"\n    if isinstance(auth_req_id, BackChannelAuthenticationResponse):\n        if auth_req_id.auth_req_id is None or not isinstance(auth_req_id.auth_req_id, str):\n            raise ValueError(\n                \"This BackChannelAuthenticationResponse doesn't have an auth_req_id\"\n            )\n        auth_req_id = auth_req_id.auth_req_id\n\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=\"urn:openid:params:grant-type:ciba\",\n        auth_req_id=auth_req_id,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.token_exchange","title":"<code>token_exchange(subject_token, subject_token_type=None, actor_token=None, actor_token_type=None, requested_token_type=None, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a Token Exchange request.</p> <p>A Token Exchange request is actually a request to the Token Endpoint with a grant_type <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subject_token</code> <code>Union[str, BearerToken, IdToken]</code> <p>the subject token to exchange for a new token.</p> required <code>subject_token_type</code> <code>Optional[str]</code> <p>a token type identifier for the subject_token, mandatory if it cannot be guessed based on <code>type(subject_token)</code>.</p> <code>None</code> <code>actor_token</code> <code>Union[None, str, BearerToken, IdToken]</code> <p>the actor token to include in the request, if any.</p> <code>None</code> <code>actor_token_type</code> <code>Optional[str]</code> <p>a token type identifier for the actor_token, mandatory if it cannot be guessed based on <code>type(actor_token)</code>.</p> <code>None</code> <code>requested_token_type</code> <code>Optional[str]</code> <p>a token type identifier for the requested token.</p> <code>None</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def token_exchange(\n    self,\n    subject_token: Union[str, BearerToken, IdToken],\n    subject_token_type: Optional[str] = None,\n    actor_token: Union[None, str, BearerToken, IdToken] = None,\n    actor_token_type: Optional[str] = None,\n    requested_token_type: Optional[str] = None,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a Token Exchange request.\n\n    A Token Exchange request is actually a request to the Token Endpoint with a grant_type `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n    Args:\n        subject_token: the subject token to exchange for a new token.\n        subject_token_type: a token type identifier for the subject_token, mandatory if it cannot be guessed based\n            on `type(subject_token)`.\n        actor_token: the actor token to include in the request, if any.\n        actor_token_type: a token type identifier for the actor_token, mandatory if it cannot be guessed based\n            on `type(actor_token)`.\n        requested_token_type: a token type identifier for the requested token.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    try:\n        subject_token_type = self.get_token_type(subject_token_type, subject_token)\n    except ValueError:\n        raise TypeError(\n            \"Cannot determine the kind of 'subject_token' you provided. \"\n            \"Please specify a 'subject_token_type'.\"\n        )\n    if actor_token:  # pragma: no branch\n        try:\n            actor_token_type = self.get_token_type(actor_token_type, actor_token)\n        except ValueError:\n            raise TypeError(\n                \"Cannot determine the kind of 'actor_token' you provided. \"\n                \"Please specify an 'actor_token_type'.\"\n            )\n\n    data = dict(\n        grant_type=\"urn:ietf:params:oauth:grant-type:token-exchange\",\n        subject_token=subject_token,\n        subject_token_type=subject_token_type,\n        actor_token=actor_token,\n        actor_token_type=actor_token_type,\n        requested_token_type=requested_token_type,\n        **token_kwargs,\n    )\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.jwt_bearer","title":"<code>jwt_bearer(assertion, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using a JWT as authorization grant.</p> <p>This is a defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).</p> <p>Parameters:</p> Name Type Description Default <code>assertion</code> <code>Union[Jwt, str]</code> <p>a JWT (as an instance of <code>jwskate.Jwt</code> or as a <code>str</code>) to use as authorization grant.</p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def jwt_bearer(\n    self,\n    assertion: Union[Jwt, str],\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a request using a JWT as authorization grant.\n\n    This is a defined in (RFC7523 $2.1)[https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1).\n\n    Args:\n        assertion: a JWT (as an instance of `jwskate.Jwt` or as a `str`) to use as authorization grant.\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server.\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n\n    if not isinstance(assertion, Jwt):\n        assertion = Jwt(assertion)\n\n    data = dict(\n        grant_type=\"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n        assertion=assertion,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.resource_owner_password","title":"<code>resource_owner_password(username, password, requests_kwargs=None, **token_kwargs)</code>","text":"<p>Send a request using the Resource Owner Password Grant.</p> <p>This Grant Type is deprecated and should only be used when there is no other choice.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the resource owner user name</p> required <code>password</code> <code>str</code> <p>the resource owner password</p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters to pass to the underlying <code>requests.post()</code> call.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters to include in the request body.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a <code>BearerToken</code> as returned by the Authorization Server</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def resource_owner_password(\n    self,\n    username: str,\n    password: str,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **token_kwargs: Any,\n) -&gt; BearerToken:\n\"\"\"Send a request using the Resource Owner Password Grant.\n\n    This Grant Type is deprecated and should only be used when there is no other choice.\n\n    Args:\n        username: the resource owner user name\n        password: the resource owner password\n        requests_kwargs: additional parameters to pass to the underlying `requests.post()` call.\n        **token_kwargs: additional parameters to include in the request body.\n\n    Returns:\n        a `BearerToken` as returned by the Authorization Server\n    \"\"\"\n    requests_kwargs = requests_kwargs or {}\n    data = dict(\n        grant_type=\"password\",\n        username=username,\n        password=password,\n        **token_kwargs,\n    )\n\n    return self.token_request(data, **requests_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorization_request","title":"<code>authorization_request(scope='openid', response_type='code', redirect_uri=None, state=True, nonce=True, code_verifier=None, **kwargs)</code>","text":"<p>Generate an Authorization Request for this client.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Union[None, str, Iterable[str]]</code> <p>the scope to use</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response_type to use</p> <code>'code'</code> <code>redirect_uri</code> <code>Optional[str]</code> <p>the redirect_uri to include in the request. By default, the redirect_uri defined at init time is used.</p> <code>None</code> <code>state</code> <code>Union[str, Literal[True], None]</code> <p>the state parameter to use. Leave default to generate a random value.</p> <code>True</code> <code>nonce</code> <code>Union[str, Literal[True], None]</code> <p>a nonce. Leave default to generate a random value.</p> <code>True</code> <code>code_verifier</code> <code>Optional[str]</code> <p>the PKCE code verifier to use. Leave default to generate a random value.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters to include in the auth request</p> <code>{}</code> <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest with the supplied parameters</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorization_request(\n    self,\n    scope: Union[None, str, Iterable[str]] = \"openid\",\n    response_type: str = \"code\",\n    redirect_uri: Optional[str] = None,\n    state: Union[str, Literal[True], None] = True,\n    nonce: Union[str, Literal[True], None] = True,\n    code_verifier: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; AuthorizationRequest:\n\"\"\"Generate an Authorization Request for this client.\n\n    Args:\n        scope: the scope to use\n        response_type: the response_type to use\n        redirect_uri: the redirect_uri to include in the request. By default, the redirect_uri defined at init time is used.\n        state: the state parameter to use. Leave default to generate a random value.\n        nonce: a nonce. Leave default to generate a random value.\n        code_verifier: the PKCE code verifier to use. Leave default to generate a random value.\n        **kwargs: additional parameters to include in the auth request\n\n    Returns:\n        an AuthorizationRequest with the supplied parameters\n    \"\"\"\n    authorization_endpoint = self._require_endpoint(\"authorization_endpoint\")\n\n    redirect_uri = redirect_uri or self.redirect_uri\n    if not redirect_uri:\n        raise AttributeError(\n            \"No 'redirect_uri' defined for this client. \"\n            \"You must either pass a redirect_uri as parameter to this method, \"\n            \"or include a redirect_uri when initializing your OAuth2Client.\"\n        )\n\n    if response_type != \"code\":\n        raise ValueError(\"Only response_type=code is supported.\")\n\n    return AuthorizationRequest(\n        authorization_endpoint=authorization_endpoint,\n        client_id=self.client_id,\n        redirect_uri=redirect_uri,\n        issuer=self.issuer,\n        response_type=response_type,\n        scope=scope,\n        state=state,\n        nonce=nonce,\n        code_verifier=code_verifier,\n        code_challenge_method=self.code_challenge_method,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.pushed_authorization_request","title":"<code>pushed_authorization_request(authorization_request)</code>","text":"<p>Send a Pushed Authorization Request.</p> <p>This sends a request to the Pushed Authorization Request Endpoint, and returns a <code>RequestUriParameterAuthorizationRequest</code> initialized with the AS response.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_request</code> <code>AuthorizationRequest</code> <p>the authorization request to send</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>the <code>RequestUriParameterAuthorizationRequest</code> initialized based on the AS response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def pushed_authorization_request(\n    self, authorization_request: AuthorizationRequest\n) -&gt; RequestUriParameterAuthorizationRequest:\n\"\"\"Send a Pushed Authorization Request.\n\n    This sends a request to the Pushed Authorization Request Endpoint, and returns a\n    `RequestUriParameterAuthorizationRequest` initialized with the AS response.\n\n    Args:\n        authorization_request: the authorization request to send\n\n    Returns:\n        the `RequestUriParameterAuthorizationRequest` initialized based on the AS response\n    \"\"\"\n    pushed_authorization_request_endpoint = self._require_endpoint(\n        \"pushed_authorization_request_endpoint\"\n    )\n\n    response = self.session.post(\n        pushed_authorization_request_endpoint,\n        data=authorization_request.args,\n        auth=self.auth,\n    )\n    if not response.ok:\n        return self.on_pushed_authorization_request_error(response)\n\n    response_json = response.json()\n    request_uri = response_json.get(\"request_uri\")\n    expires_in = response_json.get(\"expires_in\")\n\n    return RequestUriParameterAuthorizationRequest(\n        authorization_endpoint=authorization_request.authorization_endpoint,\n        client_id=authorization_request.client_id,\n        request_uri=request_uri,\n        expires_in=expires_in,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_pushed_authorization_request_error","title":"<code>on_pushed_authorization_request_error(response)</code>","text":"<p>Error Handler for Pushed Authorization Endpoint errors.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the HTTP response as returned by the AS PAR endpoint.</p> required <p>Returns:</p> Type Description <code>RequestUriParameterAuthorizationRequest</code> <p>a RequestUriParameterAuthorizationRequest, if the error is recoverable</p> <p>Raises:</p> Type Description <code>EndpointError</code> <p>a subclass of this error depending on the error returned by the AS</p> <code>InvalidPushedAuthorizationResponse</code> <p>if the returned response is not following the specifications</p> <code>UnknownTokenEndpointError</code> <p>for unknown/unhandled errors</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_pushed_authorization_request_error(\n    self, response: requests.Response\n) -&gt; RequestUriParameterAuthorizationRequest:\n\"\"\"Error Handler for Pushed Authorization Endpoint errors.\n\n    Args:\n        response: the HTTP response as returned by the AS PAR endpoint.\n\n    Returns:\n        a RequestUriParameterAuthorizationRequest, if the error is recoverable\n\n    Raises:\n        EndpointError: a subclass of this error depending on the error returned by the AS\n        InvalidPushedAuthorizationResponse: if the returned response is not following the specifications\n        UnknownTokenEndpointError: for unknown/unhandled errors\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, UnknownTokenEndpointError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidPushedAuthorizationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.userinfo","title":"<code>userinfo(access_token)</code>","text":"<p>Call the UserInfo endpoint.</p> <p>This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>Union[BearerToken, str]</code> <p>the access token to use</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the Response returned by the userinfo endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def userinfo(self, access_token: Union[BearerToken, str]) -&gt; Any:\n\"\"\"Call the UserInfo endpoint.\n\n    This sends a request to the UserInfo endpoint, with the specified access_token, and returns the parsed result.\n\n    Args:\n        access_token: the access token to use\n\n    Returns:\n        the [Response][requests.Response] returned by the userinfo endpoint.\n    \"\"\"\n    userinfo_endpoint = self._require_endpoint(\"userinfo_endpoint\")\n    response = self.session.post(userinfo_endpoint, auth=BearerAuth(access_token))\n    return self.parse_userinfo_response(response)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_userinfo_response","title":"<code>parse_userinfo_response(resp)</code>","text":"<p>Parse the response obtained by <code>userinfo()</code>.</p> <p>Invoked by userinfo() to parse the response from the UserInfo endpoint, this will extract and return its JSON content.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>requests.Response</code> <p>a Response returned from the UserInfo endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the parsed JSON content from this response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_userinfo_response(self, resp: requests.Response) -&gt; Any:\n\"\"\"Parse the response obtained by `userinfo()`.\n\n    Invoked by [userinfo()][requests_oauth2client.client.OAuth2Client.userinfo] to parse the response from the UserInfo endpoint, this will extract and return its JSON\n    content.\n\n    Args:\n        resp: a [Response][requests.Response] returned from the UserInfo endpoint.\n\n    Returns:\n        the parsed JSON content from this response.\n    \"\"\"\n    return resp.json()\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.get_token_type","title":"<code>get_token_type(token_type=None, token=None)</code>  <code>classmethod</code>","text":"<p>Get standardised token type identifiers.</p> <p>Return a standardised token type identifier, based on a short <code>token_type</code> hint and/or a token value.</p> <p>Parameters:</p> Name Type Description Default <code>token_type</code> <code>Optional[str]</code> <p>a token_type hint, as <code>str</code>. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional)</p> <code>None</code> <code>token</code> <code>Union[None, str, BearerToken, IdToken]</code> <p>a token value, as an instance of <code>BearerToken</code> or IdToken, or as a <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the token_type as defined in the Token Exchange RFC8693.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef get_token_type(\n    cls,\n    token_type: Optional[str] = None,\n    token: Union[None, str, BearerToken, IdToken] = None,\n) -&gt; str:\n\"\"\"Get standardised token type identifiers.\n\n    Return a standardised token type identifier, based on a short `token_type`\n    hint and/or a token value.\n\n    Args:\n        token_type: a token_type hint, as `str`. May be \"access_token\", \"refresh_token\" or \"id_token\" (optional)\n        token: a token value, as an instance of `BearerToken` or IdToken, or as a `str`.\n\n    Returns:\n        the token_type as defined in the Token Exchange RFC8693.\n    \"\"\"\n    if not (token_type or token):\n        raise ValueError(\n            \"Cannot determine type of an empty token without a token_type hint\"\n        )\n\n    if token_type is None:\n        if isinstance(token, str):\n            raise ValueError(\n                \"Cannot determine the type of provided token when it is a bare str. \"\n                \"Please specify a token_type.\"\n            )\n        elif isinstance(token, BearerToken):\n            return \"urn:ietf:params:oauth:token-type:access_token\"\n        elif isinstance(token, IdToken):\n            return \"urn:ietf:params:oauth:token-type:id_token\"\n        else:\n            raise TypeError(\n                \"Unexpected type of token, please provide a string or a BearerToken or an IdToken.\",\n                type(token),\n            )\n    elif token_type == \"access_token\":\n        if token is not None and not isinstance(token, (str, BearerToken)):\n            raise TypeError(\n                \"The supplied token is not a BearerToken or a string representation of it.\",\n                type(token),\n            )\n        return \"urn:ietf:params:oauth:token-type:access_token\"\n    elif token_type == \"refresh_token\":\n        if token is not None and isinstance(token, BearerToken) and not token.refresh_token:\n            raise ValueError(\"The supplied BearerToken doesn't have a refresh_token.\")\n        return \"urn:ietf:params:oauth:token-type:refresh_token\"\n    elif token_type == \"id_token\":\n        if token is not None and not isinstance(token, (str, IdToken)):\n            raise TypeError(\n                \"The supplied token is not an IdToken or a string representation of it.\",\n                type(token),\n            )\n        return \"urn:ietf:params:oauth:token-type:id_token\"\n    else:\n        return {\n            \"saml1\": \"urn:ietf:params:oauth:token-type:saml1\",\n            \"saml2\": \"urn:ietf:params:oauth:token-type:saml2\",\n            \"jwt\": \"urn:ietf:params:oauth:token-type:jwt\",\n        }.get(token_type, token_type)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_access_token","title":"<code>revoke_access_token(access_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke an access token.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>Union[BearerToken, str]</code> <p>the access token to revoke</p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the underlying requests.post() call</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint</p> <code>{}</code> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_access_token(\n    self,\n    access_token: Union[BearerToken, str],\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n\"\"\"Send a request to the Revocation Endpoint to revoke an access token.\n\n    Args:\n        access_token: the access token to revoke\n        requests_kwargs: additional parameters for the underlying requests.post() call\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint\n    \"\"\"\n    return self.revoke_token(\n        access_token,\n        token_type_hint=\"access_token\",\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_refresh_token","title":"<code>revoke_refresh_token(refresh_token, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a request to the Revocation Endpoint to revoke a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>Union[str, BearerToken]</code> <p>the refresh token to revoke.</p> required <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to pass to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation request is successful, <code>False</code> if this client has no configured revocation endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_refresh_token(\n    self,\n    refresh_token: Union[str, BearerToken],\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n\"\"\"Send a request to the Revocation Endpoint to revoke a refresh token.\n\n    Args:\n        refresh_token: the refresh token to revoke.\n        requests_kwargs: additional parameters to pass to the revocation endpoint.\n        **revoke_kwargs: additional parameters to pass to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation request is successful, `False` if this client has no configured revocation endpoint.\n    \"\"\"\n    if isinstance(refresh_token, BearerToken):\n        if refresh_token.refresh_token is None:\n            raise ValueError(\"The supplied BearerToken doesn't have a refresh token.\")\n        refresh_token = refresh_token.refresh_token\n\n    return self.revoke_token(\n        refresh_token,\n        token_type_hint=\"refresh_token\",\n        requests_kwargs=requests_kwargs,\n        **revoke_kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.revoke_token","title":"<code>revoke_token(token, token_type_hint=None, requests_kwargs=None, **revoke_kwargs)</code>","text":"<p>Send a Token Revocation request.</p> <p>By default, authentication will be the same than the one used for the Token Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Union[str, BearerToken]</code> <p>the token to revoke.</p> required <code>token_type_hint</code> <code>Optional[str]</code> <p>a token_type_hint to send to the revocation endpoint.</p> <code>None</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**revoke_kwargs</code> <code>Any</code> <p>additional parameters to send to the revocation endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the revocation succeeds,</p> <code>bool</code> <p><code>False</code> if no revocation endpoint is present or a non-standardised error is returned.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def revoke_token(\n    self,\n    token: Union[str, BearerToken],\n    token_type_hint: Optional[str] = None,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **revoke_kwargs: Any,\n) -&gt; bool:\n\"\"\"Send a Token Revocation request.\n\n    By default, authentication will be the same than the one used for the Token Endpoint.\n\n    Args:\n        token: the token to revoke.\n        token_type_hint: a token_type_hint to send to the revocation endpoint.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **revoke_kwargs: additional parameters to send to the revocation endpoint.\n\n    Returns:\n        `True` if the revocation succeeds,\n        `False` if no revocation endpoint is present or a non-standardised error is returned.\n    \"\"\"\n    if not self.revocation_endpoint:\n        return False\n\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == \"refresh_token\" and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            raise ValueError(\"The supplied BearerToken doesn't have a refresh token.\")\n        token = token.refresh_token\n\n    data = dict(revoke_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    response = self.session.post(\n        self.revocation_endpoint,\n        data=data,\n        auth=self.auth,\n        **requests_kwargs,\n    )\n    if response.ok:\n        return True\n\n    return self.on_revocation_error(response)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_revocation_error","title":"<code>on_revocation_error(response)</code>","text":"<p>Error handler for <code>revoke_token()</code>.</p> <p>Invoked by revoke_token() when the revocation endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the Response as returned by the Revocation Endpoint</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> to signal that an error occurred. May raise exceptions instead depending on the revocation response.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_revocation_error(self, response: requests.Response) -&gt; bool:\n\"\"\"Error handler for `revoke_token()`.\n\n    Invoked by [revoke_token()][requests_oauth2client.client.OAuth2Client.revoke_token] when the revocation endpoint returns an error.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Revocation Endpoint\n\n    Returns:\n        `False` to signal that an error occurred. May raise exceptions instead depending on the revocation response.\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, RevocationError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception:\n        return False\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.introspect_token","title":"<code>introspect_token(token, token_type_hint=None, requests_kwargs=None, **introspect_kwargs)</code>","text":"<p>Send a request to the configured Introspection Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>token_type_hint</code> <code>Optional[str]</code> <p>the token_type_hint to include in the request.</p> <code>None</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters to the underling call to requests.post()</p> <code>None</code> <code>**introspect_kwargs</code> <code>Any</code> <p>additional parameters to send to the introspection endpoint.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response as returned by the Introspection Endpoint.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def introspect_token(\n    self,\n    token: Union[str, BearerToken],\n    token_type_hint: Optional[str] = None,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **introspect_kwargs: Any,\n) -&gt; Any:\n\"\"\"Send a request to the configured Introspection Endpoint.\n\n    Args:\n        token_type_hint: the token_type_hint to include in the request.\n        requests_kwargs: additional parameters to the underling call to requests.post()\n        **introspect_kwargs: additional parameters to send to the introspection endpoint.\n\n    Returns:\n        the response as returned by the Introspection Endpoint.\n    \"\"\"\n    introspection_endpoint = self._require_endpoint(\"introspection_endpoint\")\n\n    requests_kwargs = requests_kwargs or {}\n\n    if token_type_hint == \"refresh_token\" and isinstance(token, BearerToken):\n        if token.refresh_token is None:\n            raise ValueError(\"The supplied BearerToken doesn't have a refresh token.\")\n        token = token.refresh_token\n\n    data = dict(introspect_kwargs, token=str(token))\n    if token_type_hint:\n        data[\"token_type_hint\"] = token_type_hint\n\n    response = self.session.post(\n        introspection_endpoint,\n        data=data,\n        auth=self.auth,\n        **requests_kwargs,\n    )\n    if response.ok:\n        return self.parse_introspection_response(response)\n\n    return self.on_introspection_error(response)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_introspection_response","title":"<code>parse_introspection_response(response)</code>","text":"<p>Parse Token Introspection Responses received by <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response. This decodes the JSON content if possible, otherwise it returns the response as a string.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the Response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the decoded JSON content, or a <code>str</code> with the content.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_introspection_response(self, response: requests.Response) -&gt; Any:\n\"\"\"Parse Token Introspection Responses received by `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response.\n    This decodes the JSON content if possible, otherwise it returns the response as a string.\n\n    Args:\n        response: the [Response][requests.Response] as returned by the Introspection Endpoint.\n\n    Returns:\n        the decoded JSON content, or a `str` with the content.\n    \"\"\"\n    try:\n        return response.json()\n    except ValueError:\n        return response.text\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_introspection_error","title":"<code>on_introspection_error(response)</code>","text":"<p>Error handler for <code>introspect_token()</code>.</p> <p>Invoked by introspect_token() to parse the returned response in the case an error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the response as returned by the Introspection Endpoint.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>usually raises exeptions. A subclass can return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_introspection_error(self, response: requests.Response) -&gt; Any:\n\"\"\"Error handler for `introspect_token()`.\n\n    Invoked by [introspect_token()][requests_oauth2client.client.OAuth2Client.introspect_token] to parse the returned response in the case an error is returned.\n\n    Args:\n        response: the response as returned by the Introspection Endpoint.\n\n    Returns:\n        usually raises exeptions. A subclass can return a default response instead.\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, IntrospectionError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception as exc:\n        raise UnknownIntrospectionError(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.backchannel_authentication_request","title":"<code>backchannel_authentication_request(scope='openid', client_notification_token=None, acr_values=None, login_hint_token=None, id_token_hint=None, login_hint=None, binding_message=None, user_code=None, requested_expiry=None, private_jwk=None, alg=None, requests_kwargs=None, **ciba_kwargs)</code>","text":"<p>Send a CIBA Authentication Request.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Union[None, str, Iterable[str]]</code> <p>the scope to include in the request.</p> <code>'openid'</code> <code>client_notification_token</code> <code>Optional[str]</code> <p>the Client Notification Token to include in the request.</p> <code>None</code> <code>acr_values</code> <code>Union[None, str, Iterable[str]]</code> <p>the acr values to include in the request.</p> <code>None</code> <code>login_hint_token</code> <code>Optional[str]</code> <p>the Login Hint Token to include in the request.</p> <code>None</code> <code>id_token_hint</code> <code>Optional[str]</code> <p>the ID Token Hint to include in the request.</p> <code>None</code> <code>login_hint</code> <code>Optional[str]</code> <p>the Login Hint to include in the request.</p> <code>None</code> <code>binding_message</code> <code>Optional[str]</code> <p>the Binding Message to include in the request.</p> <code>None</code> <code>user_code</code> <code>Optional[str]</code> <p>the User Code to include in the request</p> <code>None</code> <code>requested_expiry</code> <code>Optional[int]</code> <p>the Requested Expiry, in seconds, to include in the request.</p> <code>None</code> <code>private_jwk</code> <code>Union[Jwk, Dict[str, Any], None]</code> <p>the JWK to use to sign the request (optional)</p> <code>None</code> <code>alg</code> <code>Optional[str]</code> <p>the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.</p> <code>None</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for</p> <code>None</code> <code>**ciba_kwargs</code> <code>Any</code> <p>additional parameters to include in the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a BackChannelAuthenticationResponse as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def backchannel_authentication_request(\n    self,\n    scope: Union[None, str, Iterable[str]] = \"openid\",\n    client_notification_token: Optional[str] = None,\n    acr_values: Union[None, str, Iterable[str]] = None,\n    login_hint_token: Optional[str] = None,\n    id_token_hint: Optional[str] = None,\n    login_hint: Optional[str] = None,\n    binding_message: Optional[str] = None,\n    user_code: Optional[str] = None,\n    requested_expiry: Optional[int] = None,\n    private_jwk: Union[Jwk, Dict[str, Any], None] = None,\n    alg: Optional[str] = None,\n    requests_kwargs: Optional[Dict[str, Any]] = None,\n    **ciba_kwargs: Any,\n) -&gt; BackChannelAuthenticationResponse:\n\"\"\"Send a CIBA Authentication Request.\n\n    Args:\n         scope: the scope to include in the request.\n         client_notification_token: the Client Notification Token to include in the request.\n         acr_values: the acr values to include in the request.\n         login_hint_token: the Login Hint Token to include in the request.\n         id_token_hint: the ID Token Hint to include in the request.\n         login_hint: the Login Hint to include in the request.\n         binding_message: the Binding Message to include in the request.\n         user_code: the User Code to include in the request\n         requested_expiry: the Requested Expiry, in seconds, to include in the request.\n         private_jwk: the JWK to use to sign the request (optional)\n         alg: the alg to use to sign the request, if the provided JWK does not include an \"alg\" parameter.\n         requests_kwargs: additional parameters for\n         **ciba_kwargs: additional parameters to include in the request.\n\n    Returns:\n        a BackChannelAuthenticationResponse as returned by AS\n    \"\"\"\n    backchannel_authentication_endpoint = self._require_endpoint(\n        \"backchannel_authentication_endpoint\"\n    )\n\n    if not (login_hint or login_hint_token or id_token_hint):\n        raise ValueError(\n            \"One of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        )\n\n    if (\n        (login_hint_token and id_token_hint)\n        or (login_hint and id_token_hint)\n        or (login_hint_token and login_hint)\n    ):\n        raise ValueError(\n            \"Only one of `login_hint`, `login_hint_token` or `\u00ecd_token_hint` must be provided\"\n        )\n\n    requests_kwargs = requests_kwargs or {}\n\n    if scope is not None and not isinstance(scope, str):\n        try:\n            scope = \" \".join(scope)\n        except Exception as exc:\n            raise ValueError(\"Unsupported `scope` value\") from exc\n\n    if acr_values is not None and not isinstance(acr_values, str):\n        try:\n            acr_values = \" \".join(acr_values)\n        except Exception as exc:\n            raise ValueError(\"Unsupported `acr_values`\") from exc\n\n    data = dict(\n        ciba_kwargs,\n        scope=scope,\n        client_notification_token=client_notification_token,\n        acr_values=acr_values,\n        login_hint_token=login_hint_token,\n        id_token_hint=id_token_hint,\n        login_hint=login_hint,\n        binding_message=binding_message,\n        user_code=user_code,\n        requested_expiry=requested_expiry,\n    )\n\n    if private_jwk is not None:\n        data = {\"request\": str(Jwt.sign(data, key=private_jwk, alg=alg))}\n\n    response = self.session.post(\n        backchannel_authentication_endpoint,\n        data=data,\n        auth=self.auth,\n        **requests_kwargs,\n    )\n\n    if response.ok:\n        return self.parse_backchannel_authentication_response(response)\n\n    return self.on_backchannel_authentication_error(response)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_backchannel_authentication_response","title":"<code>parse_backchannel_authentication_response(response)</code>","text":"<p>Parse a response received by <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>a <code>BackChannelAuthenticationResponse</code></p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_backchannel_authentication_response(\n    self, response: requests.Response\n) -&gt; BackChannelAuthenticationResponse:\n\"\"\"Parse a response received by `backchannel_authentication_request()`.\n\n    Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response\n    returned by the BackChannel Authentication Endpoint.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        a `BackChannelAuthenticationResponse`\n    \"\"\"\n    try:\n        return BackChannelAuthenticationResponse(**response.json())\n    except TypeError as exc:\n        raise InvalidBackChannelAuthenticationResponse(response) from exc\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_backchannel_authentication_error","title":"<code>on_backchannel_authentication_error(response)</code>","text":"<p>Error handler for <code>backchannel_authentication_request()</code>.</p> <p>Invoked by backchannel_authentication_request() to parse the response returned by the BackChannel Authentication Endpoint, when it is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the response returned by the BackChannel Authentication Endpoint.</p> required <p>Returns:</p> Type Description <code>BackChannelAuthenticationResponse</code> <p>usually raises an exception. But a subclass can return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_backchannel_authentication_error(\n    self, response: requests.Response\n) -&gt; BackChannelAuthenticationResponse:\n\"\"\"Error handler for `backchannel_authentication_request()`.\n\n    Invoked by [backchannel_authentication_request()][requests_oauth2client.client.OAuth2Client.backchannel_authentication_request] to parse the response\n    returned by the BackChannel Authentication Endpoint, when it is an error.\n\n    Args:\n        response: the response returned by the BackChannel Authentication Endpoint.\n\n    Returns:\n        usually raises an exception. But a subclass can return a default response instead.\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, BackChannelAuthenticationError)\n        exception = exception_class(error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidBackChannelAuthenticationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.authorize_device","title":"<code>authorize_device(**data)</code>","text":"<p>Send a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>additional data to send to the Device Authorization Endpoint</p> <code>{}</code> <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a Device Authorization Response</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def authorize_device(self, **data: Any) -&gt; DeviceAuthorizationResponse:\n\"\"\"Send a Device Authorization Request.\n\n    Args:\n        **data: additional data to send to the Device Authorization Endpoint\n\n    Returns:\n        a Device Authorization Response\n    \"\"\"\n    device_authorization_endpoint = self._require_endpoint(\"device_authorization_endpoint\")\n\n    response = self.session.post(device_authorization_endpoint, data=data, auth=self.auth)\n\n    if response.ok:\n        return self.parse_device_authorization_response(response)\n\n    return self.on_device_authorization_error(response)\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.parse_device_authorization_response","title":"<code>parse_device_authorization_response(response)</code>","text":"<p>Parse a Device Authorization Response received by <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>a <code>DeviceAuthorizationResponse</code> as returned by AS</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def parse_device_authorization_response(\n    self, response: requests.Response\n) -&gt; DeviceAuthorizationResponse:\n\"\"\"Parse a Device Authorization Response received by `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        a `DeviceAuthorizationResponse` as returned by AS\n    \"\"\"\n    device_authorization_response = DeviceAuthorizationResponse(**response.json())\n    return device_authorization_response\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.on_device_authorization_error","title":"<code>on_device_authorization_error(response)</code>","text":"<p>Error handler for <code>authorize_device()</code>.</p> <p>Invoked by authorize_device() to parse the response returned by the Device Authorization Endpoint, when that response is an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the response returned by the Device Authorization Endpoint.</p> required <p>Returns:</p> Type Description <code>DeviceAuthorizationResponse</code> <p>usually raises an Exception. But a subclass may return a default response instead.</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def on_device_authorization_error(\n    self, response: requests.Response\n) -&gt; DeviceAuthorizationResponse:\n\"\"\"Error handler for `authorize_device()`.\n\n    Invoked by [authorize_device()][requests_oauth2client.client.OAuth2Client.authorize_device] to parse the response returned by the Device Authorization Endpoint, when that response is an error.\n\n    Args:\n        response: the response returned by the Device Authorization Endpoint.\n\n    Returns:\n        usually raises an Exception. But a subclass may return a default response instead.\n    \"\"\"\n    try:\n        data = response.json()\n        error = data[\"error\"]\n        error_description = data.get(\"error_description\")\n        error_uri = data.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, DeviceAuthorizationError)\n        exception = exception_class(response, error, error_description, error_uri)\n    except Exception as exc:\n        raise InvalidDeviceAuthorizationResponse(response) from exc\n    raise exception\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.update_authorization_server_public_keys","title":"<code>update_authorization_server_public_keys()</code>","text":"<p>Update the cached AS public keys by retrieving them from its <code>jwks_uri</code>.</p> <p>Public keys are returned by this method, as a JwkSet. They are also available in attribute <code>authorization_server_jwks</code>.</p> <p>Returns:</p> Type Description <code>JwkSet</code> <p>the retrieved public keys</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no jwks_uri is configured</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>def update_authorization_server_public_keys(self) -&gt; JwkSet:\n\"\"\"Update the cached AS public keys by retrieving them from its `jwks_uri`.\n\n    Public keys are returned by this method, as a [JwkSet][jwskate.JwkSet].\n    They are also available in attribute `authorization_server_jwks`.\n\n    Returns:\n        the retrieved public keys\n\n    Raises:\n        ValueError: if no jwks_uri is configured\n    \"\"\"\n    jwks_uri = self._require_endpoint(\"jwks_uri\")\n\n    jwks = self.session.get(jwks_uri, auth=None).json()\n    self.authorization_server_jwks = JwkSet(jwks)\n    return self.authorization_server_jwks\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_endpoint","title":"<code>from_discovery_endpoint(url=None, issuer=None, auth=None, client_id=None, client_secret=None, private_key=None, session=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client based on Authorization Server Metadata.</p> <p>This will retrieve the standardised metadata document available at <code>url</code>, and will extract all Endpoint Uris from that document, will fetch the current public keys from its <code>jwks_uri</code>, then will initialize an OAuth2Client based on those endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>the url where the server metadata will be retrieved</p> <code>None</code> <code>auth</code> <code>Union[requests.auth.AuthBase, Tuple[str, str], str, None]</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>Optional[str]</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>Optional[str]</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Union[Jwk, Dict[str, Any], None]</code> <p>private key to sign client assertions</p> <code>None</code> <code>session</code> <code>Optional[requests.Session]</code> <p>a requests Session to use to retrieve the document and initialise the client with</p> <code>None</code> <code>issuer</code> <code>Optional[str]</code> <p>if an issuer is given, check that it matches the one from the retrieved document</p> <code>None</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an OAuth2Client with endpoint initialized based on the obtained metadata</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if neither <code>url</code> or <code>issuer</code> are suitable urls.</p> <code>requests.HTTPError</code> <p>if an error happens while fetching the documents</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_endpoint(\n    cls,\n    url: Optional[str] = None,\n    issuer: Optional[str] = None,\n    auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n    client_id: Optional[str] = None,\n    client_secret: Optional[str] = None,\n    private_key: Union[Jwk, Dict[str, Any], None] = None,\n    session: Optional[requests.Session] = None,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n\"\"\"Initialise an OAuth2Client based on Authorization Server Metadata.\n\n    This will retrieve the standardised metadata document available at `url`, and will extract all Endpoint Uris\n    from that document, will fetch the current public keys from its `jwks_uri`, then will initialize an OAuth2Client\n    based on those endpoints.\n\n    Args:\n         url: the url where the server metadata will be retrieved\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         session: a requests Session to use to retrieve the document and initialise the client with\n         issuer: if an issuer is given, check that it matches the one from the retrieved document\n\n    Returns:\n        an OAuth2Client with endpoint initialized based on the obtained metadata\n\n    Raises:\n        ValueError: if neither `url` or `issuer` are suitable urls.\n        requests.HTTPError: if an error happens while fetching the documents\n    \"\"\"\n    if url is None and issuer is not None:\n        url = oidc_discovery_document_url(issuer)\n    if url is None:\n        raise ValueError(\"Please specify at least one of `issuer` or `url`\")\n\n    validate_endpoint_uri(url, path=False)\n\n    session = session or requests.Session()\n    discovery = session.get(url).json()\n\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri:\n        jwks = JwkSet(session.get(jwks_uri).json())\n\n    return cls.from_discovery_document(\n        discovery,\n        issuer=issuer,\n        auth=auth,\n        session=session,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        authorization_server_jwks=jwks,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.client.OAuth2Client.from_discovery_document","title":"<code>from_discovery_document(discovery, issuer=None, auth=None, client_id=None, client_secret=None, private_key=None, authorization_server_jwks=None, session=None, https=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialise an OAuth2Client, based on the server metadata from <code>discovery</code>.</p> <p>Parameters:</p> Name Type Description Default <code>discovery</code> <code>Dict[str, Any]</code> <p>a dict of server metadata, in the same format as retrieved from a discovery endpoint.</p> required <code>issuer</code> <code>Optional[str]</code> <p>if an issuer is given, check that it matches the one mentioned in the document</p> <code>None</code> <code>auth</code> <code>Union[requests.auth.AuthBase, Tuple[str, str], str, None]</code> <p>the authentication handler to use for client authentication</p> <code>None</code> <code>client_id</code> <code>Optional[str]</code> <p>client ID</p> <code>None</code> <code>client_secret</code> <code>Optional[str]</code> <p>client secret to use to authenticate the client</p> <code>None</code> <code>private_key</code> <code>Union[Jwk, Dict[str, Any], None]</code> <p>private key to sign client assertions</p> <code>None</code> <code>authorization_server_jwks</code> <code>Union[JwkSet, Dict[str, Any], None]</code> <p>the current authorization server JWKS keys</p> <code>None</code> <code>session</code> <code>Optional[requests.Session]</code> <p>a requests Session to use to retrieve the document and initialise the client with</p> <code>None</code> <code>https</code> <code>bool</code> <p>if True, validates that urls in the discovery document use the https scheme</p> <code>True</code> <p>Returns:</p> Type Description <code>OAuth2Client</code> <p>an OAuth2Client</p> Source code in <code>requests_oauth2client/client.py</code> <pre><code>@classmethod\ndef from_discovery_document(\n    cls,\n    discovery: Dict[str, Any],\n    issuer: Optional[str] = None,\n    auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n    client_id: Optional[str] = None,\n    client_secret: Optional[str] = None,\n    private_key: Union[Jwk, Dict[str, Any], None] = None,\n    authorization_server_jwks: Union[JwkSet, Dict[str, Any], None] = None,\n    session: Optional[requests.Session] = None,\n    https: bool = True,\n    **kwargs: Any,\n) -&gt; OAuth2Client:\n\"\"\"Initialise an OAuth2Client, based on the server metadata from `discovery`.\n\n    Args:\n         discovery: a dict of server metadata, in the same format as retrieved from a discovery endpoint.\n         issuer: if an issuer is given, check that it matches the one mentioned in the document\n         auth: the authentication handler to use for client authentication\n         client_id: client ID\n         client_secret: client secret to use to authenticate the client\n         private_key: private key to sign client assertions\n         authorization_server_jwks: the current authorization server JWKS keys\n         session: a requests Session to use to retrieve the document and initialise the client with\n         https: if True, validates that urls in the discovery document use the https scheme\n\n    Returns:\n        an OAuth2Client\n    \"\"\"\n    if issuer and discovery.get(\"issuer\") != issuer:\n        raise ValueError(\n            \"Mismatching issuer value in discovery document: \",\n            issuer,\n            discovery.get(\"issuer\"),\n        )\n    elif issuer is None:\n        issuer = discovery.get(\"issuer\")\n\n    token_endpoint = discovery.get(\"token_endpoint\")\n    if token_endpoint is None:\n        raise ValueError(\"token_endpoint not found in that discovery document\")\n    validate_endpoint_uri(token_endpoint, https=https)\n    authorization_endpoint = discovery.get(\"authorization_endpoint\")\n    if authorization_endpoint is not None:\n        validate_endpoint_uri(authorization_endpoint, https=https)\n    validate_endpoint_uri(token_endpoint, https=https)\n    revocation_endpoint = discovery.get(\"revocation_endpoint\")\n    if revocation_endpoint is not None:\n        validate_endpoint_uri(revocation_endpoint, https=https)\n    introspection_endpoint = discovery.get(\"introspection_endpoint\")\n    if introspection_endpoint is not None:\n        validate_endpoint_uri(introspection_endpoint, https=https)\n    userinfo_endpoint = discovery.get(\"userinfo_endpoint\")\n    if userinfo_endpoint is not None:\n        validate_endpoint_uri(userinfo_endpoint, https=https)\n    jwks_uri = discovery.get(\"jwks_uri\")\n    if jwks_uri is not None:\n        validate_endpoint_uri(userinfo_endpoint, https=https)\n    authorization_response_iss_parameter_supported = discovery.get(\n        \"authorization_response_iss_parameter_supported\", False\n    )\n\n    return cls(\n        token_endpoint=token_endpoint,\n        authorization_endpoint=authorization_endpoint,\n        revocation_endpoint=revocation_endpoint,\n        introspection_endpoint=introspection_endpoint,\n        userinfo_endpoint=userinfo_endpoint,\n        jwks_uri=jwks_uri,\n        authorization_server_jwks=authorization_server_jwks,\n        auth=auth,\n        client_id=client_id,\n        client_secret=client_secret,\n        private_key=private_key,\n        session=session,\n        issuer=issuer,\n        authorization_response_iss_parameter_supported=authorization_response_iss_parameter_supported,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth","title":"<code>auth</code>","text":"<p>This module contains requests-compatible Auth Handlers that implement OAuth 2.0.</p>"},{"location":"api/#requests_oauth2client.auth.BearerAuth","title":"<code>BearerAuth</code>","text":"<p>         Bases: <code>requests.auth.AuthBase</code></p> <p>An Auth Handler that includes a Bearer Token in API calls, as defined in RFC6750$2.1.</p> <p>As a prerequisite to using this <code>AuthBase</code>, you have to obtain an access token manually. You most likely don't want do to that by yourself, but instead use an instance of OAuth2Client to do that for you. See the others Auth Handlers in this module, which will automatically obtain access tokens from an OAuth 2.x server.</p> Usage <pre><code>auth = BearerAuth(\"my_access_token\")\nresp = requests.get(\"https://my.api.local/resource\", auth=auth)\n</code></pre> <p>The HTTP request will look like: <pre><code>GET /resource HTTP/1.1\nHost: my.api.local\nAuthorization: Bearer my_access_token\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Optional[Union[str, BearerToken]]</code> <p>a BearerToken or a string to use as token for this Auth Handler. If <code>None</code>, this Auth Handler is a no op.</p> <code>None</code> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class BearerAuth(requests.auth.AuthBase):\n\"\"\"An Auth Handler that includes a Bearer Token in API calls, as defined in [RFC6750$2.1].\n\n    As a prerequisite to using this `AuthBase`, you have to obtain an access token manually.\n    You most likely don't want do to that by yourself, but instead use an instance of\n    [OAuth2Client][requests_oauth2client.client.OAuth2Client] to do that for you.\n    See the others Auth Handlers in this module, which will automatically obtain access tokens from an OAuth 2.x server.\n\n    [RFC6750$2.1]: https://datatracker.ietf.org/doc/html/rfc6750#section-2.1\n\n    Usage:\n        ```python\n        auth = BearerAuth(\"my_access_token\")\n        resp = requests.get(\"https://my.api.local/resource\", auth=auth)\n        ```\n\n        The HTTP request will look like:\n        ```\n        GET /resource HTTP/1.1\n        Host: my.api.local\n        Authorization: Bearer my_access_token\n        ```\n\n    Args:\n        token: a [BearerToken][requests_oauth2client.tokens.BearerToken] or a string to use as token for this Auth Handler. If `None`, this Auth Handler is a no op.\n    \"\"\"\n\n    def __init__(self, token: Optional[Union[str, BearerToken]] = None) -&gt; None:\n        self.token = token  # type: ignore[assignment] # until https://github.com/python/mypy/issues/3004 is fixed\n\n    @property\n    def token(self) -&gt; Optional[BearerToken]:\n\"\"\"Return the [BearerToken] that is used for authorization against the API.\n\n        Returns:\n            the configured [BearerToken][requests_oauth2client.tokens.BearerToken] used with this AuthHandler.\n        \"\"\"\n        return self._token\n\n    @token.setter\n    def token(self, token: Union[str, BearerToken]) -&gt; None:\n\"\"\"Change the access token used with this AuthHandler.\n\n        Accepts a [BearerToken][requests_oauth2client.tokens.BearerToken] or an access token as `str`.\n\n        Args:\n            token: an access token to use for this Auth Handler\n        \"\"\"\n        if token is not None and not isinstance(token, BearerToken):\n            token = BearerToken(token)\n        self._token = token\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Implement the usage of Bearer Tokens in requests.\n\n        This will add a properly formatted `Authorization: Bearer &lt;token&gt;` header in\n        the request.\n\n        If the configured token is a instance of BearerToken with an expires_at attribute,\n        raises [ExpiredAccessToken][requests_oauth2client.exceptions.ExpiredAccessToken] once the access token is expired.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header\n        \"\"\"\n        if self.token is None:\n            return request\n        if self.token.is_expired():\n            raise ExpiredAccessToken(self.token)\n        request.headers[\"Authorization\"] = self.token.authorization_header()\n        return request\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.BearerAuth.token","title":"<code>token: Optional[BearerToken]</code>  <code>writable</code> <code>property</code>","text":"<p>Return the [BearerToken] that is used for authorization against the API.</p> <p>Returns:</p> Type Description <code>Optional[BearerToken]</code> <p>the configured BearerToken used with this AuthHandler.</p>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth","title":"<code>OAuth2ClientCredentialsAuth</code>","text":"<p>         Bases: <code>BearerAuth</code></p> <p>An Auth Handler for the Client Credentials grant.</p> <p>This requests AuthBase automatically gets Access Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will get a new one once the current one is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>**token_kwargs</code> <code>Any</code> <p>extra kw parameters to pass to the Token Endpoint. May include <code>scope</code>, <code>resource</code>, etc.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")\n)\noauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\nresp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n</code></pre> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2ClientCredentialsAuth(BearerAuth):\n\"\"\"An Auth Handler for the Client Credentials grant.\n\n    This [requests AuthBase][requests.auth.AuthBase] automatically gets Access\n    Tokens from an OAuth 2.0 Token Endpoint with the Client Credentials grant, and will\n    get a new one once the current one is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        **token_kwargs: extra kw parameters to pass to the Token Endpoint. May include `scope`, `resource`, etc.\n\n    Usage:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")\n        )\n        oauth2cc = OAuth2ClientCredentialsAuth(client, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2cc)\n        ```\n    \"\"\"\n\n    def __init__(self, client: \"OAuth2Client\", **token_kwargs: Any):\n        super().__init__(None)\n        self.client = client\n        self.token_kwargs = token_kwargs\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Implement the Client Credentials grant as an Auth Handler.\n\n        This will obtain a token using the Client Credentials Grant, and include that token in requests.\n        Once the token is expired (detected using the 'expires_in' hint), it will obtain a new token.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.renew_token()\n        return super().__call__(request)\n\n    def renew_token(self) -&gt; None:\n\"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n        self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2ClientCredentialsAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token for use within this Auth Handler.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n\"\"\"Obtain a new token for use within this Auth Handler.\"\"\"\n    self.token = self.client.client_credentials(**self.token_kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth","title":"<code>OAuth2AccessTokenAuth</code>","text":"<p>         Bases: <code>BearerAuth</code></p> <p>Authenticaton Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.</p> <p>This Requests Auth handler implementation uses an access token as Bearer token, and can automatically refreshes it when expired, if a refresh token is available.</p> <p>Token can be a simple <code>str</code> containing a raw access token value, or a BearerToken that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler will automatically refresh the access token once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to refresh tokens.</p> required <code>token</code> <code>Optional[Union[str, BearerToken]]</code> <p>a access token that has been previously obtained</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) token = BearerToken(     access_token=\"access_token\",     expires_in=600,     refresh_token=\"refresh_token\")  # obtain a BearerToken any way you see fit, including a refresh token oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\") resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2AccessTokenAuth(BearerAuth):\n\"\"\"Authenticaton Handler for OAuth 2.0 Access Tokens and (optional) Refresh Tokens.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation uses an access token as Bearer token, and can\n    automatically refreshes it when expired, if a refresh token is available.\n\n    Token can be a simple `str` containing a raw access token value, or a [BearerToken][requests_oauth2client.tokens.BearerToken]\n    that can contain a refresh_token. If a refresh_token and an expiration date are available, this Auth Handler\n    will automatically refresh the access token once it is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to refresh tokens.\n        token: a access token that has been previously obtained\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        token = BearerToken(\n            access_token=\"access_token\",\n            expires_in=600,\n            refresh_token=\"refresh_token\")  # obtain a BearerToken any way you see fit, including a refresh token\n        oauth2at_auth = OAuth2ClientCredentialsAuth(client, token, scope=\"my_scope\")\n        resp = requests.post(\"https://my.api.local/resource\", auth=oauth2at_auth)\n        ````\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"OAuth2Client\",\n        token: Optional[Union[str, BearerToken]] = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(token)\n        self.client = client\n        self.token_kwargs = token_kwargs\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Implement the usage of OAuth 2.0 access tokens as Bearer Tokens.\n\n        This adds access token in requests, and refreshes that token once it is expired.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header\n        \"\"\"\n        token = self.token\n        if token is not None and token.is_expired():\n            self.renew_token()\n        return super().__call__(request)\n\n    def renew_token(self) -&gt; None:\n\"\"\"Obtain a new token, by using the Refresh Token, if available.\"\"\"\n        if self.token and self.token.refresh_token and self.client is not None:\n            self.token = self.client.refresh_token(\n                refresh_token=self.token.refresh_token, **self.token_kwargs\n            )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AccessTokenAuth.renew_token","title":"<code>renew_token()</code>","text":"<p>Obtain a new token, by using the Refresh Token, if available.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def renew_token(self) -&gt; None:\n\"\"\"Obtain a new token, by using the Refresh Token, if available.\"\"\"\n    if self.token and self.token.refresh_token and self.client is not None:\n        self.token = self.client.refresh_token(\n            refresh_token=self.token.refresh_token, **self.token_kwargs\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth","title":"<code>OAuth2AuthorizationCodeAuth</code>","text":"<p>         Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication handler for the Authorization Code grant.</p> <p>This Requests Auth handler implementation exchanges an Authorization Code for an access token, then automatically refreshes it once it is expired.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>code</code> <code>Union[str, AuthorizationResponse]</code> <p>an Authorization Code that has been obtained from the AS.</p> required <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) code = \"my_code\" # you must obtain this code yourself resp = requests.post(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code)) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2AuthorizationCodeAuth(OAuth2AccessTokenAuth):\n\"\"\"Authentication handler for the Authorization Code grant.\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges an Authorization\n    Code for an access token, then automatically refreshes it once it is expired.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        code: an Authorization Code that has been obtained from the AS.\n        **token_kwargs: additional kwargs to pass to the token endpoint\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        code = \"my_code\" # you must obtain this code yourself\n        resp = requests.post(\"https://my.api.local/resource\", auth=OAuth2AuthorizationCodeAuth(client, code))\n        ````\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"OAuth2Client\",\n        code: Union[str, AuthorizationResponse],\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(client, None)\n        self.code: Union[str, AuthorizationResponse, None] = code\n        self.token_kwargs = token_kwargs\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Implement the Authorization Code grant as an Authentication Handler.\n\n        This exchanges an Authorization Code for an access token and adds it in the request.\n\n        Args:\n            request: a [PreparedRequest][requests.PreparedRequest]\n\n        Returns:\n            a [PreparedRequest][requests.PreparedRequest] with an Access Token added in Authorization Header\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.exchange_code_for_token()\n        return super().__call__(request)\n\n    def exchange_code_for_token(self) -&gt; None:\n\"\"\"Obtain the initial access token with the authorization_code grant.\"\"\"\n        if self.code:  # pragma: no branch\n            self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n            self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2AuthorizationCodeAuth.exchange_code_for_token","title":"<code>exchange_code_for_token()</code>","text":"<p>Obtain the initial access token with the authorization_code grant.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_code_for_token(self) -&gt; None:\n\"\"\"Obtain the initial access token with the authorization_code grant.\"\"\"\n    if self.code:  # pragma: no branch\n        self.token = self.client.authorization_code(code=self.code, **self.token_kwargs)\n        self.code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth","title":"<code>OAuth2DeviceCodeAuth</code>","text":"<p>         Bases: <code>OAuth2AccessTokenAuth</code></p> <p>Authentication Handler for the Device Code Flow.</p> <p>This Requests Auth handler implementation exchanges a Device Code for an Access Token, then automatically refreshes it once it is expired.</p> <p>It needs a Device Code and an OAuth2Client to be able to get a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client to use to obtain Access Tokens.</p> required <code>device_code</code> <code>Union[str, DeviceAuthorizationResponse]</code> <p>a Device Code obtained from the AS.</p> required <code>interval</code> <code>int</code> <p>the interval to use to pool the Token Endpoint, in seconds.</p> <code>5</code> <code>expires_in</code> <code>int</code> <p>the lifetime of the token, in seconds.</p> <code>360</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs to pass to the token endpoint.</p> <code>{}</code> Usage <p>```python client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")) device_code = client.device_authorization() auth = OAuth2DeviceCodeAuth(client, device_code) resp = requests.post(\"https://my.api.local/resource\", auth=auth) ````</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>class OAuth2DeviceCodeAuth(OAuth2AccessTokenAuth):\n\"\"\"Authentication Handler for the [Device Code Flow](https://www.rfc-editor.org/rfc/rfc8628).\n\n    This [Requests Auth handler][requests.auth.AuthBase] implementation exchanges a Device Code for\n    an Access Token, then automatically refreshes it once it is expired.\n\n    It needs a Device Code and an [OAuth2Client][requests_oauth2client.client.OAuth2Client] to be able to get\n    a token from the AS Token Endpoint just before the first request using this Auth Handler is being sent.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] to use to obtain Access Tokens.\n        device_code: a Device Code obtained from the AS.\n        interval: the interval to use to pool the Token Endpoint, in seconds.\n        expires_in: the lifetime of the token, in seconds.\n        **token_kwargs: additional kwargs to pass to the token endpoint.\n\n    Usage:\n        ```python\n        client = OAuth2Client(token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\"))\n        device_code = client.device_authorization()\n        auth = OAuth2DeviceCodeAuth(client, device_code)\n        resp = requests.post(\"https://my.api.local/resource\", auth=auth)\n        ````\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"OAuth2Client\",\n        device_code: Union[str, DeviceAuthorizationResponse],\n        interval: int = 5,\n        expires_in: int = 360,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(client, None)\n        self.device_code: Union[str, DeviceAuthorizationResponse, None] = device_code\n        self.interval = interval\n        self.expires_in = expires_in\n        self.token_kwargs = token_kwargs\n\n    def __call__(self, request: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n\"\"\"Implement the Device Code grant as a request Authentication Handler.\n\n        This exchanges a Device Code for an access token and adds it in HTTP requests.\n\n        Args:\n            request: a [requests.PreparedRequest][]\n\n        Returns:\n            a [requests.PreparedRequest][] with an Access Token added in Authorization Header\n        \"\"\"\n        token = self.token\n        if token is None or token.is_expired():\n            self.exchange_device_code_for_token()\n        return super().__call__(request)\n\n    def exchange_device_code_for_token(self) -&gt; None:\n\"\"\"Exchange the Device Code for an access token.\n\n        This will poll the Token Endpoint until the user finishes the authorization process.\n        \"\"\"\n        from .device_authorization import DeviceAuthorizationPoolingJob\n\n        if self.device_code:  # pragma: no branch\n            pooling_job = DeviceAuthorizationPoolingJob(\n                client=self.client,\n                device_code=self.device_code,\n                interval=self.interval,\n            )\n            while self.token is None:\n                self.token = pooling_job()\n            self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.auth.OAuth2DeviceCodeAuth.exchange_device_code_for_token","title":"<code>exchange_device_code_for_token()</code>","text":"<p>Exchange the Device Code for an access token.</p> <p>This will poll the Token Endpoint until the user finishes the authorization process.</p> Source code in <code>requests_oauth2client/auth.py</code> <pre><code>def exchange_device_code_for_token(self) -&gt; None:\n\"\"\"Exchange the Device Code for an access token.\n\n    This will poll the Token Endpoint until the user finishes the authorization process.\n    \"\"\"\n    from .device_authorization import DeviceAuthorizationPoolingJob\n\n    if self.device_code:  # pragma: no branch\n        pooling_job = DeviceAuthorizationPoolingJob(\n            client=self.client,\n            device_code=self.device_code,\n            interval=self.interval,\n        )\n        while self.token is None:\n            self.token = pooling_job()\n        self.device_code = None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization","title":"<code>device_authorization</code>","text":"<p>Implements the Device Authorization Flow as defined in RFC8628.</p> <p>See RFC8628.</p>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse","title":"<code>DeviceAuthorizationResponse</code>","text":"<p>Represent a response returned by the device Authorization Endpoint.</p> <p>All parameters are those returned by the AS as response to a Device Authorization Request.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>user_code</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri</code> <code>str</code> <p>the <code>device_code</code> as returned by the AS.</p> required <code>verification_uri_complete</code> <code>Optional[str]</code> <p>the <code>device_code</code> as returned by the AS.</p> <code>None</code> <code>expires_at</code> <code>Optional[datetime]</code> <p>the expiration date for the device_code. Also accepts an <code>expires_in</code> parameter, as a number of seconds in the future.</p> <code>None</code> <code>interval</code> <code>Optional[int]</code> <p>the pooling <code>interval</code> as returned by the AS.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationResponse:\n\"\"\"Represent a response returned by the device Authorization Endpoint.\n\n    All parameters are those returned by the AS as response to a Device Authorization Request.\n\n    Args:\n        device_code: the `device_code` as returned by the AS.\n        user_code: the `device_code` as returned by the AS.\n        verification_uri: the `device_code` as returned by the AS.\n        verification_uri_complete: the `device_code` as returned by the AS.\n        expires_at: the expiration date for the device_code. Also accepts an `expires_in` parameter, as a number of seconds in the future.\n        interval: the pooling `interval` as returned by the AS.\n        **kwargs: additional parameters as returned by the AS.\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        device_code: str,\n        user_code: str,\n        verification_uri: str,\n        verification_uri_complete: Optional[str] = None,\n        expires_at: Optional[datetime] = None,\n        interval: Optional[int] = None,\n        **kwargs: Any,\n    ):\n        self.device_code = device_code\n        self.user_code = user_code\n        self.verification_uri = verification_uri\n        self.verification_uri_complete = verification_uri_complete\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; Optional[bool]:\n\"\"\"Check if the `device_code` within this response is expired.\n\n        Returns:\n            `True` if the device_code is expired, `False` if it is still valid, `None` if there is no `expires_in` hint.\n        \"\"\"\n        if self.expires_at:\n            return datetime.now() - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the <code>device_code</code> within this response is expired.</p> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p><code>True</code> if the device_code is expired, <code>False</code> if it is still valid, <code>None</code> if there is no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; Optional[bool]:\n\"\"\"Check if the `device_code` within this response is expired.\n\n    Returns:\n        `True` if the device_code is expired, `False` if it is still valid, `None` if there is no `expires_in` hint.\n    \"\"\"\n    if self.expires_at:\n        return datetime.now() - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob","title":"<code>DeviceAuthorizationPoolingJob</code>","text":"<p>         Bases: <code>TokenEndpointPoolingJob</code></p> <p>A Token Endpoint pooling job for the Device Authorization Flow.</p> <p>This periodically checks if the user has finished with his authorization in a Device Authorization flow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>device_code</code> <code>Union[str, DeviceAuthorizationResponse]</code> <p>a <code>device_code</code> as <code>str</code> or a <code>DeviceAuthorizationResponse</code>.</p> required <code>interval</code> <code>Optional[int]</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")\n)\npool_job = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\ntoken = None\nwhile token is None:\n    token = pool_job()\n</code></pre> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>class DeviceAuthorizationPoolingJob(TokenEndpointPoolingJob):\n\"\"\"A Token Endpoint pooling job for the Device Authorization Flow.\n\n    This periodically checks if the user has finished with his authorization in a\n    Device Authorization flow.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        device_code: a `device_code` as `str` or a `DeviceAuthorizationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Usage:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")\n        )\n        pool_job = DeviceAuthorizationPoolingJob(client=client, device_code=\"my_device_code\")\n\n        token = None\n        while token is None:\n            token = pool_job()\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"OAuth2Client\",\n        device_code: Union[str, DeviceAuthorizationResponse],\n        interval: Optional[int] = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ):\n        super().__init__(\n            client=client,\n            interval=interval,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs,\n            **token_kwargs,\n        )\n        self.device_code = device_code\n\n    def token_request(self) -&gt; BearerToken:\n\"\"\"Implement the Device Code token request.\n\n        This actually calls [OAuth2Client.device_code(device_code)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n        \"\"\"\n        return self.client.device_code(\n            self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.device_authorization.DeviceAuthorizationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the Device Code token request.</p> <p>This actually calls [OAuth2Client.device_code(device_code)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/device_authorization.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n\"\"\"Implement the Device Code token request.\n\n    This actually calls [OAuth2Client.device_code(device_code)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n    \"\"\"\n    return self.client.device_code(\n        self.device_code, requests_kwargs=self.requests_kwargs, **self.token_kwargs\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens","title":"<code>tokens</code>","text":"<p>This module contain classes that represent Tokens used in OAuth2.0 / OIDC.</p>"},{"location":"api/#requests_oauth2client.tokens.IdToken","title":"<code>IdToken</code>","text":"<p>         Bases: <code>jwskate.SignedJwt</code></p> <p>Represent an ID Token.</p> <p>An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded beforehand.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class IdToken(jwskate.SignedJwt):\n\"\"\"Represent an ID Token.\n\n    An ID Token is actually a Signed JWT. If the ID Token is encrypted, it must be decoded\n    beforehand.\n    \"\"\"\n\n    @property\n    def auth_time(self) -&gt; datetime:\n\"\"\"The last user authentication time.\"\"\"\n        auth_time = self.claims.get(\"auth_time\")\n        if auth_time:\n            return self.timestamp_to_datetime(auth_time)\n        raise AttributeError(\"This ID Token doesn't have an `auth_time` attribute.\")\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.IdToken.auth_time","title":"<code>auth_time: datetime</code>  <code>property</code>","text":"<p>The last user authentication time.</p>"},{"location":"api/#requests_oauth2client.tokens.BearerToken","title":"<code>BearerToken</code>","text":"<p>Represents a Bearer Token as returned by a Token Endpoint.</p> <p>This is a wrapper around a Bearer Token and associated parameters, such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.</p> <p>All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime in the <code>expires_at</code> parameter, or an <code>expires_in</code> parameter, as number of seconds in the future, can be passed instead.</p> <p>Parameters:</p> Name Type Description Default <code>access_token</code> <code>str</code> <p>an <code>access_token</code>, as returned by the AS.</p> required <code>expires_at</code> <code>Optional[datetime]</code> <p>an expiration date. This method also accepts an <code>expires_in</code> hint as returned by the AS, if any.</p> <code>None</code> <code>scope</code> <code>Optional[str]</code> <p>a <code>scope</code>, as returned by the AS, if any.</p> <code>None</code> <code>refresh_token</code> <code>Optional[str]</code> <p>a <code>refresh_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>token_type</code> <code>str</code> <p>a <code>token_type</code>, as returned by the AS.</p> <code>TOKEN_TYPE</code> <code>id_token</code> <code>Optional[str]</code> <p>an <code>id_token</code>, as returned by the AS, if any.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional parameters as returned by the AS, if any.</p> <code>{}</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerToken:\n\"\"\"Represents a Bearer Token as returned by a Token Endpoint.\n\n    This is a wrapper around a Bearer Token and associated parameters,\n    such as expiration date and refresh token, as returned by an OAuth 2.x or OIDC 1.0 Token Endpoint.\n\n    All parameters are as returned by a Token Endpoint. The token expiration date can be passed as datetime\n    in the `expires_at` parameter, or an `expires_in` parameter, as number of seconds in the future, can be passed instead.\n\n    Args:\n        access_token: an `access_token`, as returned by the AS.\n        expires_at: an expiration date. This method also accepts an `expires_in` hint as returned by the AS, if any.\n        scope: a `scope`, as returned by the AS, if any.\n        refresh_token: a `refresh_token`, as returned by the AS, if any.\n        token_type: a `token_type`, as returned by the AS.\n        id_token: an `id_token`, as returned by the AS, if any.\n        **kwargs: additional parameters as returned by the AS, if any.\n    \"\"\"\n\n    TOKEN_TYPE = \"Bearer\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        access_token: str,\n        *,\n        expires_at: Optional[datetime] = None,\n        scope: Optional[str] = None,\n        refresh_token: Optional[str] = None,\n        token_type: str = TOKEN_TYPE,\n        id_token: Optional[str] = None,\n        **kwargs: Any,\n    ):\n        if token_type.title() != self.TOKEN_TYPE.title():\n            raise ValueError(f\"Token Type is not '{self.TOKEN_TYPE}'!\", token_type)\n        self.access_token = access_token\n        self.expires_at = expires_at\n        self.scope = scope\n        self.refresh_token = refresh_token\n        self.id_token: Union[IdToken, jwskate.JweCompact, None] = None\n        if id_token:\n            try:\n                self.id_token = IdToken(id_token)\n            except jwskate.InvalidJwt:\n                try:\n                    self.id_token = jwskate.JweCompact(id_token)\n                except jwskate.InvalidJwe:\n                    raise InvalidIdToken(\n                        \"ID Token is invalid because it is  neither a JWT or a JWE.\"\n                    )\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; Optional[bool]:\n\"\"\"Check if the access token is expired.\n\n        Args:\n            leeway: If the token expires in the next given number of seconds, then consider it expired already.\n\n        Returns:\n            `True` if the access token is expired, `False` if it is still valid, `None` if there is no expires_in hint.\n        \"\"\"\n        if self.expires_at:\n            return datetime.now() - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def authorization_header(self) -&gt; str:\n\"\"\"Return the appropriate Authorization Header value for this token.\n\n        The value is formatted correctly according to RFC6750.\n\n        Returns:\n            the value to use in a HTTP Authorization Header\n        \"\"\"\n        return f\"Bearer {self.access_token}\"\n\n    def validate_id_token(  # noqa: C901\n        self, client: \"OAuth2Client\", azr: \"AuthorizationResponse\"\n    ) -&gt; IdToken:\n\"\"\"Validate that a token response is valid, and return the ID Token.\n\n        This will validate the id_token as described\n        in [OIDC 1.0 $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n        If the ID Token was encrypted, this decrypts it and returns the clear-text ID Token.\n        \"\"\"\n        if not self.id_token:\n            raise MissingIdToken()\n\n        raw_id_token = self.id_token\n\n        if (\n            isinstance(raw_id_token, jwskate.JweCompact)\n            and client.id_token_encrypted_response_alg is None\n        ):\n            raise InvalidIdToken(\"ID Token is encrypted while it should be clear-text\", self)\n        elif (\n            isinstance(raw_id_token, IdToken)\n            and client.id_token_encrypted_response_alg is not None\n        ):\n            raise InvalidIdToken(\"ID Token is clear-text while it should be encrypted\", self)\n\n        if isinstance(raw_id_token, jwskate.JweCompact):\n            enc_jwk = client.id_token_decryption_key\n            if enc_jwk is None:\n                raise InvalidIdToken(\n                    \"ID Token is encrypted but client does not have a decryption key\", self\n                )\n            nested_id_token = raw_id_token.decrypt(enc_jwk)\n            id_token = IdToken(nested_id_token)\n        else:\n            id_token = raw_id_token\n\n        if id_token.get_header(\"alg\") is None and client.id_token_signed_response_alg is None:\n            raise InvalidIdToken(\n                \"ID Token does not contain an `alg` parameter to specify the signature algorithm, \"\n                \"and no algorithm has been configured for the client (using param id_token_signed_response_alg`.\"\n            )\n        elif (\n            client.id_token_signed_response_alg is not None\n            and id_token.alg != client.id_token_signed_response_alg\n        ):\n            raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg)\n\n        id_token_alg = id_token.alg or client.id_token_signed_response_alg\n\n        if azr.issuer:\n            if id_token.issuer != azr.issuer:\n                raise MismatchingIssuer(id_token.issuer, azr.issuer, self)\n\n        if id_token.audiences and client.client_id not in id_token.audiences:\n            raise MismatchingAudience(id_token.audiences, client.client_id, self)\n\n        if id_token.get_claim(\"azp\") is not None and id_token.azp != client.client_id:\n            raise MismatchingAzp(id_token.azp, client.client_id, self)\n\n        if id_token.is_expired():\n            raise ExpiredIdToken(id_token)\n\n        if azr.nonce:\n            if id_token.nonce != azr.nonce:\n                raise MismatchingNonce()\n\n        if azr.acr_values:\n            if id_token.acr not in azr.acr_values:\n                raise MismatchingAcr(id_token.acr, azr.acr_values)\n\n        hash_function: Callable[[str], str]  # method used to calculate at_hash, s_hash, etc.\n\n        if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n            if not client.client_secret:\n                raise InvalidIdToken(\n                    \"ID Token is symmetrically signed but this client does not have a Client Secret.\"\n                )\n            id_token.verify_signature(\n                jwskate.SymmetricJwk.from_bytes(client.client_secret), alg=id_token_alg\n            )\n        elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n            if not client.authorization_server_jwks:\n                raise InvalidIdToken(\n                    \"ID Token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n                )\n\n            if id_token.get_header(\"kid\") is None:\n                raise InvalidIdToken(\n                    \"ID Token does not contain a Key ID (kid) to specify the asymmetric key to use for signature verification.\"\n                )\n            try:\n                verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n            except KeyError:\n                raise InvalidIdToken(\n                    \"ID Token is asymmetrically signed but its Key ID is not part of the Authorization Server JWKS.\"\n                )\n\n            if id_token_alg not in verification_jwk.supported_signing_algorithms():\n                raise InvalidIdToken(\n                    \"ID Token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n                )\n\n            id_token.verify_signature(verification_jwk, alg=id_token_alg)\n\n            alg_class = jwskate.select_alg_class(\n                verification_jwk.SIGNATURE_ALGORITHMS, jwk_alg=id_token_alg\n            )\n            if alg_class == jwskate.EdDsa:\n                if verification_jwk.crv == \"Ed25519\":\n                    hash_function = (\n                        lambda token: BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").ascii()\n                    )\n                elif verification_jwk.crv == \"Ed448\":\n                    hash_function = (\n                        lambda token: BinaPy(token).to(\"shake256\", 456).to(\"b64u\").ascii()\n                    )\n            else:\n                hash_alg = alg_class.hashing_alg.name\n                hash_size = alg_class.hashing_alg.digest_size\n                hash_function = (\n                    lambda token: BinaPy(token)\n                    .to(hash_alg)[: hash_size // 2]\n                    .to(\"b64u\")\n                    .ascii()\n                )\n\n        at_hash = id_token.get_claim(\"at_hash\")\n        if at_hash is not None:\n            expected_at_hash = hash_function(self.access_token)\n            if expected_at_hash != at_hash:\n                raise InvalidIdToken(\n                    f\"Mismatching 'at_hash' value: expected '{expected_at_hash}', got '{at_hash}'\"\n                )\n\n        c_hash = id_token.get_claim(\"c_hash\")\n        if c_hash is not None:\n            expected_c_hash = hash_function(azr.code)\n            if expected_c_hash != c_hash:\n                raise InvalidIdToken(\n                    f\"Mismatching 'c_hash' value: expected '{expected_c_hash}', got '{c_hash}'\"\n                )\n\n        s_hash = id_token.get_claim(\"s_hash\")\n        if s_hash is not None:\n            if azr.state is None:\n                raise InvalidIdToken(\n                    \"ID Token has a 's_hash' claim but no state was included in the request.\"\n                )\n            expected_s_hash = hash_function(azr.state)\n            if expected_s_hash != s_hash:\n                raise InvalidIdToken(\n                    f\"Mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}'\"\n                )\n\n        if azr.max_age is not None:\n            try:\n                auth_time = id_token.auth_time\n            except AttributeError:\n                raise InvalidIdToken(\n                    \"A `max_age` parameter was included in the authorization request, \"\n                    \"but the ID Token does not contain an `auth_time` claim.\"\n                )\n            auth_age = datetime.now(tz=timezone.utc) - auth_time\n            if auth_age.seconds &gt; azr.max_age + 60:\n                raise InvalidIdToken(\n                    \"User authentication happened too long ago. \"\n                    \"The `auth_time` parameter from the ID Token indicate that the last Authentication Time \"\n                    f\"was at {auth_time} ({auth_age.seconds} sec ago), but the authorization request `max_age` \"\n                    f\"parameter specified that it must be maximum {azr.max_age} sec ago.\"\n                )\n\n        return id_token\n\n    def __str__(self) -&gt; str:\n\"\"\"Return the access token value, as a string.\n\n        Returns:\n            the access token string\n        \"\"\"\n        return self.access_token\n\n    def __contains__(self, key: str) -&gt; bool:\n\"\"\"Check existence of a key in the token response.\n\n        Allows testing like `assert \"refresh_token\" in token_response`.\n\n        Args:\n            key: a key\n\n        Returns:\n            `True` if the key exists in the token response, `False` otherwise\n        \"\"\"\n        if key == \"access_token\":\n            return True\n        elif key == \"refresh_token\":\n            return self.refresh_token is not None\n        elif key == \"scope\":\n            return self.scope is not None\n        elif key == \"token_type\":\n            return True\n        elif key == \"expires_in\":\n            return self.expires_at is not None\n        elif key == \"id_token\":\n            return self.id_token is not None\n        else:\n            return key in self.other\n\n    def __getattr__(self, key: str) -&gt; Any:\n\"\"\"Return attributes from this BearerToken.\n\n        Allows `token_response.expires_in` or `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not found in this response.\n        \"\"\"\n        if key == \"expires_in\":\n            if self.expires_at is None:\n                return None\n            return int(self.expires_at.timestamp() - datetime.now().timestamp())\n        elif key == \"token_type\":\n            return self.TOKEN_TYPE\n        return self.other.get(key) or super().__getattribute__(key)\n\n    def as_dict(self, expires_at: bool = False) -&gt; Dict[str, Any]:\n\"\"\"Return all attributes from this BearerToken as a `dict`.\n\n        Args:\n            expires_at: if `True`, the dict will contain an extra `expires_at` field with the token expiration date.\n\n        Returns\n            a `dict` containing this BearerToken attributes.\n        \"\"\"\n        r: Dict[str, Any] = {\n            \"access_token\": self.access_token,\n            \"token_type\": self.TOKEN_TYPE,\n        }\n        if self.expires_at:\n            r[\"expires_in\"] = self.expires_in\n            if expires_at:\n                r[\"expires_at\"] = self.expires_at\n        if self.scope:\n            r[\"scope\"] = self.scope\n        if self.refresh_token:\n            r[\"refresh_token\"] = self.refresh_token\n        if self.id_token:\n            r[\"id_token\"] = str(self.id_token)\n        if self.other:\n            r.update(self.other)\n        return r\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this BearerToken.\n\n        This representation is a pretty formatted `dict` that looks like a Token Endpoint response.\n\n        Returns:\n            a `str` representation of this BearerToken.\n        \"\"\"\n        return pprint.pformat(self.as_dict())\n\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check if this BearerToken is equal to another.\n\n        It supports comparison with another BearerToken, or with an `access_token` as `str`.\n\n        Args:\n            other: another token to compare to\n\n        Returns:\n            `True` if equal, `False` otherwise\n        \"\"\"\n        if isinstance(other, BearerToken):\n            return (\n                self.access_token == other.access_token\n                and self.refresh_token == other.refresh_token\n                and self.expires_at == other.expires_at\n                and self.token_type == other.token_type\n            )\n        elif isinstance(other, str):\n            return self.access_token == other\n        return super().__eq__(other)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Check if the access token is expired.</p> <p>Parameters:</p> Name Type Description Default <code>leeway</code> <code>int</code> <p>If the token expires in the next given number of seconds, then consider it expired already.</p> <code>0</code> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p><code>True</code> if the access token is expired, <code>False</code> if it is still valid, <code>None</code> if there is no expires_in hint.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; Optional[bool]:\n\"\"\"Check if the access token is expired.\n\n    Args:\n        leeway: If the token expires in the next given number of seconds, then consider it expired already.\n\n    Returns:\n        `True` if the access token is expired, `False` if it is still valid, `None` if there is no expires_in hint.\n    \"\"\"\n    if self.expires_at:\n        return datetime.now() - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.authorization_header","title":"<code>authorization_header()</code>","text":"<p>Return the appropriate Authorization Header value for this token.</p> <p>The value is formatted correctly according to RFC6750.</p> <p>Returns:</p> Type Description <code>str</code> <p>the value to use in a HTTP Authorization Header</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def authorization_header(self) -&gt; str:\n\"\"\"Return the appropriate Authorization Header value for this token.\n\n    The value is formatted correctly according to RFC6750.\n\n    Returns:\n        the value to use in a HTTP Authorization Header\n    \"\"\"\n    return f\"Bearer {self.access_token}\"\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.validate_id_token","title":"<code>validate_id_token(client, azr)</code>","text":"<p>Validate that a token response is valid, and return the ID Token.</p> <p>This will validate the id_token as described in OIDC 1.0 $3.1.3.7.</p> <p>If the ID Token was encrypted, this decrypts it and returns the clear-text ID Token.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def validate_id_token(  # noqa: C901\n    self, client: \"OAuth2Client\", azr: \"AuthorizationResponse\"\n) -&gt; IdToken:\n\"\"\"Validate that a token response is valid, and return the ID Token.\n\n    This will validate the id_token as described\n    in [OIDC 1.0 $3.1.3.7](https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).\n\n    If the ID Token was encrypted, this decrypts it and returns the clear-text ID Token.\n    \"\"\"\n    if not self.id_token:\n        raise MissingIdToken()\n\n    raw_id_token = self.id_token\n\n    if (\n        isinstance(raw_id_token, jwskate.JweCompact)\n        and client.id_token_encrypted_response_alg is None\n    ):\n        raise InvalidIdToken(\"ID Token is encrypted while it should be clear-text\", self)\n    elif (\n        isinstance(raw_id_token, IdToken)\n        and client.id_token_encrypted_response_alg is not None\n    ):\n        raise InvalidIdToken(\"ID Token is clear-text while it should be encrypted\", self)\n\n    if isinstance(raw_id_token, jwskate.JweCompact):\n        enc_jwk = client.id_token_decryption_key\n        if enc_jwk is None:\n            raise InvalidIdToken(\n                \"ID Token is encrypted but client does not have a decryption key\", self\n            )\n        nested_id_token = raw_id_token.decrypt(enc_jwk)\n        id_token = IdToken(nested_id_token)\n    else:\n        id_token = raw_id_token\n\n    if id_token.get_header(\"alg\") is None and client.id_token_signed_response_alg is None:\n        raise InvalidIdToken(\n            \"ID Token does not contain an `alg` parameter to specify the signature algorithm, \"\n            \"and no algorithm has been configured for the client (using param id_token_signed_response_alg`.\"\n        )\n    elif (\n        client.id_token_signed_response_alg is not None\n        and id_token.alg != client.id_token_signed_response_alg\n    ):\n        raise MismatchingIdTokenAlg(id_token.alg, client.id_token_signed_response_alg)\n\n    id_token_alg = id_token.alg or client.id_token_signed_response_alg\n\n    if azr.issuer:\n        if id_token.issuer != azr.issuer:\n            raise MismatchingIssuer(id_token.issuer, azr.issuer, self)\n\n    if id_token.audiences and client.client_id not in id_token.audiences:\n        raise MismatchingAudience(id_token.audiences, client.client_id, self)\n\n    if id_token.get_claim(\"azp\") is not None and id_token.azp != client.client_id:\n        raise MismatchingAzp(id_token.azp, client.client_id, self)\n\n    if id_token.is_expired():\n        raise ExpiredIdToken(id_token)\n\n    if azr.nonce:\n        if id_token.nonce != azr.nonce:\n            raise MismatchingNonce()\n\n    if azr.acr_values:\n        if id_token.acr not in azr.acr_values:\n            raise MismatchingAcr(id_token.acr, azr.acr_values)\n\n    hash_function: Callable[[str], str]  # method used to calculate at_hash, s_hash, etc.\n\n    if id_token_alg in jwskate.SignatureAlgs.ALL_SYMMETRIC:\n        if not client.client_secret:\n            raise InvalidIdToken(\n                \"ID Token is symmetrically signed but this client does not have a Client Secret.\"\n            )\n        id_token.verify_signature(\n            jwskate.SymmetricJwk.from_bytes(client.client_secret), alg=id_token_alg\n        )\n    elif id_token_alg in jwskate.SignatureAlgs.ALL_ASYMMETRIC:\n        if not client.authorization_server_jwks:\n            raise InvalidIdToken(\n                \"ID Token is asymmetrically signed but the Authorization Server JWKS is not available.\"\n            )\n\n        if id_token.get_header(\"kid\") is None:\n            raise InvalidIdToken(\n                \"ID Token does not contain a Key ID (kid) to specify the asymmetric key to use for signature verification.\"\n            )\n        try:\n            verification_jwk = client.authorization_server_jwks.get_jwk_by_kid(id_token.kid)\n        except KeyError:\n            raise InvalidIdToken(\n                \"ID Token is asymmetrically signed but its Key ID is not part of the Authorization Server JWKS.\"\n            )\n\n        if id_token_alg not in verification_jwk.supported_signing_algorithms():\n            raise InvalidIdToken(\n                \"ID Token is asymmetrically signed but its algorithm is not supported by the verification key.\"\n            )\n\n        id_token.verify_signature(verification_jwk, alg=id_token_alg)\n\n        alg_class = jwskate.select_alg_class(\n            verification_jwk.SIGNATURE_ALGORITHMS, jwk_alg=id_token_alg\n        )\n        if alg_class == jwskate.EdDsa:\n            if verification_jwk.crv == \"Ed25519\":\n                hash_function = (\n                    lambda token: BinaPy(token).to(\"sha512\")[:32].to(\"b64u\").ascii()\n                )\n            elif verification_jwk.crv == \"Ed448\":\n                hash_function = (\n                    lambda token: BinaPy(token).to(\"shake256\", 456).to(\"b64u\").ascii()\n                )\n        else:\n            hash_alg = alg_class.hashing_alg.name\n            hash_size = alg_class.hashing_alg.digest_size\n            hash_function = (\n                lambda token: BinaPy(token)\n                .to(hash_alg)[: hash_size // 2]\n                .to(\"b64u\")\n                .ascii()\n            )\n\n    at_hash = id_token.get_claim(\"at_hash\")\n    if at_hash is not None:\n        expected_at_hash = hash_function(self.access_token)\n        if expected_at_hash != at_hash:\n            raise InvalidIdToken(\n                f\"Mismatching 'at_hash' value: expected '{expected_at_hash}', got '{at_hash}'\"\n            )\n\n    c_hash = id_token.get_claim(\"c_hash\")\n    if c_hash is not None:\n        expected_c_hash = hash_function(azr.code)\n        if expected_c_hash != c_hash:\n            raise InvalidIdToken(\n                f\"Mismatching 'c_hash' value: expected '{expected_c_hash}', got '{c_hash}'\"\n            )\n\n    s_hash = id_token.get_claim(\"s_hash\")\n    if s_hash is not None:\n        if azr.state is None:\n            raise InvalidIdToken(\n                \"ID Token has a 's_hash' claim but no state was included in the request.\"\n            )\n        expected_s_hash = hash_function(azr.state)\n        if expected_s_hash != s_hash:\n            raise InvalidIdToken(\n                f\"Mismatching 's_hash' value (expected '{expected_s_hash}', got '{s_hash}'\"\n            )\n\n    if azr.max_age is not None:\n        try:\n            auth_time = id_token.auth_time\n        except AttributeError:\n            raise InvalidIdToken(\n                \"A `max_age` parameter was included in the authorization request, \"\n                \"but the ID Token does not contain an `auth_time` claim.\"\n            )\n        auth_age = datetime.now(tz=timezone.utc) - auth_time\n        if auth_age.seconds &gt; azr.max_age + 60:\n            raise InvalidIdToken(\n                \"User authentication happened too long ago. \"\n                \"The `auth_time` parameter from the ID Token indicate that the last Authentication Time \"\n                f\"was at {auth_time} ({auth_age.seconds} sec ago), but the authorization request `max_age` \"\n                f\"parameter specified that it must be maximum {azr.max_age} sec ago.\"\n            )\n\n    return id_token\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerToken.as_dict","title":"<code>as_dict(expires_at=False)</code>","text":"<p>Return all attributes from this BearerToken as a <code>dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expires_at</code> <code>bool</code> <p>if <code>True</code>, the dict will contain an extra <code>expires_at</code> field with the token expiration date.</p> <code>False</code> <p>Returns     a <code>dict</code> containing this BearerToken attributes.</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def as_dict(self, expires_at: bool = False) -&gt; Dict[str, Any]:\n\"\"\"Return all attributes from this BearerToken as a `dict`.\n\n    Args:\n        expires_at: if `True`, the dict will contain an extra `expires_at` field with the token expiration date.\n\n    Returns\n        a `dict` containing this BearerToken attributes.\n    \"\"\"\n    r: Dict[str, Any] = {\n        \"access_token\": self.access_token,\n        \"token_type\": self.TOKEN_TYPE,\n    }\n    if self.expires_at:\n        r[\"expires_in\"] = self.expires_in\n        if expires_at:\n            r[\"expires_at\"] = self.expires_at\n    if self.scope:\n        r[\"scope\"] = self.scope\n    if self.refresh_token:\n        r[\"refresh_token\"] = self.refresh_token\n    if self.id_token:\n        r[\"id_token\"] = str(self.id_token)\n    if self.other:\n        r.update(self.other)\n    return r\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer","title":"<code>BearerTokenSerializer</code>","text":"<p>A helper class to serialize Token Response returned by an AS.</p> <p>This may be used to store BearerTokens in session or cookies.</p> <p>It needs a <code>dumper</code> and a <code>loader</code> functions that will respectively serialize and deserialize BearerTokens. Default implementations are provided with use gzip and base64url on the serialized JSON representation.</p> <p>Parameters:</p> Name Type Description Default <code>dumper</code> <code>Optional[Callable[[BearerToken], str]]</code> <p>a function to serialize a token into a <code>str</code>.</p> <code>None</code> <code>loader</code> <code>Optional[Callable[[str], BearerToken]]</code> <p>a function do deserialize a serialized token representation.</p> <code>None</code> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>class BearerTokenSerializer:\n\"\"\"A helper class to serialize Token Response returned by an AS.\n\n    This may be used to store BearerTokens in session or cookies.\n\n    It needs a `dumper` and a `loader` functions that will respectively serialize and deserialize BearerTokens.\n    Default implementations are provided with use gzip and base64url on the serialized JSON representation.\n\n    Args:\n        dumper: a function to serialize a token into a `str`.\n        loader: a function do deserialize a serialized token representation.\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Optional[Callable[[BearerToken], str]] = None,\n        loader: Optional[Callable[[str], BearerToken]] = None,\n    ):\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(token: BearerToken) -&gt; str:\n\"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n        Args:\n            token: the `BearerToken` to serialize\n\n        Returns:\n            the serialized value\n        \"\"\"\n        return BinaPy.serialize_to(\"json\", token.as_dict(True)).to(\"deflate\").to(\"b64u\").ascii()\n\n    def default_loader(\n        self, serialized: str, token_class: Type[BearerToken] = BearerToken\n    ) -&gt; BearerToken:\n\"\"\"Deserialize a BearerToken.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            a BearerToken\n        \"\"\"\n        attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        expires_at = attrs.get(\"expires_at\")\n        if expires_at:\n            attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at)\n        return token_class(**attrs)\n\n    def dumps(self, token: BearerToken) -&gt; str:\n\"\"\"Serialize and compress a given token for easier storage.\n\n        Args:\n            token: a BearerToken to serialize\n\n        Returns:\n            the serialized token, as a str\n        \"\"\"\n        return self.dumper(token)\n\n    def loads(self, serialized: str) -&gt; BearerToken:\n\"\"\"Deserialize a serialized token.\n\n        Args:\n            serialized: the serialized token\n\n        Returns:\n            the deserialized token\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_dumper","title":"<code>default_dumper(token)</code>  <code>staticmethod</code>","text":"<p>Serialize a token as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>the <code>BearerToken</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>@staticmethod\ndef default_dumper(token: BearerToken) -&gt; str:\n\"\"\"Serialize a token as JSON, then compress with deflate, then encodes as base64url.\n\n    Args:\n        token: the `BearerToken` to serialize\n\n    Returns:\n        the serialized value\n    \"\"\"\n    return BinaPy.serialize_to(\"json\", token.as_dict(True)).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.default_loader","title":"<code>default_loader(serialized, token_class=BearerToken)</code>","text":"<p>Deserialize a BearerToken.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def default_loader(\n    self, serialized: str, token_class: Type[BearerToken] = BearerToken\n) -&gt; BearerToken:\n\"\"\"Deserialize a BearerToken.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        a BearerToken\n    \"\"\"\n    attrs = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    expires_at = attrs.get(\"expires_at\")\n    if expires_at:\n        attrs[\"expires_at\"] = datetime.fromtimestamp(expires_at)\n    return token_class(**attrs)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.dumps","title":"<code>dumps(token)</code>","text":"<p>Serialize and compress a given token for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>BearerToken</code> <p>a BearerToken to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized token, as a str</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def dumps(self, token: BearerToken) -&gt; str:\n\"\"\"Serialize and compress a given token for easier storage.\n\n    Args:\n        token: a BearerToken to serialize\n\n    Returns:\n        the serialized token, as a str\n    \"\"\"\n    return self.dumper(token)\n</code></pre>"},{"location":"api/#requests_oauth2client.tokens.BearerTokenSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized token.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized token</p> required <p>Returns:</p> Type Description <code>BearerToken</code> <p>the deserialized token</p> Source code in <code>requests_oauth2client/tokens.py</code> <pre><code>def loads(self, serialized: str) -&gt; BearerToken:\n\"\"\"Deserialize a serialized token.\n\n    Args:\n        serialized: the serialized token\n\n    Returns:\n        the deserialized token\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client","title":"<code>api_client</code>","text":"<p>ApiClient main module.</p>"},{"location":"api/#requests_oauth2client.api_client.ApiClient","title":"<code>ApiClient</code>","text":"<p>A Wrapper around requests.Session with extra features for Rest API calls.</p> <p>Additional features compared to requests.Session:</p> <ul> <li>Allows setting a root url at creation time, then passing relative urls at request time.</li> <li>It may also raise exceptions instead of returning error responses.</li> <li>You can also pass additional kwargs at init time, which will be used to configure the Session, instead of setting them later.</li> <li>for parameters passed as <code>json</code>, <code>params</code> or <code>data</code>, values that are <code>None</code> can be automatically discarded from the request</li> <li>boolean values in <code>data</code> or <code>params</code> fields can be serialized to values that are suitable for the target API, like <code>\"true\"</code> or <code>\"false\"</code>, or <code>\"1\"</code> / <code>\"0\"</code>, instead of the default values <code>\"True\"</code> or <code>\"False\"</code>.</li> </ul> <p><code>base_url</code> will serve as root for relative urls passed to ApiClient.request(), ApiClient.get(), etc. An <code>HTTPError</code> will be raised everytime an API call returns an error code (&gt;= 400), unless you set <code>raise_for_status</code> to <code>False</code>. Additional parameters passed at init time, including <code>auth</code> will be used to configure the Session.</p> Usage <pre><code>from requests_oauth2client import ApiClient\n\napi = ApiClient(\"https://myapi.local/resource\", timeout=10)\nresp = api.get(\"/myid\")  # this will send a GET request\n# to https://myapi.local/resource/myid\n\n# you can pass an underlying requests.Session at init time\nsession = requests.Session()\nsession.proxies = {\"https\": \"https://localhost:3128\"}\napi = ApiClient(\"https://myapi.local/resource\", session=session)\n\n# or you can let ApiClient init it's own session and provide additional configuration parameters:\napi = ApiClient(\n    \"https://myapi.local/resource\", proxies={\"https\": \"https://localhost:3128\"}\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>Optional[str]</code> <p>the base api url, that should be root for all the target API endpoints.</p> <code>None</code> <code>auth</code> <code>Optional[requests.auth.AuthBase]</code> <p>the requests.auth.AuthBase to use as authentication handler.</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>the default timeout, in seconds, to use for each request from this ApiClient. Can be set to <code>None</code> to disable timeout.</p> <code>60</code> <code>raise_for_status</code> <code>bool</code> <p>if <code>True</code>, exceptions will be raised everytime a request returns an error code (&gt;= 400).</p> <code>True</code> <code>none_fields</code> <code>Literal['include', 'exclude', 'empty']</code> <p>if <code>\"exclude\"</code> (default), <code>data</code> or <code>json</code> fields whose values are <code>None</code> are not included in the request. If <code>\"include\"</code>, they are included with string value <code>None</code> (this is the default behavior of <code>requests</code>). If \"empty\", they are included with an empty value (as an empty string).</p> <code>'exclude'</code> <code>bool_fields</code> <code>Optional[Tuple[Any, Any]]</code> <p>a tuple of (true_value, false_value). Fields from <code>data</code> or <code>params</code> with a boolean value (<code>True</code> or <code>False</code>) will be serialized to the corresponding value. This can be useful since some APIs expect a <code>'true'</code> or <code>'false'</code> value as boolean, and requests serialises <code>True</code> to <code>'True'</code> and <code>False</code> to <code>'False'</code>. Set it to <code>None</code> to restore default requests behaviour.</p> <code>('true', 'false')</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to configure this session. This parameter may be overridden at request time.</p> <code>{}</code> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>class ApiClient:\n\"\"\"A Wrapper around [requests.Session][] with extra features for Rest API calls.\n\n    Additional features compared to [requests.Session][]:\n\n    - Allows setting a root url at creation time, then passing relative urls at request time.\n    - It may also raise exceptions instead of returning error responses.\n    - You can also pass additional kwargs at init time, which will be used to configure the [Session][requests.Session],\n    instead of setting them later.\n    - for parameters passed as `json`, `params` or `data`, values that are `None` can be automatically discarded from the request\n    - boolean values in `data` or `params` fields can be serialized to values that are suitable for the target API, like `\"true\"` or `\"false\"`, or `\"1\"` / `\"0\"`, instead of the default values `\"True\"` or `\"False\"`.\n\n    `base_url` will serve as root for relative urls passed to [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request], [ApiClient.get()][requests_oauth2client.api_client.ApiClient.get], etc.\n    An `HTTPError` will be raised everytime an API call returns an error code (&gt;= 400), unless you set `raise_for_status` to `False`.\n    Additional parameters passed at init time, including `auth` will be used to configure the [Session][requests.Session].\n\n    Usage:\n        ```python\n        from requests_oauth2client import ApiClient\n\n        api = ApiClient(\"https://myapi.local/resource\", timeout=10)\n        resp = api.get(\"/myid\")  # this will send a GET request\n        # to https://myapi.local/resource/myid\n\n        # you can pass an underlying requests.Session at init time\n        session = requests.Session()\n        session.proxies = {\"https\": \"https://localhost:3128\"}\n        api = ApiClient(\"https://myapi.local/resource\", session=session)\n\n        # or you can let ApiClient init it's own session and provide additional configuration parameters:\n        api = ApiClient(\n            \"https://myapi.local/resource\", proxies={\"https\": \"https://localhost:3128\"}\n        )\n        ```\n\n    Args:\n        base_url: the base api url, that should be root for all the target API endpoints.\n        auth: the [requests.auth.AuthBase][] to use as authentication handler.\n        timeout: the default timeout, in seconds, to use for each request from this ApiClient. Can be set to `None` to disable timeout.\n        raise_for_status: if `True`, exceptions will be raised everytime a request returns an error code (&gt;= 400).\n        none_fields: if `\"exclude\"` (default), `data` or `json` fields whose values are `None` are not included in the request. If `\"include\"`, they are included with string value `None` (this is the default behavior of `requests`). If \"empty\", they are included with an empty value (as an empty string).\n        bool_fields: a tuple of (true_value, false_value). Fields from `data` or `params` with a boolean value (`True` or `False`) will be serialized to the corresponding value. This can be useful since some APIs expect a `'true'` or `'false'` value as boolean, and requests serialises `True` to `'True'` and `False` to `'False'`. Set it to `None` to restore default requests behaviour.\n        **kwargs: additional kwargs to configure this session. This parameter may be overridden at request time.\n    \"\"\"\n\n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        auth: Optional[requests.auth.AuthBase] = None,\n        timeout: Optional[int] = 60,\n        raise_for_status: bool = True,\n        none_fields: Literal[\"include\", \"exclude\", \"empty\"] = \"exclude\",\n        bool_fields: Optional[Tuple[Any, Any]] = (\"true\", \"false\"),\n        session: Optional[requests.Session] = None,\n        **kwargs: Any,\n    ):\n        super(ApiClient, self).__init__()\n\n        self.base_url = base_url\n        self.raise_for_status = raise_for_status\n        self.none_fields = none_fields\n        self.bool_fields = bool_fields if bool_fields is not None else (True, False)\n        self.timeout = timeout\n\n        self.session = session or requests.Session()\n        self.session.auth = auth\n\n        for key, val in kwargs.items():\n            setattr(self.session, key, val)\n\n    def request(  # noqa: C901\n        self,\n        method: str,\n        url: Union[None, str, bytes, Iterable[Union[str, bytes, int]]] = None,\n        params: Union[None, bytes, MutableMapping[str, str]] = None,\n        data: Union[\n            Iterable[bytes],\n            str,\n            bytes,\n            List[Tuple[Any, Any]],\n            Tuple[Tuple[Any, Any], ...],\n            Mapping[Any, Any],\n            None,\n        ] = None,\n        headers: Optional[MutableMapping[str, str]] = None,\n        cookies: Union[None, RequestsCookieJar, MutableMapping[str, str]] = None,\n        files: Optional[MutableMapping[str, IO[Any]]] = None,\n        auth: Union[\n            None,\n            Tuple[str, str],\n            requests.auth.AuthBase,\n            Callable[[requests.PreparedRequest], requests.PreparedRequest],\n        ] = None,\n        timeout: Union[None, float, Tuple[float, float], Tuple[float, None]] = None,\n        allow_redirects: bool = False,\n        proxies: Optional[MutableMapping[str, str]] = None,\n        hooks: Optional[\n            MutableMapping[\n                str,\n                Union[\n                    Iterable[Callable[[requests.Response], Any]],\n                    Callable[[requests.Response], Any],\n                ],\n            ]\n        ] = None,\n        stream: Optional[bool] = None,\n        verify: Optional[Union[str, bool]] = None,\n        cert: Optional[Union[str, Tuple[str, str]]] = None,\n        json: Optional[Mapping[str, Any]] = None,\n        raise_for_status: Optional[bool] = None,\n        none_fields: Optional[Literal[\"include\", \"exclude\", \"empty\"]] = None,\n        bool_fields: Optional[Tuple[Any, Any]] = None,\n    ) -&gt; requests.Response:\n\"\"\"Overridden `request` method with extra features.\n\n        Features added compared to plain request():\n        - it can handle a relative path instead of a full url, which will be appended to the base_url\n        - it can raise an exception when the API returns a non-success status code\n        - allow_redirects is False by default (API usually don't use redirects)\n        - `data` or `json` fields with value `None` can either be included or excluded from the request\n        - boolean fields can be serialized to `'true'` or `'false'` instead of `'True'` and `'False'`\n\n        Args:\n          method: the HTTP method to use\n          url: the url where the request will be sent to. Can be a path instead of a full url; that path will be\n        joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url.\n          raise_for_status: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only.\n          none_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only.\n          bool_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only.\n\n        Returns:\n          a [requests.Response][] as returned by requests\n        \"\"\"\n        url = self.to_absolute_url(url)\n\n        if none_fields is None:\n            none_fields = self.none_fields\n\n        if none_fields == \"exclude\":\n            if isinstance(data, Mapping):\n                data = {key: val for key, val in data.items() if val is not None}\n            if isinstance(json, Mapping):\n                json = {key: val for key, val in json.items() if val is not None}\n        elif none_fields == \"empty\":\n            if isinstance(data, Mapping):\n                data = {key: val if val is not None else \"\" for key, val in data.items()}\n            if isinstance(json, Mapping):\n                json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n        if bool_fields is None:\n            bool_fields = self.bool_fields\n\n        if bool_fields:\n            try:\n                true_value, false_value = bool_fields\n            except ValueError:\n                raise ValueError(\n                    \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\"\n                )\n            if isinstance(data, MutableMapping):\n                for key, val in data.items():\n                    if val is True:\n                        data[key] = true_value\n                    elif val is False:\n                        data[key] = false_value\n            if isinstance(params, MutableMapping):\n                for key, val in params.items():\n                    if val is True:\n                        params[key] = true_value\n                    elif val is False:\n                        params[key] = false_value\n\n        timeout = timeout or self.timeout\n\n        response = self.session.request(\n            method,\n            url,\n            params=params,\n            data=data,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            hooks=hooks,\n            stream=stream,\n            verify=verify,\n            cert=cert,\n            json=json,\n        )\n\n        if raise_for_status is None:\n            raise_for_status = self.raise_for_status\n        if raise_for_status:\n            response.raise_for_status()\n        return response\n\n    def to_absolute_url(\n        self, relative_url: Union[None, str, bytes, Iterable[Union[str, bytes, int]]] = None\n    ) -&gt; str:\n\"\"\"Convert a relative url to an absolute url.\n\n        Given a `relative_url`, return the matching absolute url, based on the `base_url` that is configured for this API.\n\n        The result of this methods is different from a standard `urljoin()`, because a relative_url that starts with a \"/\"\n        will not override the path from the base url.\n        You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be\n        `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or any other type (which will be converted to `str` first, using the `str() function`).\n        See the table below for examples results which would exhibit most cases:\n\n        | base_url                  | relative_url                | result_url                                |\n        |---------------------------|-----------------------------|-------------------------------------------|\n        | \"https://myhost.com/root\" | \"/path\"                     | \"https://myhost.com/root/path\"            |\n        | \"https://myhost.com/root\" | \"/path\"                     | \"https://myhost.com/root/path\"            |\n        | \"https://myhost.com/root\" | b\"/path\"                    | \"https://myhost.com/root/path\"            |\n        | \"https://myhost.com/root\" | \"path\"                      | \"https://myhost.com/root/path\"            |\n        | \"https://myhost.com/root\" | None                        | \"https://myhost.com/root\"                 |\n        | \"https://myhost.com/root\" | (\"user\", 1, \"resource\")     | \"https://myhost.com/root/user/1/resource\" |\n        | \"https://myhost.com/root\" | \"https://otherhost.org/foo\" | \"https://otherhost.org/foo\"               |\n\n        Args:\n          relative_url: a relative url\n\n        Returns:\n          the resulting absolute url\n        \"\"\"\n        url = relative_url\n\n        if self.base_url:\n            if url is not None:\n                if not isinstance(url, (str, bytes)):\n                    try:\n                        url = \"/\".join(\n                            [\n                                urlencode(\n                                    part.decode() if isinstance(part, bytes) else str(part)\n                                )\n                                for part in url\n                                if part\n                            ]\n                        )\n                    except TypeError:\n                        raise TypeError(\n                            \"Unexpected url type, please pass a relative path as string or bytes, \"\n                            \"or an iterable of string-able objects\",\n                            type(url),\n                        )\n\n                if isinstance(url, bytes):\n                    url = url.decode()\n\n                url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n            else:\n                url = self.base_url\n\n        if url is None or not isinstance(url, str):\n            raise ValueError(\"Unable to determine an absolute url.\")\n\n        return url\n\n    def get(\n        self,\n        url: Union[None, str, bytes, Iterable[Union[str, bytes, int]]] = None,\n        raise_for_status: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n\"\"\"Send a GET request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n            url: a url where the request will be sent.\n            raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n            **kwargs: Optional arguments that [request()][requests.request] takes.\n\n        Returns:\n            a [Response][requests.Response] object.\n\n        Raises:\n            requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n                and an error response is returned.\n        \"\"\"\n        return self.request(\"GET\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def post(\n        self,\n        url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n        raise_for_status: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n\"\"\"Send a POST request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: Optional arguments that ``request`` takes.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n        \"\"\"\n        return self.request(\"POST\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def patch(\n        self,\n        url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n        raise_for_status: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n\"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: Optional arguments that ``request`` takes.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n        \"\"\"\n        return self.request(\"PATCH\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def put(\n        self,\n        url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n        raise_for_status: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n\"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n        \"\"\"\n        return self.request(\"PUT\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def delete(\n        self,\n        url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n        raise_for_status: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; requests.Response:\n\"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n        The passed `url` may be relative to the url passed at initialization time.\n        It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n        Args:\n          url: a url where the request will be sent.\n          raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n          **kwargs: additional kwargs for `requests.request()`.\n\n        Returns:\n          a [Response][requests.Response] object.\n\n        Raises:\n          requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n        \"\"\"\n        return self.request(\"DELETE\", url, raise_for_status=raise_for_status, **kwargs)\n\n    def __getattr__(self, item: str) -&gt; ApiClient:\n\"\"\"Allow access sub resources with an attribute-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new ApiClient initialised on the new base url\n\n        Usage:\n            ```python\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api.resource1.get()  # GET https://myapi.local/resource1\n            resource2 = api.resource2.get()  # GET https://myapi.local/resource2\n            ```\n        \"\"\"\n        return self[item]\n\n    def __getitem__(self, item: str) -&gt; ApiClient:\n\"\"\"Allow access to sub resources with a subscription-based syntax.\n\n        Args:\n            item: a subpath\n\n        Returns:\n            a new ApiClient initialised on the new base url\n\n        Usage:\n            ```python\n            api = ApiClient(\"https://myapi.local\")\n            resource1 = api[\"resource1\"].get()  # GET https://myapi.local/resource1\n            resource2 = api[\"resource2\"].get()  # GET https://myapi.local/resource2\n            ```\n        \"\"\"\n        new_base_uri = self.to_absolute_url(item)\n        return ApiClient(\n            new_base_uri,\n            session=self.session,\n            none_fields=self.none_fields,\n            bool_fields=self.bool_fields,\n            timeout=self.timeout,\n            raise_for_status=self.raise_for_status,\n        )\n\n    def __enter__(self) -&gt; ApiClient:\n\"\"\"Allow `ApiClient` to act as a context manager.\n\n        You can then use an `ApiClient` instance in a `with` clause, the same way as `requests.Session`.\n        The underlying request.Session will be closed on exit.\n\n        Usage:\n            ```python\n            with ApiClient(\"https://myapi.com/path\") as client:\n                resp = client.get(\"resource\")\n            ```\n        \"\"\"\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n\"\"\"Close the underlying requests.Session on exit.\"\"\"\n        self.session.close()\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.request","title":"<code>request(method, url=None, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=False, proxies=None, hooks=None, stream=None, verify=None, cert=None, json=None, raise_for_status=None, none_fields=None, bool_fields=None)</code>","text":"<p>Overridden <code>request</code> method with extra features.</p> <p>Features added compared to plain request(): - it can handle a relative path instead of a full url, which will be appended to the base_url - it can raise an exception when the API returns a non-success status code - allow_redirects is False by default (API usually don't use redirects) - <code>data</code> or <code>json</code> fields with value <code>None</code> can either be included or excluded from the request - boolean fields can be serialized to <code>'true'</code> or <code>'false'</code> instead of <code>'True'</code> and <code>'False'</code></p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the HTTP method to use</p> required <code>url</code> <code>Union[None, str, bytes, Iterable[Union[str, bytes, int]]]</code> <p>the url where the request will be sent to. Can be a path instead of a full url; that path will be</p> <code>None</code> <p>joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url.   raise_for_status: like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.   none_fields: like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.   bool_fields: like the parameter of the same name from <code>ApiClient.__init__</code>, but this will be applied for this request only.</p> <p>Returns:</p> Type Description <code>requests.Response</code> <p>a requests.Response as returned by requests</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def request(  # noqa: C901\n    self,\n    method: str,\n    url: Union[None, str, bytes, Iterable[Union[str, bytes, int]]] = None,\n    params: Union[None, bytes, MutableMapping[str, str]] = None,\n    data: Union[\n        Iterable[bytes],\n        str,\n        bytes,\n        List[Tuple[Any, Any]],\n        Tuple[Tuple[Any, Any], ...],\n        Mapping[Any, Any],\n        None,\n    ] = None,\n    headers: Optional[MutableMapping[str, str]] = None,\n    cookies: Union[None, RequestsCookieJar, MutableMapping[str, str]] = None,\n    files: Optional[MutableMapping[str, IO[Any]]] = None,\n    auth: Union[\n        None,\n        Tuple[str, str],\n        requests.auth.AuthBase,\n        Callable[[requests.PreparedRequest], requests.PreparedRequest],\n    ] = None,\n    timeout: Union[None, float, Tuple[float, float], Tuple[float, None]] = None,\n    allow_redirects: bool = False,\n    proxies: Optional[MutableMapping[str, str]] = None,\n    hooks: Optional[\n        MutableMapping[\n            str,\n            Union[\n                Iterable[Callable[[requests.Response], Any]],\n                Callable[[requests.Response], Any],\n            ],\n        ]\n    ] = None,\n    stream: Optional[bool] = None,\n    verify: Optional[Union[str, bool]] = None,\n    cert: Optional[Union[str, Tuple[str, str]]] = None,\n    json: Optional[Mapping[str, Any]] = None,\n    raise_for_status: Optional[bool] = None,\n    none_fields: Optional[Literal[\"include\", \"exclude\", \"empty\"]] = None,\n    bool_fields: Optional[Tuple[Any, Any]] = None,\n) -&gt; requests.Response:\n\"\"\"Overridden `request` method with extra features.\n\n    Features added compared to plain request():\n    - it can handle a relative path instead of a full url, which will be appended to the base_url\n    - it can raise an exception when the API returns a non-success status code\n    - allow_redirects is False by default (API usually don't use redirects)\n    - `data` or `json` fields with value `None` can either be included or excluded from the request\n    - boolean fields can be serialized to `'true'` or `'false'` instead of `'True'` and `'False'`\n\n    Args:\n      method: the HTTP method to use\n      url: the url where the request will be sent to. Can be a path instead of a full url; that path will be\n    joined to the configured API url. Can also be an iterable of path segments, that will be joined to the root url.\n      raise_for_status: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only.\n      none_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only.\n      bool_fields: like the parameter of the same name from `ApiClient.__init__`, but this will be applied for this request only.\n\n    Returns:\n      a [requests.Response][] as returned by requests\n    \"\"\"\n    url = self.to_absolute_url(url)\n\n    if none_fields is None:\n        none_fields = self.none_fields\n\n    if none_fields == \"exclude\":\n        if isinstance(data, Mapping):\n            data = {key: val for key, val in data.items() if val is not None}\n        if isinstance(json, Mapping):\n            json = {key: val for key, val in json.items() if val is not None}\n    elif none_fields == \"empty\":\n        if isinstance(data, Mapping):\n            data = {key: val if val is not None else \"\" for key, val in data.items()}\n        if isinstance(json, Mapping):\n            json = {key: val if val is not None else \"\" for key, val in json.items()}\n\n    if bool_fields is None:\n        bool_fields = self.bool_fields\n\n    if bool_fields:\n        try:\n            true_value, false_value = bool_fields\n        except ValueError:\n            raise ValueError(\n                \"Invalid value for 'bool_fields'. Must be a 2 value tuple, with (true_value, false_value).\"\n            )\n        if isinstance(data, MutableMapping):\n            for key, val in data.items():\n                if val is True:\n                    data[key] = true_value\n                elif val is False:\n                    data[key] = false_value\n        if isinstance(params, MutableMapping):\n            for key, val in params.items():\n                if val is True:\n                    params[key] = true_value\n                elif val is False:\n                    params[key] = false_value\n\n    timeout = timeout or self.timeout\n\n    response = self.session.request(\n        method,\n        url,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        stream=stream,\n        verify=verify,\n        cert=cert,\n        json=json,\n    )\n\n    if raise_for_status is None:\n        raise_for_status = self.raise_for_status\n    if raise_for_status:\n        response.raise_for_status()\n    return response\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.to_absolute_url","title":"<code>to_absolute_url(relative_url=None)</code>","text":"<p>Convert a relative url to an absolute url.</p> <p>Given a <code>relative_url</code>, return the matching absolute url, based on the <code>base_url</code> that is configured for this API.</p> <p>The result of this methods is different from a standard <code>urljoin()</code>, because a relative_url that starts with a \"/\" will not override the path from the base url. You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be <code>str</code> (which will be urlencoded) or <code>bytes</code> (which will be decoded as UTF-8 first) or any other type (which will be converted to <code>str</code> first, using the <code>str() function</code>). See the table below for examples results which would exhibit most cases:</p> base_url relative_url result_url \"https://myhost.com/root\" \"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" \"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" b\"/path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" \"path\" \"https://myhost.com/root/path\" \"https://myhost.com/root\" None \"https://myhost.com/root\" \"https://myhost.com/root\" (\"user\", 1, \"resource\") \"https://myhost.com/root/user/1/resource\" \"https://myhost.com/root\" \"https://otherhost.org/foo\" \"https://otherhost.org/foo\" <p>Parameters:</p> Name Type Description Default <code>relative_url</code> <code>Union[None, str, bytes, Iterable[Union[str, bytes, int]]]</code> <p>a relative url</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the resulting absolute url</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def to_absolute_url(\n    self, relative_url: Union[None, str, bytes, Iterable[Union[str, bytes, int]]] = None\n) -&gt; str:\n\"\"\"Convert a relative url to an absolute url.\n\n    Given a `relative_url`, return the matching absolute url, based on the `base_url` that is configured for this API.\n\n    The result of this methods is different from a standard `urljoin()`, because a relative_url that starts with a \"/\"\n    will not override the path from the base url.\n    You can also pass an iterable of path parts as relative url, which will be properly joined with \"/\". Those parts may be\n    `str` (which will be urlencoded) or `bytes` (which will be decoded as UTF-8 first) or any other type (which will be converted to `str` first, using the `str() function`).\n    See the table below for examples results which would exhibit most cases:\n\n    | base_url                  | relative_url                | result_url                                |\n    |---------------------------|-----------------------------|-------------------------------------------|\n    | \"https://myhost.com/root\" | \"/path\"                     | \"https://myhost.com/root/path\"            |\n    | \"https://myhost.com/root\" | \"/path\"                     | \"https://myhost.com/root/path\"            |\n    | \"https://myhost.com/root\" | b\"/path\"                    | \"https://myhost.com/root/path\"            |\n    | \"https://myhost.com/root\" | \"path\"                      | \"https://myhost.com/root/path\"            |\n    | \"https://myhost.com/root\" | None                        | \"https://myhost.com/root\"                 |\n    | \"https://myhost.com/root\" | (\"user\", 1, \"resource\")     | \"https://myhost.com/root/user/1/resource\" |\n    | \"https://myhost.com/root\" | \"https://otherhost.org/foo\" | \"https://otherhost.org/foo\"               |\n\n    Args:\n      relative_url: a relative url\n\n    Returns:\n      the resulting absolute url\n    \"\"\"\n    url = relative_url\n\n    if self.base_url:\n        if url is not None:\n            if not isinstance(url, (str, bytes)):\n                try:\n                    url = \"/\".join(\n                        [\n                            urlencode(\n                                part.decode() if isinstance(part, bytes) else str(part)\n                            )\n                            for part in url\n                            if part\n                        ]\n                    )\n                except TypeError:\n                    raise TypeError(\n                        \"Unexpected url type, please pass a relative path as string or bytes, \"\n                        \"or an iterable of string-able objects\",\n                        type(url),\n                    )\n\n            if isinstance(url, bytes):\n                url = url.decode()\n\n            url = urljoin(self.base_url + \"/\", url.lstrip(\"/\"))\n        else:\n            url = self.base_url\n\n    if url is None or not isinstance(url, str):\n        raise ValueError(\"Unable to determine an absolute url.\")\n\n    return url\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.get","title":"<code>get(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a GET request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[None, str, bytes, Iterable[Union[str, bytes, int]]]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>Optional[bool]</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that request() takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>requests.HTTPError</code> <p>if <code>raises_for_status</code> is True (in this request or at initialization time) and an error response is returned. and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def get(\n    self,\n    url: Union[None, str, bytes, Iterable[Union[str, bytes, int]]] = None,\n    raise_for_status: Optional[bool] = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n\"\"\"Send a GET request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n        url: a url where the request will be sent.\n        raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n        **kwargs: Optional arguments that [request()][requests.request] takes.\n\n    Returns:\n        a [Response][requests.Response] object.\n\n    Raises:\n        requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n            and an error response is returned.\n    \"\"\"\n    return self.request(\"GET\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.post","title":"<code>post(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a POST request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[Union[str, bytes, Iterable[Union[str, bytes]]]]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>Optional[bool]</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that <code>request</code> takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>requests.HTTPError</code> <p>if <code>raises_for_status</code> is True (in this request or at initialization time) and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def post(\n    self,\n    url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n    raise_for_status: Optional[bool] = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n\"\"\"Send a POST request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: Optional arguments that ``request`` takes.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n    \"\"\"\n    return self.request(\"POST\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.patch","title":"<code>patch(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PATCH request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[Union[str, bytes, Iterable[Union[str, bytes]]]]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>Optional[bool]</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Optional arguments that <code>request</code> takes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>requests.HTTPError</code> <p>if <code>raises_for_status</code> is True (in this request or at initialization time) and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def patch(\n    self,\n    url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n    raise_for_status: Optional[bool] = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n\"\"\"Send a PATCH request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: Optional arguments that ``request`` takes.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n    \"\"\"\n    return self.request(\"PATCH\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.put","title":"<code>put(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a PUT request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[Union[str, bytes, Iterable[Union[str, bytes]]]]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>Optional[bool]</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>requests.HTTPError</code> <p>if <code>raises_for_status</code> is True (in this request or at initialization time) and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def put(\n    self,\n    url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n    raise_for_status: Optional[bool] = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n\"\"\"Send a PUT request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n    \"\"\"\n    return self.request(\"PUT\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.api_client.ApiClient.delete","title":"<code>delete(url=None, raise_for_status=None, **kwargs)</code>","text":"<p>Send a DELETE request. Return a Response object.</p> <p>The passed <code>url</code> may be relative to the url passed at initialization time. It takes the same parameters as ApiClient.request().</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[Union[str, bytes, Iterable[Union[str, bytes]]]]</code> <p>a url where the request will be sent.</p> <code>None</code> <code>raise_for_status</code> <code>Optional[bool]</code> <p>overrides the <code>raises_for_status</code> parameter passed at initialization time.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs for <code>requests.request()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>a Response object.</p> <p>Raises:</p> Type Description <code>requests.HTTPError</code> <p>if <code>raises_for_status</code> is True (in this request or at initialization time) and an error response is returned.</p> Source code in <code>requests_oauth2client/api_client.py</code> <pre><code>def delete(\n    self,\n    url: Optional[Union[str, bytes, Iterable[Union[str, bytes]]]] = None,\n    raise_for_status: Optional[bool] = None,\n    **kwargs: Any,\n) -&gt; requests.Response:\n\"\"\"Send a DELETE request. Return a [Response][requests.Response] object.\n\n    The passed `url` may be relative to the url passed at initialization time.\n    It takes the same parameters as [ApiClient.request()][requests_oauth2client.api_client.ApiClient.request].\n\n    Args:\n      url: a url where the request will be sent.\n      raise_for_status: overrides the `raises_for_status` parameter passed at initialization time.\n      **kwargs: additional kwargs for `requests.request()`.\n\n    Returns:\n      a [Response][requests.Response] object.\n\n    Raises:\n      requests.HTTPError: if `raises_for_status` is True (in this request or at initialization time) and an error response is returned.\n    \"\"\"\n    return self.request(\"DELETE\", url, raise_for_status=raise_for_status, **kwargs)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication","title":"<code>backchannel_authentication</code>","text":"<p>Implementation of CIBA.</p> <p>CIBA stands for Client Initiated BackChannel Authentication and is standardised by the OpenID Fundation. https://openid.net/specs/openid-client-initiated-backchannel- authentication-core-1_0.html.</p>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse","title":"<code>BackChannelAuthenticationResponse</code>","text":"<p>Represent a BackChannel Authentication Response.</p> <p>This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request, such as <code>auth_req_id</code> (required), and the optional <code>expires_at</code>, <code>interval</code>, and/or any custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>auth_req_id</code> <code>str</code> <p>the <code>auth_req_id</code> as returned by the AS.</p> required <code>expires_at</code> <code>Optional[datetime]</code> <p>the date when the <code>auth_req_id</code> expires. Note that this request also accepts an <code>expires_in</code> parameter, in seconds.</p> <code>None</code> <code>interval</code> <code>Optional[int]</code> <p>the Token Endpoint pooling interval, in seconds, as returned by the AS.</p> <code>20</code> <code>**kwargs</code> <code>Any</code> <p>any additional custom parameters as returned by the AS.</p> <code>{}</code> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationResponse:\n\"\"\"Represent a BackChannel Authentication Response.\n\n    This contains all the parameters that are returned by the AS as a result of a BackChannel Authentication Request,\n    such as `auth_req_id` (required), and the optional `expires_at`, `interval`, and/or any custom parameters.\n\n    Args:\n        auth_req_id: the `auth_req_id` as returned by the AS.\n        expires_at: the date when the `auth_req_id` expires.\n            Note that this request also accepts an `expires_in` parameter, in seconds.\n        interval: the Token Endpoint pooling interval, in seconds, as returned by the AS.\n        **kwargs: any additional custom parameters as returned by the AS.\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        auth_req_id: str,\n        expires_at: Optional[datetime] = None,\n        interval: Optional[int] = 20,\n        **kwargs: Any,\n    ):\n        self.auth_req_id = auth_req_id\n        self.expires_at = expires_at\n        self.interval = interval\n        self.other = kwargs\n\n    def is_expired(self, leeway: int = 0) -&gt; Optional[bool]:\n\"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n        Expiration is evaluated at the time of the call.\n        If there is no \"expires_at\" hint (which is derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint), this will return `None`.\n\n        Returns:\n            `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is no `expires_in` hint.\n        \"\"\"\n        if self.expires_at:\n            return datetime.now() - timedelta(seconds=leeway) &gt; self.expires_at\n        return None\n\n    def __getattr__(self, key: str) -&gt; Any:\n\"\"\"Return attributes from this `BackChannelAuthenticationResponse`.\n\n        Allows accessing response parameters with `token_response.expires_in` or `token_response.any_custom_attribute`.\n\n        Args:\n            key: a key\n\n        Returns:\n            the associated value in this token response\n\n        Raises:\n            AttributeError: if the attribute is not present in the response\n        \"\"\"\n        if key == \"expires_in\":\n            if self.expires_at is None:\n                return None\n            return int(self.expires_at.timestamp() - datetime.now().timestamp())\n        return self.other.get(key) or super().__getattribute__(key)\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationResponse.is_expired","title":"<code>is_expired(leeway=0)</code>","text":"<p>Return <code>True</code> if the <code>auth_req_id</code> within this response is expired.</p> <p>Expiration is evaluated at the time of the call. If there is no \"expires_at\" hint (which is derived from the <code>expires_in</code> hint returned by the AS BackChannel Authentication endpoint), this will return <code>None</code>.</p> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p><code>True</code> if the auth_req_id is expired, <code>False</code> if it is still valid, <code>None</code> if there is no <code>expires_in</code> hint.</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def is_expired(self, leeway: int = 0) -&gt; Optional[bool]:\n\"\"\"Return `True` if the `auth_req_id` within this response is expired.\n\n    Expiration is evaluated at the time of the call.\n    If there is no \"expires_at\" hint (which is derived from the `expires_in` hint returned by the AS BackChannel Authentication endpoint), this will return `None`.\n\n    Returns:\n        `True` if the auth_req_id is expired, `False` if it is still valid, `None` if there is no `expires_in` hint.\n    \"\"\"\n    if self.expires_at:\n        return datetime.now() - timedelta(seconds=leeway) &gt; self.expires_at\n    return None\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob","title":"<code>BackChannelAuthenticationPoolingJob</code>","text":"<p>         Bases: <code>TokenEndpointPoolingJob</code></p> <p>A pooling job for the BackChannel Authentication flow.</p> <p>This will poll the Token Endpoint until the user finishes with its authentication.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to pool the token endpoint.</p> required <code>auth_req_id</code> <code>Union[str, BackChannelAuthenticationResponse]</code> <p>an <code>auth_req_id</code> as <code>str</code> or a <code>BackChannelAuthenticationResponse</code>.</p> required <code>interval</code> <code>Optional[int]</code> <p>The pooling interval to use. This overrides the one in <code>auth_req_id</code> if it is a <code>BackChannelAuthenticationResponse</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>Number of seconds to add to the pooling interval when the AS returns a slow down request.</p> <code>5</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Additional parameters for the underlying calls to requests.request.</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>Additional parameters for the token request.</p> <code>{}</code> Usage <pre><code>client = OAuth2Client(\n    token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")\n)\npool_job = BackChannelAuthenticationPoolingJob(\n    client=client, auth_req_id=\"my_auth_req_id\"\n)\n\ntoken = None\nwhile token is None:\n    token = pool_job()\n</code></pre> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>class BackChannelAuthenticationPoolingJob(TokenEndpointPoolingJob):\n\"\"\"A pooling job for the BackChannel Authentication flow.\n\n    This will poll the Token Endpoint until the user finishes with its authentication.\n\n    Args:\n        client: an OAuth2Client that will be used to pool the token endpoint.\n        auth_req_id: an `auth_req_id` as `str` or a `BackChannelAuthenticationResponse`.\n        interval: The pooling interval to use. This overrides the one in `auth_req_id` if it is a `BackChannelAuthenticationResponse`.\n        slow_down_interval: Number of seconds to add to the pooling interval when the AS returns a slow down request.\n        requests_kwargs: Additional parameters for the underlying calls to [requests.request][].\n        **token_kwargs: Additional parameters for the token request.\n\n    Usage:\n        ```python\n        client = OAuth2Client(\n            token_endpoint=\"https://my.as.local/token\", auth=(\"client_id\", \"client_secret\")\n        )\n        pool_job = BackChannelAuthenticationPoolingJob(\n            client=client, auth_req_id=\"my_auth_req_id\"\n        )\n\n        token = None\n        while token is None:\n            token = pool_job()\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"OAuth2Client\",\n        auth_req_id: Union[str, BackChannelAuthenticationResponse],\n        *,\n        interval: Optional[int] = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ):\n        if isinstance(auth_req_id, BackChannelAuthenticationResponse) and interval is None:\n            interval = auth_req_id.interval\n\n        super().__init__(\n            client=client,\n            interval=interval,\n            slow_down_interval=slow_down_interval,\n            requests_kwargs=requests_kwargs,\n            **token_kwargs,\n        )\n        self.auth_req_id = auth_req_id\n\n    def token_request(self) -&gt; BearerToken:\n\"\"\"Implement the CIBA token request.\n\n        This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n        \"\"\"\n        return self.client.ciba(\n            self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.backchannel_authentication.BackChannelAuthenticationPoolingJob.token_request","title":"<code>token_request()</code>","text":"<p>Implement the CIBA token request.</p> <p>This actually calls [OAuth2Client.ciba(auth_req_id)] on <code>client</code>.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/backchannel_authentication.py</code> <pre><code>def token_request(self) -&gt; BearerToken:\n\"\"\"Implement the CIBA token request.\n\n    This actually calls [OAuth2Client.ciba(auth_req_id)] on `client`.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n    \"\"\"\n    return self.client.ciba(\n        self.auth_req_id, requests_kwargs=self.requests_kwargs, **self.token_kwargs\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery","title":"<code>discovery</code>","text":"<p>Implements Metadata discovery documents URLS.</p> <p>This is as defined in RFC8615 and OpenID Connect Discovery 1.0.</p>"},{"location":"api/#requests_oauth2client.discovery.well_known_uri","title":"<code>well_known_uri(origin, name, at_root=True)</code>","text":"<p>Return the location of a well-known document on an origin url.</p> <p>See RFC8615 and OIDC Discovery.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>origin to use to build the well-known uri.</p> required <code>name</code> <code>str</code> <p>document name to use to build the well-known uri.</p> required <code>at_root</code> <code>bool</code> <p>if <code>True</code>, assume the well-known document is at root level (as defined in RFC8615). If <code>False</code>, assume the well-known location is per-directory, as defined in OpenID Connect Discovery 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>the well-know uri, relative to origin, where the well-known document named <code>name</code> should be found.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def well_known_uri(origin: str, name: str, at_root: bool = True) -&gt; str:\n\"\"\"Return the location of a well-known document on an origin url.\n\n    See [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615) and [OIDC Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        origin: origin to use to build the well-known uri.\n        name: document name to use to build the well-known uri.\n        at_root: if `True`, assume the well-known document is at root level (as defined in [RFC8615](https://datatracker.ietf.org/doc/html/rfc8615)).\n            If `False`, assume the well-known location is per-directory, as defined in [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Returns:\n        the well-know uri, relative to origin, where the well-known document named `name` should be found.\n    \"\"\"\n    url = furl(origin)\n    if at_root:\n        url.path = Path(\".well-known\") / url.path / name\n    else:\n        url.path.add(Path(\".well-known\") / name)\n    return str(url)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oidc_discovery_document_url","title":"<code>oidc_discovery_document_url(issuer)</code>","text":"<p>Construct the OIDC discovery document url for a given <code>issuer</code>.</p> <p>Given an <code>issuer</code> identifier, return the standardised URL where the OIDC discovery document can be retrieved.</p> <p>The returned URL is biuilt as specified in OpenID Connect Discovery 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OIDC Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oidc_discovery_document_url(issuer: str) -&gt; str:\n\"\"\"Construct the OIDC discovery document url for a given `issuer`.\n\n    Given an `issuer` identifier, return the standardised URL where the OIDC\n    discovery document can be retrieved.\n\n    The returned URL is biuilt as specified in [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).\n\n    Args:\n        issuer: an OIDC Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is made.\n    \"\"\"\n    return well_known_uri(issuer, \"openid-configuration\", at_root=False)\n</code></pre>"},{"location":"api/#requests_oauth2client.discovery.oauth2_discovery_document_url","title":"<code>oauth2_discovery_document_url(issuer)</code>","text":"<p>Construct the standardised OAuth 2.0 discovery document url for a given <code>issuer</code>.</p> <p>Based an <code>issuer</code> identifier, returns the standardised URL where the OAuth20 server metadata can be retrieved.</p> <p>The returned URL is built as specified in RFC8414.</p> <p>Parameters:</p> Name Type Description Default <code>issuer</code> <code>str</code> <p>an OAuth20 Authentication Server <code>issuer</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the standardised discovery document URL. Note that no attempt to fetch this document is made.</p> Source code in <code>requests_oauth2client/discovery.py</code> <pre><code>def oauth2_discovery_document_url(issuer: str) -&gt; str:\n\"\"\"Construct the standardised OAuth 2.0 discovery document url for a given `issuer`.\n\n    Based an `issuer` identifier, returns the standardised URL where the OAuth20\n    server metadata can be retrieved.\n\n    The returned URL is built as specified in [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\n    Args:\n        issuer: an OAuth20 Authentication Server `issuer`\n\n    Returns:\n        the standardised discovery document URL. Note that no attempt to fetch this document is made.\n    \"\"\"\n    return well_known_uri(issuer, \"oauth-authorization-server\", at_root=True)\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling","title":"<code>pooling</code>","text":"<p>Contains base classes for pooling jobs.</p>"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob","title":"<code>TokenEndpointPoolingJob</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for Token Endpoint pooling jobs.</p> <p>This is used for decoupled flows like CIBA or Device Authorization.</p> <p>This class must be subclassed to implement actual BackChannel flows. This needs an OAuth2Client that will be used to pool the token endpoint. The initial pooling <code>interval</code> is configurable.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>the OAuth2Client that will be used to pool the token endpoint.</p> required <code>interval</code> <code>Optional[int]</code> <p>initial pooling interval, in seconds. If <code>None</code>, default to <code>5</code>.</p> <code>None</code> <code>slow_down_interval</code> <code>int</code> <p>when a SlowDown is received, this number of seconds will be added to the pooling interval.</p> <code>5</code> <code>requests_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>additional parameters for the underlying calls to requests.request</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional parameters for the token request</p> <code>{}</code> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>class TokenEndpointPoolingJob(ABC):\n\"\"\"Base class for Token Endpoint pooling jobs.\n\n    This is used for decoupled flows like CIBA or Device Authorization.\n\n    This class must be subclassed to implement actual BackChannel flows.\n    This needs an [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token\n    endpoint. The initial pooling `interval` is configurable.\n\n    Args:\n        client: the [OAuth2Client][requests_oauth2client.client.OAuth2Client] that will be used to pool the token endpoint.\n        interval: initial pooling interval, in seconds. If `None`, default to `5`.\n        slow_down_interval: when a [SlowDown][requests_oauth2client.exceptions.SlowDown] is received, this number of seconds will be added to the pooling interval.\n        requests_kwargs: additional parameters for the underlying calls to [requests.request][]\n        **token_kwargs: additional parameters for the token request\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"OAuth2Client\",\n        interval: Optional[int] = None,\n        slow_down_interval: int = 5,\n        requests_kwargs: Optional[Dict[str, Any]] = None,\n        **token_kwargs: Any,\n    ):\n        self.client = client\n        self.interval = interval or 5\n        self.slow_down_interval = slow_down_interval\n        self.requests_kwargs = requests_kwargs\n        self.token_kwargs = token_kwargs\n\n    def __call__(self) -&gt; Optional[BearerToken]:\n\"\"\"Wrap the actual Token Endpoint call with a pooling interval.\n\n        Everytime this method is called, it will wait for the entire duration of the pooling interval before calling\n        [token_request()][requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request]. So you can call it\n        immediately after initiating the BackChannel flow, and it will wait before initiating the first call.\n\n        This implements the logic to handle [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending]\n        or [SlowDown][requests_oauth2client.exceptions.SlowDown] requests by the AS.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken] if the AS returns one, or `None` if the Authorization is still pending.\n        \"\"\"\n        time.sleep(self.interval)\n        try:\n            return self.token_request()\n        except SlowDown:\n            self.interval += self.slow_down_interval\n        except AuthorizationPending:\n            pass\n        return None\n\n    @abstractmethod\n    def token_request(self) -&gt; BearerToken:\n\"\"\"Abstract method for the token endpoint call.\n\n        This must be implemented by subclasses. This method must\n        Must raise [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after the pooling interval,\n        or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase the pooling interval by `slow_down_interval` seconds.\n\n        Returns:\n            a [BearerToken][requests_oauth2client.tokens.BearerToken]\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.pooling.TokenEndpointPoolingJob.token_request","title":"<code>token_request()</code>  <code>abstractmethod</code>","text":"<p>Abstract method for the token endpoint call.</p> <p>This must be implemented by subclasses. This method must Must raise AuthorizationPending to retry after the pooling interval, or SlowDown to increase the pooling interval by <code>slow_down_interval</code> seconds.</p> <p>Returns:</p> Type Description <code>BearerToken</code> <p>a BearerToken</p> Source code in <code>requests_oauth2client/pooling.py</code> <pre><code>@abstractmethod\ndef token_request(self) -&gt; BearerToken:\n\"\"\"Abstract method for the token endpoint call.\n\n    This must be implemented by subclasses. This method must\n    Must raise [AuthorizationPending][requests_oauth2client.exceptions.AuthorizationPending] to retry after the pooling interval,\n    or [SlowDown][requests_oauth2client.exceptions.SlowDown] to increase the pooling interval by `slow_down_interval` seconds.\n\n    Returns:\n        a [BearerToken][requests_oauth2client.tokens.BearerToken]\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions","title":"<code>exceptions</code>","text":"<p>This module contains all exception classes from <code>requests_oauth2client</code>.</p>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for Exceptions raised when a backend endpoint returns an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the HTTP response containing the error</p> required Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class OAuth2Error(Exception):\n\"\"\"Base class for Exceptions raised when a backend endpoint returns an error.\n\n    Args:\n        response: the HTTP response containing the error\n    \"\"\"\n\n    def __init__(self, response: requests.Response):\n        self.response = response\n\n    @property\n    def request(self) -&gt; requests.PreparedRequest:\n\"\"\"The request leading to the error.\"\"\"\n        return self.response.request\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.OAuth2Error.request","title":"<code>request: requests.PreparedRequest</code>  <code>property</code>","text":"<p>The request leading to the error.</p>"},{"location":"api/#requests_oauth2client.exceptions.EndpointError","title":"<code>EndpointError</code>","text":"<p>         Bases: <code>OAuth2Error</code></p> <p>Base class for exceptions raised from backend endpoint errors.</p> <p>This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>requests.Response</code> <p>the raw requests.PreparedResponse containing the error.</p> required <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS.</p> required <code>description</code> <code>Optional[str]</code> <p>the <code>error_description</code> as returned by the AS.</p> <code>None</code> <code>uri</code> <code>Optional[str]</code> <p>the <code>error_uri</code> as returned by the AS.</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class EndpointError(OAuth2Error):\n\"\"\"Base class for exceptions raised from backend endpoint errors.\n\n    This contains the error message, description and uri that are returned by the AS in the OAuth 2.0 standardised way.\n\n    Args:\n        response: the raw requests.PreparedResponse containing the error.\n        error: the `error` identifier as returned by the AS.\n        description: the `error_description` as returned by the AS.\n        uri: the `error_uri` as returned by the AS.\n    \"\"\"\n\n    def __init__(\n        self,\n        response: requests.Response,\n        error: str,\n        description: Optional[str] = None,\n        uri: Optional[str] = None,\n    ):\n        super().__init__(response)\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTokenResponse","title":"<code>InvalidTokenResponse</code>","text":"<p>         Bases: <code>OAuth2Error</code></p> <p>Raised when the Token Endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTokenResponse(OAuth2Error):\n\"\"\"Raised when the Token Endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredAccessToken","title":"<code>ExpiredAccessToken</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>Raised when an expired access token is used.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredAccessToken(RuntimeError):\n\"\"\"Raised when an expired access token is used.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownTokenEndpointError","title":"<code>UnknownTokenEndpointError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Raised when an otherwise unknown error is returned by the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownTokenEndpointError(EndpointError):\n\"\"\"Raised when an otherwise unknown error is returned by the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Raised when the token endpoint returns <code>error = server_error</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ServerError(EndpointError):\n\"\"\"Raised when the token endpoint returns `error = server_error`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.TokenEndpointError","title":"<code>TokenEndpointError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Base class for errors that are specific to the token endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class TokenEndpointError(EndpointError):\n\"\"\"Base class for errors that are specific to the token endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidRequest","title":"<code>InvalidRequest</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_request</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidRequest(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = invalid_request`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidClient","title":"<code>InvalidClient</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidClient(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = invalid_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidScope","title":"<code>InvalidScope</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_scope</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidScope(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = invalid_scope`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidTarget","title":"<code>InvalidTarget</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_target</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidTarget(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = invalid_target`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidGrant","title":"<code>InvalidGrant</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = invalid_grant</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidGrant(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = invalid_grant`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccessDenied","title":"<code>AccessDenied</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = access_denied</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccessDenied(EndpointError):\n\"\"\"Raised when the Authorization Server returns `error = access_denied`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnauthorizedClient","title":"<code>UnauthorizedClient</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Raised when the Authorization Server returns <code>error = unauthorized_client</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnauthorizedClient(EndpointError):\n\"\"\"Raised when the Authorization Server returns `error = unauthorized_client`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.RevocationError","title":"<code>RevocationError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Base class for Revocation Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class RevocationError(EndpointError):\n\"\"\"Base class for Revocation Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnsupportedTokenType","title":"<code>UnsupportedTokenType</code>","text":"<p>         Bases: <code>RevocationError</code></p> <p>Raised when the Revocation endpoint returns <code>error = unsupported_token_type</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnsupportedTokenType(RevocationError):\n\"\"\"Raised when the Revocation endpoint returns `error = unsupported_token_type`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.IntrospectionError","title":"<code>IntrospectionError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Base class for Introspection Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class IntrospectionError(EndpointError):\n\"\"\"Base class for Introspection Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.UnknownIntrospectionError","title":"<code>UnknownIntrospectionError</code>","text":"<p>         Bases: <code>OAuth2Error</code></p> <p>Raised when the Introspection Endpoint returns a non-standard error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class UnknownIntrospectionError(OAuth2Error):\n\"\"\"Raised when the Introspection Endpoint returns a non-standard error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.DeviceAuthorizationError","title":"<code>DeviceAuthorizationError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Base class for Device Authorization Endpoint errors.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class DeviceAuthorizationError(EndpointError):\n\"\"\"Base class for Device Authorization Endpoint errors.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationPending","title":"<code>AuthorizationPending</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = authorization_pending</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationPending(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = authorization_pending`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SlowDown","title":"<code>SlowDown</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = slow_down</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SlowDown(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = slow_down`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredToken","title":"<code>ExpiredToken</code>","text":"<p>         Bases: <code>TokenEndpointError</code></p> <p>Raised when the Token Endpoint returns <code>error = expired_token</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredToken(TokenEndpointError):\n\"\"\"Raised when the Token Endpoint returns `error = expired_token`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidDeviceAuthorizationResponse","title":"<code>InvalidDeviceAuthorizationResponse</code>","text":"<p>         Bases: <code>OAuth2Error</code></p> <p>Raised when the Device Authorization Endpoint returns a non-standard error response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidDeviceAuthorizationResponse(OAuth2Error):\n\"\"\"Raised when the Device Authorization Endpoint returns a non-standard error response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidIdToken","title":"<code>InvalidIdToken</code>","text":"<p>         Bases: <code>InvalidJwt</code></p> <p>Raised when trying to validate an invalid Id Token value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidIdToken(InvalidJwt):\n\"\"\"Raised when trying to validate an invalid Id Token value.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AuthorizationResponseError","title":"<code>AuthorizationResponseError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for error responses returned by the Authorization endpoint.</p> <p>An <code>AuthorizationResponseError</code> contains the error message, description and uri that are returned by the AS.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>str</code> <p>the <code>error</code> identifier as returned by the AS</p> required <code>description</code> <code>Optional[str]</code> <p>the <code>error_description</code> as returned by the AS</p> <code>None</code> <code>uri</code> <code>Optional[str]</code> <p>the <code>error_uri</code> as returned by the AS</p> <code>None</code> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AuthorizationResponseError(Exception):\n\"\"\"Base class for error responses returned by the Authorization endpoint.\n\n    An `AuthorizationResponseError` contains the error message, description and uri that are returned by the AS.\n\n    Args:\n        error: the `error` identifier as returned by the AS\n        description: the `error_description` as returned by the AS\n        uri: the `error_uri` as returned by the AS\n    \"\"\"\n\n    def __init__(\n        self, error: str, description: Optional[str] = None, uri: Optional[str] = None\n    ):\n        self.error = error\n        self.description = description\n        self.uri = uri\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InteractionRequired","title":"<code>InteractionRequired</code>","text":"<p>         Bases: <code>AuthorizationResponseError</code></p> <p>Raised when the Authorization Endpoint returns <code>error = interaction_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InteractionRequired(AuthorizationResponseError):\n\"\"\"Raised when the Authorization Endpoint returns `error = interaction_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.LoginRequired","title":"<code>LoginRequired</code>","text":"<p>         Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = login_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class LoginRequired(InteractionRequired):\n\"\"\"Raised when the Authorization Endpoint returns `error = login_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.AccountSelectionRequired","title":"<code>AccountSelectionRequired</code>","text":"<p>         Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = account_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class AccountSelectionRequired(InteractionRequired):\n\"\"\"Raised when the Authorization Endpoint returns `error = account_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.SessionSelectionRequired","title":"<code>SessionSelectionRequired</code>","text":"<p>         Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = session_selection_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class SessionSelectionRequired(InteractionRequired):\n\"\"\"Raised when the Authorization Endpoint returns `error = session_selection_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ConsentRequired","title":"<code>ConsentRequired</code>","text":"<p>         Bases: <code>InteractionRequired</code></p> <p>Raised when the Authorization Endpoint returns <code>error = consent_required</code>.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ConsentRequired(InteractionRequired):\n\"\"\"Raised when the Authorization Endpoint returns `error = consent_required`.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidAuthResponse","title":"<code>InvalidAuthResponse</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when the Authorization Endpoint returns an invalid response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidAuthResponse(Exception):\n\"\"\"Raised when the Authorization Endpoint returns an invalid response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingAuthCode","title":"<code>MissingAuthCode</code>","text":"<p>         Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return the mandatory <code>code</code>.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an authorization <code>code</code> either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingAuthCode(InvalidAuthResponse):\n\"\"\"Raised when the Authorization Endpoint does not return the mandatory `code`.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an\n    authorization `code` either.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingIssuer","title":"<code>MissingIssuer</code>","text":"<p>         Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return an <code>iss</code> parameter as expected.</p> <p>The Authorization Server advertises its support with a flag <code>authorization_response_iss_parameter_supported</code> in its discovery document. If it is set to <code>true</code>, it must include an <code>iss</code> parameter in its authorization responses, containing its issuer identifier.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIssuer(InvalidAuthResponse):\n\"\"\"Raised when the Authorization Endpoint does not return an `iss` parameter as expected.\n\n    The Authorization Server advertises its support with a flag\n    `authorization_response_iss_parameter_supported` in its discovery document. If it is set to\n    `true`, it must include an `iss` parameter in its authorization responses, containing its issuer\n    identifier.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MissingIdToken","title":"<code>MissingIdToken</code>","text":"<p>         Bases: <code>InvalidAuthResponse</code></p> <p>Raised when the Authorization Endpoint does not return a mandatory ID Token.</p> <p>This happens when the Authorization Endpoint does not return an error, but does not return an ID Token either.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MissingIdToken(InvalidAuthResponse):\n\"\"\"Raised when the Authorization Endpoint does not return a mandatory ID Token.\n\n    This happens when the Authorization Endpoint does not return an error, but does not return an ID\n    Token either.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingState","title":"<code>MismatchingState</code>","text":"<p>         Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>state</code> value.</p> <p>This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the value passed in the Authorization Request.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingState(InvalidAuthResponse):\n\"\"\"Raised on mismatching `state` value.\n\n    This happens when the Authorization Endpoints returns a 'state' parameter that doesn't match the\n    value passed in the Authorization Request.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIssuer","title":"<code>MismatchingIssuer</code>","text":"<p>         Bases: <code>InvalidAuthResponse</code></p> <p>Raised on mismatching <code>iss</code> value.</p> <p>This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIssuer(InvalidAuthResponse):\n\"\"\"Raised on mismatching `iss` value.\n\n    This happens when the Authorization Endpoints returns an 'iss' that doesn't match the expected\n    value.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingNonce","title":"<code>MismatchingNonce</code>","text":"<p>         Bases: <code>InvalidIdToken</code></p> <p>Raised on mismatching <code>nonce</code> value in an ID Token.</p> <p>This happens when the authorization request includes a <code>nonce</code> but the returned ID Token include a different value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingNonce(InvalidIdToken):\n\"\"\"Raised on mismatching `nonce` value in an ID Token.\n\n    This happens when the authorization request includes a `nonce` but the returned ID Token include\n    a different value.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingAcr","title":"<code>MismatchingAcr</code>","text":"<p>         Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token doesn't contain one of the requested ACR Values.</p> <p>This happens when the authorization request includes an <code>acr_values</code> parameter but the returned ID Token includes a different value.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAcr(InvalidIdToken):\n\"\"\"Raised when the returned ID Token doesn't contain one of the requested ACR Values.\n\n    This happens when the authorization request includes an `acr_values` parameter but the returned\n    ID Token includes a different value.\n    \"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingAudience","title":"<code>MismatchingAudience</code>","text":"<p>         Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token audience does not include the requesting Client ID.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAudience(InvalidIdToken):\n\"\"\"Raised when the ID Token audience does not include the requesting Client ID.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingAzp","title":"<code>MismatchingAzp</code>","text":"<p>         Bases: <code>InvalidIdToken</code></p> <p>Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingAzp(InvalidIdToken):\n\"\"\"Raised when the ID Token Authorized Presenter (azp) claim is not the Client ID.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.MismatchingIdTokenAlg","title":"<code>MismatchingIdTokenAlg</code>","text":"<p>         Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is signed with an unexpected alg.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class MismatchingIdTokenAlg(InvalidIdToken):\n\"\"\"Raised when the returned ID Token is signed with an unexpected alg.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.ExpiredIdToken","title":"<code>ExpiredIdToken</code>","text":"<p>         Bases: <code>InvalidIdToken</code></p> <p>Raised when the returned ID Token is expired.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class ExpiredIdToken(InvalidIdToken):\n\"\"\"Raised when the returned ID Token is expired.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.BackChannelAuthenticationError","title":"<code>BackChannelAuthenticationError</code>","text":"<p>         Bases: <code>EndpointError</code></p> <p>Base class for errors returned by the BackChannel Authentication endpoint.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class BackChannelAuthenticationError(EndpointError):\n\"\"\"Base class for errors returned by the BackChannel Authentication endpoint.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidBackChannelAuthenticationResponse","title":"<code>InvalidBackChannelAuthenticationResponse</code>","text":"<p>         Bases: <code>OAuth2Error</code></p> <p>Raised when the BackChannel Authentication endpoint returns a non-standard response.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidBackChannelAuthenticationResponse(OAuth2Error):\n\"\"\"Raised when the BackChannel Authentication endpoint returns a non-standard response.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.exceptions.InvalidPushedAuthorizationResponse","title":"<code>InvalidPushedAuthorizationResponse</code>","text":"<p>         Bases: <code>OAuth2Error</code></p> <p>Raised when the Pushed Authorization Endpoint returns an error.</p> Source code in <code>requests_oauth2client/exceptions.py</code> <pre><code>class InvalidPushedAuthorizationResponse(OAuth2Error):\n\"\"\"Raised when the Pushed Authorization Endpoint returns an error.\"\"\"\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request","title":"<code>authorization_request</code>","text":"<p>Classes and utilities related to Authorization Requests and Responses.</p>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils","title":"<code>PkceUtils</code>","text":"<p>Contains helper methods for PKCE, as described in RFC7636.</p> <p>See RFC7636.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class PkceUtils:\n\"\"\"Contains helper methods for PKCE, as described in RFC7636.\n\n    See [RFC7636](https://tools.ietf.org/html/rfc7636).\n    \"\"\"\n\n    code_verifier_re = re.compile(r\"^[a-zA-Z0-9_\\-~.]{43,128}$\")\n\"\"\"A regex that matches valid code verifiers.\"\"\"\n\n    @classmethod\n    def generate_code_verifier(cls) -&gt; str:\n\"\"\"Generate a valid `code_verifier`.\n\n        Returns:\n            a code_verifier ready to use for PKCE\n        \"\"\"\n        return secrets.token_urlsafe(96)\n\n    @classmethod\n    def derive_challenge(cls, verifier: Union[str, bytes], method: str = \"S256\") -&gt; str:\n\"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n        Args:\n            verifier: a code verifier\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a code_challenge derived from the given verifier\n        \"\"\"\n        if isinstance(verifier, bytes):\n            verifier = verifier.decode()\n\n        if not cls.code_verifier_re.match(verifier):\n            raise ValueError(\n                f\"Invalid code verifier, does not match {cls.code_verifier_re}\",\n                verifier,\n            )\n\n        if method == \"S256\":\n            return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n        elif method == \"plain\":\n            return verifier\n        else:\n            raise ValueError(\"Unsupported code_challenge_method\", method)\n\n    @classmethod\n    def generate_code_verifier_and_challenge(cls, method: str = \"S256\") -&gt; Tuple[str, str]:\n\"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n        Args:\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            a (code_verifier, code_challenge) tuple.\n        \"\"\"\n        verifier = cls.generate_code_verifier()\n        challenge = cls.derive_challenge(verifier, method)\n        return verifier, challenge\n\n    @classmethod\n    def validate_code_verifier(\n        cls, verifier: str, challenge: str, method: str = \"S256\"\n    ) -&gt; bool:\n\"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n        Args:\n            verifier: the `code_verifier`, exactly as submitted by the client on token request.\n            challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n            method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n        Returns:\n            `True` if verifier is valid, or `False` otherwise\n        \"\"\"\n        return (\n            cls.code_verifier_re.match(verifier) is not None\n            and cls.derive_challenge(verifier, method) == challenge\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.code_verifier_re","title":"<code>code_verifier_re = re.compile('^[a-zA-Z0-9_\\\\-~.]{43,128}$')</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>A regex that matches valid code verifiers.</p>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier","title":"<code>generate_code_verifier()</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a code_verifier ready to use for PKCE</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier(cls) -&gt; str:\n\"\"\"Generate a valid `code_verifier`.\n\n    Returns:\n        a code_verifier ready to use for PKCE\n    \"\"\"\n    return secrets.token_urlsafe(96)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.derive_challenge","title":"<code>derive_challenge(verifier, method='S256')</code>  <code>classmethod</code>","text":"<p>Derive the <code>code_challenge</code> from a given <code>code_verifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>Union[str, bytes]</code> <p>a code verifier</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>str</code> <p>a code_challenge derived from the given verifier</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef derive_challenge(cls, verifier: Union[str, bytes], method: str = \"S256\") -&gt; str:\n\"\"\"Derive the `code_challenge` from a given `code_verifier`.\n\n    Args:\n        verifier: a code verifier\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a code_challenge derived from the given verifier\n    \"\"\"\n    if isinstance(verifier, bytes):\n        verifier = verifier.decode()\n\n    if not cls.code_verifier_re.match(verifier):\n        raise ValueError(\n            f\"Invalid code verifier, does not match {cls.code_verifier_re}\",\n            verifier,\n        )\n\n    if method == \"S256\":\n        return BinaPy(verifier).to(\"sha256\").to(\"b64u\").ascii()\n    elif method == \"plain\":\n        return verifier\n    else:\n        raise ValueError(\"Unsupported code_challenge_method\", method)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.generate_code_verifier_and_challenge","title":"<code>generate_code_verifier_and_challenge(method='S256')</code>  <code>classmethod</code>","text":"<p>Generate a valid <code>code_verifier</code> and derive its <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>a (code_verifier, code_challenge) tuple.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_code_verifier_and_challenge(cls, method: str = \"S256\") -&gt; Tuple[str, str]:\n\"\"\"Generate a valid `code_verifier` and derive its `code_challenge`.\n\n    Args:\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        a (code_verifier, code_challenge) tuple.\n    \"\"\"\n    verifier = cls.generate_code_verifier()\n    challenge = cls.derive_challenge(verifier, method)\n    return verifier, challenge\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.PkceUtils.validate_code_verifier","title":"<code>validate_code_verifier(verifier, challenge, method='S256')</code>  <code>classmethod</code>","text":"<p>Validate a <code>code_verifier</code> against a <code>code_challenge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verifier</code> <code>str</code> <p>the <code>code_verifier</code>, exactly as submitted by the client on token request.</p> required <code>challenge</code> <code>str</code> <p>the <code>code_challenge</code>, exactly as submitted by the client on authorization request.</p> required <code>method</code> <code>str</code> <p>the method to use for deriving the challenge. Accepts 'S256' or 'plain'.</p> <code>'S256'</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if verifier is valid, or <code>False</code> otherwise</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef validate_code_verifier(\n    cls, verifier: str, challenge: str, method: str = \"S256\"\n) -&gt; bool:\n\"\"\"Validate a `code_verifier` against a `code_challenge`.\n\n    Args:\n        verifier: the `code_verifier`, exactly as submitted by the client on token request.\n        challenge: the `code_challenge`, exactly as submitted by the client on authorization request.\n        method: the method to use for deriving the challenge. Accepts 'S256' or 'plain'.\n\n    Returns:\n        `True` if verifier is valid, or `False` otherwise\n    \"\"\"\n    return (\n        cls.code_verifier_re.match(verifier) is not None\n        and cls.derive_challenge(verifier, method) == challenge\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationResponse","title":"<code>AuthorizationResponse</code>","text":"<p>Represent a successful Authorization Response.</p> <p>An Authorization Response is the redirection initiated by the AS to the client's redirection endpoint (redirect_uri) after an Authorization Request. This Response is typically created with a call to <code>AuthorizationRequest.validate_callback()</code> once the call to the client Redirection Endpoint is made. AuthorizationResponse contains the following, all accessible as attributes:  - all the parameters that have been returned by the AS, most notably the <code>code</code>, and optional parameters such as <code>state</code>.  - the redirect_uri that was used for the Authorization Request  - the code_verifier matching the code_challenge that was used for the Authorization Request</p> <p>Parameters <code>redirect_uri</code> and <code>code_verifier</code> must be those from the matching <code>AuthorizationRequest</code>. All other parameters including <code>code</code> and <code>state</code> must be those extracted from the Authorization Response parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>the authorization code returned by the AS</p> required <code>redirect_uri</code> <code>Optional[str]</code> <p>the redirect_uri that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>code_verifier</code> <code>Optional[str]</code> <p>the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest</p> <code>None</code> <code>state</code> <code>Optional[str]</code> <p>the state returned by the AS</p> <code>None</code> <code>**kwargs</code> <code>str</code> <p>other parameters as returned by the AS</p> <code>{}</code> Usage <pre><code>request = AuthorizationRequest(\n    client_id, scope=\"openid\", redirect_uri=\"http://localhost:54121/callback\"\n)\nwebbrowser.open(request)  # open the authorization request in a browser\nresponse_uri = ...  # at this point, manage to get the response uri\nresponse = request.validate_callback(\n    response_uri\n)  # get an AuthorizationResponse at this point\n\nclient = OAuth2Client(token_endpoint, auth=(client_id, client_secret))\nclient.authorization_code(\n    response\n)  # you can pass this response on a call to `OAuth2Client.authorization_code()`\n</code></pre> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationResponse:\n\"\"\"Represent a successful Authorization Response.\n\n    An Authorization Response is the redirection initiated by the AS\n    to the client's redirection endpoint (redirect_uri) after an Authorization Request.\n    This Response is typically created with a call to `AuthorizationRequest.validate_callback()` once the call\n    to the client Redirection Endpoint is made.\n    AuthorizationResponse contains the following, all accessible as attributes:\n     - all the parameters that have been returned by the AS, most notably the `code`, and optional parameters such as `state`.\n     - the redirect_uri that was used for the Authorization Request\n     - the code_verifier matching the code_challenge that was used for the Authorization Request\n\n    Parameters `redirect_uri` and `code_verifier` must be those from the matching `AuthorizationRequest`.\n    All other parameters including `code` and `state` must be those extracted from the Authorization Response parameters.\n\n    Args:\n        code: the authorization code returned by the AS\n        redirect_uri: the redirect_uri that was passed as parameter in the AuthorizationRequest\n        code_verifier: the code_verifier matching the code_challenge that was passed as parameter in the AuthorizationRequest\n        state: the state returned by the AS\n        **kwargs: other parameters as returned by the AS\n\n    Usage:\n        ```python\n        request = AuthorizationRequest(\n            client_id, scope=\"openid\", redirect_uri=\"http://localhost:54121/callback\"\n        )\n        webbrowser.open(request)  # open the authorization request in a browser\n        response_uri = ...  # at this point, manage to get the response uri\n        response = request.validate_callback(\n            response_uri\n        )  # get an AuthorizationResponse at this point\n\n        client = OAuth2Client(token_endpoint, auth=(client_id, client_secret))\n        client.authorization_code(\n            response\n        )  # you can pass this response on a call to `OAuth2Client.authorization_code()`\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        code: str,\n        redirect_uri: Optional[str] = None,\n        code_verifier: Optional[str] = None,\n        state: Optional[str] = None,\n        nonce: Optional[str] = None,\n        acr_values: Optional[Iterable[str]] = None,\n        max_age: Optional[int] = None,\n        **kwargs: str,\n    ):\n        self.code = code\n        self.redirect_uri = redirect_uri\n        self.code_verifier = code_verifier\n        self.state = state\n        self.nonce = nonce\n        self.acr_values = list(acr_values) if acr_values is not None else None\n        self.max_age = max_age\n        self.others = kwargs\n\n    def __getattr__(self, item: str) -&gt; Optional[str]:\n\"\"\"Make additional parameters available as attributes.\n\n        Args:\n            item: the attribute name\n\n        Returns:\n            the attribute value, or None if it isn't part of the returned attributes\n        \"\"\"\n        return self.others.get(item)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest","title":"<code>AuthorizationRequest</code>","text":"<p>Represents an Authorization Request.</p> <p>This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args), to store all parameters, and to validate an Authorization Response.</p> <p>All parameters passed at init time will be included in the request query parameters as-is, excepted for a few parameters which have a special behaviour:</p> <ul> <li><code>state</code>: if True (default), a random state parameter will be generated for you. You may pass your own state as <code>str</code>, or set it to <code>None</code> so that the state parameter will not be included in the request. You may access that state in the <code>state</code> attribute from this request.</li> <li><code>nonce</code>: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request.  You may access that nonce in the <code>nonce</code> attribute from this request.</li> <li><code>code_verifier</code>: if <code>None</code>, and <code>code_challenge_method</code> is <code>'S256'</code> or <code>'plain'</code>, a valid <code>code_challenge</code> and <code>code_verifier</code> for PKCE will be automatically generated, and the <code>code_challenge</code> will be included in the request. You may pass your own <code>code_verifier</code> as a <code>str</code> parameter, in which case the appropriate <code>code_challenge</code> will be included in the request, according to the <code>code_challenge_method</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the uri for the authorization endpoint.</p> required <code>client_id</code> <code>str</code> <p>the client_id to include in the request.</p> required <code>redirect_uri</code> <code>Optional[str]</code> <p>the redirect_uri to include in the request. This is required in OAuth 2.0 and optional in OAuth 2.1. Pass <code>None</code> if you don't need any redirect_uri in the Authorization Request.</p> <code>None</code> <code>scope</code> <code>Union[None, str, Iterable[str]]</code> <p>the scope to include in the request, as an iterable of <code>str</code>, or a single space-separated <code>str</code>.</p> <code>'openid'</code> <code>response_type</code> <code>str</code> <p>the response type to include in the request.</p> <code>'code'</code> <code>state</code> <code>Union[str, Literal[True], None]</code> <p>the state to include in the request, or <code>True</code> to autogenerate one (default).</p> <code>True</code> <code>nonce</code> <code>Union[str, Literal[True], None]</code> <p>the nonce to include in the request, or <code>True</code> to autogenerate one (default).</p> <code>True</code> <code>code_verifier</code> <code>Optional[str]</code> <p>the code verifier to include in the request. If left as <code>None</code> and <code>code_challenge_method</code> is set, a valid code_verifier will be generated.</p> <code>None</code> <code>code_challenge_method</code> <code>Optional[str]</code> <p>the method to use to derive the <code>code_challenge</code> from the <code>code_verifier</code>.</p> <code>'S256'</code> <code>acr_values</code> <code>Union[str, Iterable[str], None]</code> <p>requested Authentication Context Class Reference values.</p> <code>None</code> <code>issuer</code> <code>Optional[str]</code> <p>Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>extra parameters to include in the request, as-is.</p> <code>{}</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequest:\n\"\"\"Represents an Authorization Request.\n\n    This class makes it easy to generate valid Authorization Request URI (possibly including a state, nonce, PKCE, and custom args),\n    to store all parameters, and to validate an Authorization Response.\n\n    All parameters passed at init time will be included in the request query parameters as-is,\n    excepted for a few parameters which have a special behaviour:\n\n    * `state`: if True (default), a random state parameter will be generated for you. You may pass your own state as `str`,\n    or set it to `None` so that the state parameter will not be included in the request. You may access that state in the\n    `state` attribute from this request.\n    * `nonce`: if True (default) and scope includes 'openid', a random nonce will be generated and included in the request.\n     You may access that nonce in the `nonce` attribute from this request.\n    * `code_verifier`: if `None`, and `code_challenge_method` is `'S256'` or `'plain'`, a valid `code_challenge`\n    and `code_verifier` for PKCE will be automatically generated, and the `code_challenge` will be included\n    in the request. You may pass your own `code_verifier` as a `str` parameter, in which case the appropriate\n    `code_challenge` will be included in the request, according to the `code_challenge_method`.\n\n    Args:\n        authorization_endpoint: the uri for the authorization endpoint.\n        client_id: the client_id to include in the request.\n        redirect_uri: the redirect_uri to include in the request. This is required in OAuth 2.0 and optional\n            in OAuth 2.1. Pass `None` if you don't need any redirect_uri in the Authorization Request.\n        scope: the scope to include in the request, as an iterable of `str`, or a single space-separated `str`.\n        response_type: the response type to include in the request.\n        state: the state to include in the request, or `True` to autogenerate one (default).\n        nonce: the nonce to include in the request, or `True` to autogenerate one (default).\n        code_verifier: the code verifier to include in the request. If left as `None` and `code_challenge_method` is set, a valid code_verifier will be generated.\n        code_challenge_method: the method to use to derive the `code_challenge` from the `code_verifier`.\n        acr_values: requested Authentication Context Class Reference values.\n        issuer: Issuer Identifier value from the OAuth/OIDC Server, if using Server Issuer Identification.\n        **kwargs: extra parameters to include in the request, as-is.\n    \"\"\"\n\n    exception_classes: Dict[str, Type[Exception]] = {\n        \"interaction_required\": InteractionRequired,\n        \"login_required\": LoginRequired,\n        \"session_selection_required\": SessionSelectionRequired,\n        \"consent_required\": ConsentRequired,\n    }\n\n    @classmethod\n    def generate_state(cls) -&gt; str:\n\"\"\"Generate a random `state` parameter.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    @classmethod\n    def generate_nonce(cls) -&gt; str:\n\"\"\"Generate a random `nonce`.\"\"\"\n        return secrets.token_urlsafe(32)\n\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        redirect_uri: Optional[str] = None,\n        scope: Union[None, str, Iterable[str]] = \"openid\",\n        response_type: str = \"code\",\n        state: Union[str, Literal[True], None] = True,\n        nonce: Union[str, Literal[True], None] = True,\n        code_verifier: Optional[str] = None,\n        code_challenge_method: Optional[str] = \"S256\",\n        acr_values: Union[str, Iterable[str], None] = None,\n        max_age: Union[int, None] = None,\n        issuer: Optional[str] = None,\n        authorization_response_iss_parameter_supported: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        if authorization_response_iss_parameter_supported and not issuer:\n            raise ValueError(\n                \"When 'authorization_response_iss_parameter_supported' is True, you must provide the expected 'issuer' as parameter.\"\n            )\n\n        if state is True:\n            state = self.generate_state()\n\n        if scope is not None:\n            if isinstance(scope, str):\n                scope = scope.split(\" \")\n            else:\n                scope = tuple(scope)\n\n        if nonce is True:\n            if scope is not None and \"openid\" in scope:\n                nonce = self.generate_nonce()\n            else:\n                nonce = None\n\n        if acr_values is not None:\n            if isinstance(acr_values, str):\n                acr_values = acr_values.split()\n            elif not isinstance(acr_values, list):\n                acr_values = list(acr_values)\n\n        if \"code_challenge\" in kwargs:\n            raise ValueError(\n                \"A code_challenge must not be passed as parameter. \"\n                \"Pass the code_verifier instead, and the appropriate code_challenge \"\n                \"will automatically be derived from it and included in the request, \"\n                \"based on code_challenge_method.\"\n            )\n\n        if not code_challenge_method:\n            code_verifier = code_challenge = code_challenge_method = None\n        else:\n            if not code_verifier:\n                code_verifier = PkceUtils.generate_code_verifier()\n            code_challenge = PkceUtils.derive_challenge(code_verifier, code_challenge_method)\n\n        if max_age is not None:\n            if max_age &lt; 0:\n                raise ValueError(\n                    \"The `max_age` parameter is a number of seconds and cannot be negative.\"\n                )\n\n        self.authorization_endpoint = authorization_endpoint\n        self.client_id = client_id\n        self.redirect_uri = redirect_uri\n        self.issuer = issuer\n        self.response_type = response_type\n        self.scope = scope\n        self.state = state\n        self.nonce = nonce\n        self.code_verifier = code_verifier\n        self.code_challenge = code_challenge\n        self.code_challenge_method = code_challenge_method\n        self.acr_values = acr_values\n        self.max_age = max_age\n        self.authorization_response_iss_parameter_supported = (\n            authorization_response_iss_parameter_supported\n        )\n        self.kwargs = kwargs\n\n        self.args = dict(\n            client_id=client_id,\n            redirect_uri=redirect_uri,\n            response_type=response_type,\n            scope=\" \".join(scope) if scope is not None else None,\n            state=state,\n            nonce=nonce,\n            code_challenge=code_challenge,\n            code_challenge_method=code_challenge_method,\n            acr_values=\" \".join(acr_values) if acr_values is not None else None,\n            max_age=max_age,\n            **kwargs,\n        )\n\n    def as_dict(self) -&gt; Mapping[str, Any]:\n\"\"\"Return a dict with all the parameters used to init this Authorization Request.\n\n        Used for serialization of this request. A new AuthorizationRequest initialized with the same parameters will be\n        equal to this one.\n\n        Returns:\n            a dict of parameters\n        \"\"\"\n        return {\n            \"authorization_endpoint\": self.authorization_endpoint,\n            \"client_id\": self.client_id,\n            \"redirect_uri\": self.redirect_uri,\n            \"scope\": self.scope,\n            \"response_type\": self.response_type,\n            \"state\": self.state,\n            \"nonce\": self.nonce,\n            \"code_verifier\": self.code_verifier,\n            \"code_challenge_method\": self.code_challenge_method,\n            \"issuer\": self.issuer,\n            \"authorization_response_iss_parameter_supported\": self.authorization_response_iss_parameter_supported,\n            \"acr_values\": self.acr_values,\n            \"max_age\": self.max_age,\n            **self.kwargs,\n        }\n\n    def sign_request_jwt(\n        self,\n        jwk: Union[Jwk, Dict[str, Any]],\n        alg: Optional[str] = None,\n        lifetime: Optional[int] = None,\n    ) -&gt; SignedJwt:\n\"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n            lifetime: an optional number of seconds of validity for the signed reqeust. If present, `iat` an `exp` claims will be included in the signed JWT.\n\n        Returns:\n            a `Jwt` that contains the signed request object.\n        \"\"\"\n        claims = {key: val for key, val in self.args.items() if val is not None}\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign(\n            claims,\n            key=jwk,\n            alg=alg,\n        )\n\n    def sign(\n        self,\n        jwk: Union[Jwk, Dict[str, Any]],\n        alg: Optional[str] = None,\n        lifetime: Optional[int] = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n\"\"\"Sign this Authorization Request and return a new one.\n\n        This replaces all parameters with a signed `request` JWT.\n\n        Args:\n            jwk: the JWK to use to sign the request\n            alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.\n\n        Returns:\n            the signed Authorization Request\n        \"\"\"\n        request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n            expires_at=request_jwt.expires_at,\n        )\n\n    def sign_and_encrypt_request_jwt(\n        self,\n        sign_jwk: Union[Jwk, Dict[str, Any]],\n        enc_jwk: Union[Jwk, Dict[str, Any]],\n        sign_alg: Optional[str] = None,\n        enc_alg: Optional[str] = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: Optional[int] = None,\n    ) -&gt; JweCompact:\n\"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n        The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.\n\n        Returns:\n            the signed and encrypted request object, as a `jwskate.Jwt`\n        \"\"\"\n        claims = {key: val for key, val in self.args.items() if val is not None}\n        if lifetime:\n            claims[\"iat\"] = Jwt.timestamp()\n            claims[\"exp\"] = Jwt.timestamp(lifetime)\n        return Jwt.sign_and_encrypt(\n            claims=claims,\n            sign_key=sign_jwk,\n            sign_alg=sign_alg,\n            enc_key=enc_jwk,\n            enc_alg=enc_alg,\n            enc=enc,\n        )\n\n    def sign_and_encrypt(\n        self,\n        sign_jwk: Union[Jwk, Dict[str, Any]],\n        enc_jwk: Union[Jwk, Dict[str, Any]],\n        sign_alg: Optional[str] = None,\n        enc_alg: Optional[str] = None,\n        enc: str = \"A128CBC-HS256\",\n        lifetime: Optional[int] = None,\n    ) -&gt; RequestParameterAuthorizationRequest:\n\"\"\"Sign and encrypt the current Authorization Request.\n\n        This replaces all parameters with a matching `request` object.\n\n        Args:\n            sign_jwk: the JWK to use to sign the request\n            enc_jwk: the JWK to use to encrypt the request\n            sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n            enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter.\n            enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter.\n            lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.\n\n        Returns:\n            the same AuthorizationRequest, with a request object as parameter\n        \"\"\"\n        request_jwt = self.sign_and_encrypt_request_jwt(\n            sign_jwk=sign_jwk,\n            enc_jwk=enc_jwk,\n            sign_alg=sign_alg,\n            enc_alg=enc_alg,\n            enc=enc,\n            lifetime=lifetime,\n        )\n        return RequestParameterAuthorizationRequest(\n            authorization_endpoint=self.authorization_endpoint,\n            client_id=self.client_id,\n            request=str(request_jwt),\n        )\n\n    def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n\"\"\"Validate an Authorization Response against this Request.\n\n        Validate a given Authorization Response URI against this Authorization\n        Request, and return an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n        This includes matching the `state` parameter, checking for returned errors, and extracting the returned `code`\n        and other parameters.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            the extracted code, if all checks are successful\n\n        Raises:\n            MismatchingIssuer: if the 'iss' received in the response doesn't match the expected value.\n            MismatchingState: if the response `state` does not match the expected value.\n            OAuth2Error: if the response includes an error.\n            MissingAuthCode: if the response does not contain a `code`.\n            NotImplementedError: if response_type anything else than 'code'\n        \"\"\"\n        try:\n            response_url = furl(response)\n        except ValueError:\n            return self.on_response_error(response)\n\n        # validate 'iss' according to RFC9207\n        received_issuer = response_url.args.get(\"iss\")\n        if self.authorization_response_iss_parameter_supported or received_issuer:\n            if received_issuer is None:\n                raise MissingIssuer()\n            if self.issuer and received_issuer != self.issuer:\n                raise MismatchingIssuer(self.issuer, received_issuer)\n\n        # validate state\n        requested_state = self.state\n        if requested_state:\n            received_state = response_url.args.get(\"state\")\n            if requested_state != received_state:\n                raise MismatchingState(requested_state, received_state)\n\n        error = response_url.args.get(\"error\")\n        if error:\n            return self.on_response_error(response)\n\n        if \"code\" in self.response_type:\n            code: str = response_url.args.get(\"code\")\n            if code is None:\n                raise MissingAuthCode()\n        else:\n            raise NotImplementedError()\n\n        return AuthorizationResponse(\n            code_verifier=self.code_verifier,\n            redirect_uri=self.redirect_uri,\n            nonce=self.nonce,\n            acr_values=self.acr_values,\n            max_age=self.max_age,\n            **response_url.args,\n        )\n\n    def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n\"\"\"Error handler for Authorization Response errors.\n\n        Triggered by [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback] if the response uri contains\n        an error.\n\n        Args:\n            response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n        Returns:\n            may return a default code that will be returned by `validate_callback`. But this method will most likely raise exceptions instead.\n        \"\"\"\n        response_url = furl(response)\n        error = response_url.args.get(\"error\")\n        error_description = response_url.args.get(\"error_description\")\n        error_uri = response_url.args.get(\"error_uri\")\n        exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n        raise exception_class(error, error_description, error_uri)\n\n    @property\n    def furl(self) -&gt; furl:\n\"\"\"Return the Authorization Request URI, as a `furl`.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={key: value for key, value in self.args.items() if value is not None},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n\"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n\n    def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Check if this Authorization Request is the same as another one.\n\n        Args:\n            other: another AuthorizationRequest, or a url as string\n\n        Returns:\n            `True` if the other AuthorizationRequest is the same as this one, `False` otherwise\n        \"\"\"\n        if isinstance(other, AuthorizationRequest):\n            return (\n                self.authorization_endpoint == other.authorization_endpoint\n                and self.args == other.args\n            )\n        elif isinstance(other, str):\n            return self.uri == other\n        return super().__eq__(other)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_state","title":"<code>generate_state()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>state</code> parameter.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_state(cls) -&gt; str:\n\"\"\"Generate a random `state` parameter.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.generate_nonce","title":"<code>generate_nonce()</code>  <code>classmethod</code>","text":"<p>Generate a random <code>nonce</code>.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@classmethod\ndef generate_nonce(cls) -&gt; str:\n\"\"\"Generate a random `nonce`.\"\"\"\n    return secrets.token_urlsafe(32)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.as_dict","title":"<code>as_dict()</code>","text":"<p>Return a dict with all the parameters used to init this Authorization Request.</p> <p>Used for serialization of this request. A new AuthorizationRequest initialized with the same parameters will be equal to this one.</p> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>a dict of parameters</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def as_dict(self) -&gt; Mapping[str, Any]:\n\"\"\"Return a dict with all the parameters used to init this Authorization Request.\n\n    Used for serialization of this request. A new AuthorizationRequest initialized with the same parameters will be\n    equal to this one.\n\n    Returns:\n        a dict of parameters\n    \"\"\"\n    return {\n        \"authorization_endpoint\": self.authorization_endpoint,\n        \"client_id\": self.client_id,\n        \"redirect_uri\": self.redirect_uri,\n        \"scope\": self.scope,\n        \"response_type\": self.response_type,\n        \"state\": self.state,\n        \"nonce\": self.nonce,\n        \"code_verifier\": self.code_verifier,\n        \"code_challenge_method\": self.code_challenge_method,\n        \"issuer\": self.issuer,\n        \"authorization_response_iss_parameter_supported\": self.authorization_response_iss_parameter_supported,\n        \"acr_values\": self.acr_values,\n        \"max_age\": self.max_age,\n        **self.kwargs,\n    }\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_request_jwt","title":"<code>sign_request_jwt(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign the <code>request</code> object that matches this Authorization Request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>Optional[str]</code> <p>the alg to use to sign the request, if the passed <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>Optional[int]</code> <p>an optional number of seconds of validity for the signed reqeust. If present, <code>iat</code> an <code>exp</code> claims will be included in the signed JWT.</p> <code>None</code> <p>Returns:</p> Type Description <code>SignedJwt</code> <p>a <code>Jwt</code> that contains the signed request object.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_request_jwt(\n    self,\n    jwk: Union[Jwk, Dict[str, Any]],\n    alg: Optional[str] = None,\n    lifetime: Optional[int] = None,\n) -&gt; SignedJwt:\n\"\"\"Sign the `request` object that matches this Authorization Request parameters.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n        lifetime: an optional number of seconds of validity for the signed reqeust. If present, `iat` an `exp` claims will be included in the signed JWT.\n\n    Returns:\n        a `Jwt` that contains the signed request object.\n    \"\"\"\n    claims = {key: val for key, val in self.args.items() if val is not None}\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign(\n        claims,\n        key=jwk,\n        alg=alg,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign","title":"<code>sign(jwk, alg=None, lifetime=None)</code>","text":"<p>Sign this Authorization Request and return a new one.</p> <p>This replaces all parameters with a signed <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the JWK to use to sign the request</p> required <code>alg</code> <code>Optional[str]</code> <p>the alg to use to sign the request, if the passed <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>lifetime</code> <code>Optional[int]</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the signed Authorization Request</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign(\n    self,\n    jwk: Union[Jwk, Dict[str, Any]],\n    alg: Optional[str] = None,\n    lifetime: Optional[int] = None,\n) -&gt; RequestParameterAuthorizationRequest:\n\"\"\"Sign this Authorization Request and return a new one.\n\n    This replaces all parameters with a signed `request` JWT.\n\n    Args:\n        jwk: the JWK to use to sign the request\n        alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, don't use an 'exp' claim.\n\n    Returns:\n        the signed Authorization Request\n    \"\"\"\n    request_jwt = self.sign_request_jwt(jwk, alg, lifetime)\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n        expires_at=request_jwt.expires_at,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt_request_jwt","title":"<code>sign_and_encrypt_request_jwt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt a <code>request</code> object for this Authorization Request.</p> <p>The signed <code>request</code> will contain the same parameters as this AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>Optional[str]</code> <p>the alg to use to sign the request, if the passed <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>Optional[str]</code> <p>the alg to use to encrypt the request, if the passed <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request, if the passed <code>jwk</code> has no <code>enc</code> parameter.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>Optional[int]</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>JweCompact</code> <p>the signed and encrypted request object, as a <code>jwskate.Jwt</code></p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt_request_jwt(\n    self,\n    sign_jwk: Union[Jwk, Dict[str, Any]],\n    enc_jwk: Union[Jwk, Dict[str, Any]],\n    sign_alg: Optional[str] = None,\n    enc_alg: Optional[str] = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: Optional[int] = None,\n) -&gt; JweCompact:\n\"\"\"Sign and encrypt a `request` object for this Authorization Request.\n\n    The signed `request` will contain the same parameters as this AuthorizationRequest.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.\n\n    Returns:\n        the signed and encrypted request object, as a `jwskate.Jwt`\n    \"\"\"\n    claims = {key: val for key, val in self.args.items() if val is not None}\n    if lifetime:\n        claims[\"iat\"] = Jwt.timestamp()\n        claims[\"exp\"] = Jwt.timestamp(lifetime)\n    return Jwt.sign_and_encrypt(\n        claims=claims,\n        sign_key=sign_jwk,\n        sign_alg=sign_alg,\n        enc_key=enc_jwk,\n        enc_alg=enc_alg,\n        enc=enc,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.sign_and_encrypt","title":"<code>sign_and_encrypt(sign_jwk, enc_jwk, sign_alg=None, enc_alg=None, enc='A128CBC-HS256', lifetime=None)</code>","text":"<p>Sign and encrypt the current Authorization Request.</p> <p>This replaces all parameters with a matching <code>request</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>sign_jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the JWK to use to sign the request</p> required <code>enc_jwk</code> <code>Union[Jwk, Dict[str, Any]]</code> <p>the JWK to use to encrypt the request</p> required <code>sign_alg</code> <code>Optional[str]</code> <p>the alg to use to sign the request, if the passed <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc_alg</code> <code>Optional[str]</code> <p>the alg to use to encrypt the request, if the passed <code>jwk</code> has no <code>alg</code> parameter.</p> <code>None</code> <code>enc</code> <code>str</code> <p>the encoding to use to encrypt the request, if the passed <code>jwk</code> has no <code>enc</code> parameter.</p> <code>'A128CBC-HS256'</code> <code>lifetime</code> <code>Optional[int]</code> <p>lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.</p> <code>None</code> <p>Returns:</p> Type Description <code>RequestParameterAuthorizationRequest</code> <p>the same AuthorizationRequest, with a request object as parameter</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def sign_and_encrypt(\n    self,\n    sign_jwk: Union[Jwk, Dict[str, Any]],\n    enc_jwk: Union[Jwk, Dict[str, Any]],\n    sign_alg: Optional[str] = None,\n    enc_alg: Optional[str] = None,\n    enc: str = \"A128CBC-HS256\",\n    lifetime: Optional[int] = None,\n) -&gt; RequestParameterAuthorizationRequest:\n\"\"\"Sign and encrypt the current Authorization Request.\n\n    This replaces all parameters with a matching `request` object.\n\n    Args:\n        sign_jwk: the JWK to use to sign the request\n        enc_jwk: the JWK to use to encrypt the request\n        sign_alg: the alg to use to sign the request, if the passed `jwk` has no `alg` parameter.\n        enc_alg: the alg to use to encrypt the request, if the passed `jwk` has no `alg` parameter.\n        enc: the encoding to use to encrypt the request, if the passed `jwk` has no `enc` parameter.\n        lifetime: lifetime of the resulting Jwt (used to calculate the 'exp' claim). By default, do not include an 'exp' claim.\n\n    Returns:\n        the same AuthorizationRequest, with a request object as parameter\n    \"\"\"\n    request_jwt = self.sign_and_encrypt_request_jwt(\n        sign_jwk=sign_jwk,\n        enc_jwk=enc_jwk,\n        sign_alg=sign_alg,\n        enc_alg=enc_alg,\n        enc=enc,\n        lifetime=lifetime,\n    )\n    return RequestParameterAuthorizationRequest(\n        authorization_endpoint=self.authorization_endpoint,\n        client_id=self.client_id,\n        request=str(request_jwt),\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback","title":"<code>validate_callback(response)</code>","text":"<p>Validate an Authorization Response against this Request.</p> <p>Validate a given Authorization Response URI against this Authorization Request, and return an AuthorizationResponse.</p> <p>This includes matching the <code>state</code> parameter, checking for returned errors, and extracting the returned <code>code</code> and other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>the extracted code, if all checks are successful</p> <p>Raises:</p> Type Description <code>MismatchingIssuer</code> <p>if the 'iss' received in the response doesn't match the expected value.</p> <code>MismatchingState</code> <p>if the response <code>state</code> does not match the expected value.</p> <code>OAuth2Error</code> <p>if the response includes an error.</p> <code>MissingAuthCode</code> <p>if the response does not contain a <code>code</code>.</p> <code>NotImplementedError</code> <p>if response_type anything else than 'code'</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def validate_callback(self, response: str) -&gt; AuthorizationResponse:\n\"\"\"Validate an Authorization Response against this Request.\n\n    Validate a given Authorization Response URI against this Authorization\n    Request, and return an [AuthorizationResponse][requests_oauth2client.authorization_request.AuthorizationResponse].\n\n    This includes matching the `state` parameter, checking for returned errors, and extracting the returned `code`\n    and other parameters.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        the extracted code, if all checks are successful\n\n    Raises:\n        MismatchingIssuer: if the 'iss' received in the response doesn't match the expected value.\n        MismatchingState: if the response `state` does not match the expected value.\n        OAuth2Error: if the response includes an error.\n        MissingAuthCode: if the response does not contain a `code`.\n        NotImplementedError: if response_type anything else than 'code'\n    \"\"\"\n    try:\n        response_url = furl(response)\n    except ValueError:\n        return self.on_response_error(response)\n\n    # validate 'iss' according to RFC9207\n    received_issuer = response_url.args.get(\"iss\")\n    if self.authorization_response_iss_parameter_supported or received_issuer:\n        if received_issuer is None:\n            raise MissingIssuer()\n        if self.issuer and received_issuer != self.issuer:\n            raise MismatchingIssuer(self.issuer, received_issuer)\n\n    # validate state\n    requested_state = self.state\n    if requested_state:\n        received_state = response_url.args.get(\"state\")\n        if requested_state != received_state:\n            raise MismatchingState(requested_state, received_state)\n\n    error = response_url.args.get(\"error\")\n    if error:\n        return self.on_response_error(response)\n\n    if \"code\" in self.response_type:\n        code: str = response_url.args.get(\"code\")\n        if code is None:\n            raise MissingAuthCode()\n    else:\n        raise NotImplementedError()\n\n    return AuthorizationResponse(\n        code_verifier=self.code_verifier,\n        redirect_uri=self.redirect_uri,\n        nonce=self.nonce,\n        acr_values=self.acr_values,\n        max_age=self.max_age,\n        **response_url.args,\n    )\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequest.on_response_error","title":"<code>on_response_error(response)</code>","text":"<p>Error handler for Authorization Response errors.</p> <p>Triggered by validate_callback() if the response uri contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>the Authorization Response URI. This can be the full URL, or just the query parameters.</p> required <p>Returns:</p> Type Description <code>AuthorizationResponse</code> <p>may return a default code that will be returned by <code>validate_callback</code>. But this method will most likely raise exceptions instead.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def on_response_error(self, response: str) -&gt; AuthorizationResponse:\n\"\"\"Error handler for Authorization Response errors.\n\n    Triggered by [validate_callback()][requests_oauth2client.authorization_request.AuthorizationRequest.validate_callback] if the response uri contains\n    an error.\n\n    Args:\n        response: the Authorization Response URI. This can be the full URL, or just the query parameters.\n\n    Returns:\n        may return a default code that will be returned by `validate_callback`. But this method will most likely raise exceptions instead.\n    \"\"\"\n    response_url = furl(response)\n    error = response_url.args.get(\"error\")\n    error_description = response_url.args.get(\"error_description\")\n    error_uri = response_url.args.get(\"error_uri\")\n    exception_class = self.exception_classes.get(error, AuthorizationResponseError)\n    raise exception_class(error, error_description, error_uri)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest","title":"<code>RequestParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request</code> JWT.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request</code> <code>str</code> <p>the request JWT</p> required <code>expires_at</code> <code>Optional[datetime]</code> <p>the expiration date for this request</p> <code>None</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class RequestParameterAuthorizationRequest:\n\"\"\"Represent an Authorization Request that includes a `request` JWT.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request: the request JWT\n        expires_at: the expiration date for this request\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request: str,\n        expires_at: Optional[datetime] = None,\n    ):\n        self.authorization_endpoint = authorization_endpoint\n        self.client_id = client_id\n        self.request = request\n        self.expires_at = expires_at\n\n    @property\n    def furl(self) -&gt; furl:\n\"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request\": self.request},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n\"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return the Authorization Request URI, as a `str`.\n\n        Returns:\n             the Authorization Request URI\n        \"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest","title":"<code>RequestUriParameterAuthorizationRequest</code>","text":"<p>Represent an Authorization Request that includes a <code>request_uri</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_endpoint</code> <code>str</code> <p>the Authorization Endpoint uri</p> required <code>client_id</code> <code>str</code> <p>the client_id</p> required <code>request_uri</code> <code>str</code> <p>the request_uri</p> required <code>expires_at</code> <code>Optional[datetime]</code> <p>the expiration date for this request</p> <code>None</code> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class RequestUriParameterAuthorizationRequest:\n\"\"\"Represent an Authorization Request that includes a `request_uri` parameter.\n\n    Args:\n        authorization_endpoint: the Authorization Endpoint uri\n        client_id: the client_id\n        request_uri: the request_uri\n        expires_at: the expiration date for this request\n    \"\"\"\n\n    @accepts_expires_in\n    def __init__(\n        self,\n        authorization_endpoint: str,\n        client_id: str,\n        request_uri: str,\n        expires_at: Optional[datetime] = None,\n    ):\n        self.authorization_endpoint = authorization_endpoint\n        self.client_id = client_id\n        self.request_uri = request_uri\n        self.expires_at = expires_at\n\n    @property\n    def furl(self) -&gt; furl:\n\"\"\"Return the Authorization Request URI, as a `furl` instance.\"\"\"\n        return furl(\n            self.authorization_endpoint,\n            args={\"client_id\": self.client_id, \"request_uri\": self.request_uri},\n        )\n\n    @property\n    def uri(self) -&gt; str:\n\"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return str(self.furl.url)\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return the Authorization Request URI, as a `str`.\"\"\"\n        return self.uri\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.furl","title":"<code>furl: furl</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>furl</code> instance.</p>"},{"location":"api/#requests_oauth2client.authorization_request.RequestUriParameterAuthorizationRequest.uri","title":"<code>uri: str</code>  <code>property</code>","text":"<p>Return the Authorization Request URI, as a <code>str</code>.</p>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer","title":"<code>AuthorizationRequestSerializer</code>","text":"<p>(De)Serializer for <code>AuthorizationRequest</code> instances.</p> <p>You might need to store pending authorization requests in session, either server-side or client- side. This class is here to help you do that.</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>class AuthorizationRequestSerializer:\n\"\"\"(De)Serializer for `AuthorizationRequest` instances.\n\n    You might need to store pending authorization requests in session, either server-side or client-\n    side. This class is here to help you do that.\n    \"\"\"\n\n    def __init__(\n        self,\n        dumper: Optional[Callable[[AuthorizationRequest], str]] = None,\n        loader: Optional[Callable[[str], AuthorizationRequest]] = None,\n    ):\n        self.dumper = dumper or self.default_dumper\n        self.loader = loader or self.default_loader\n\n    @staticmethod\n    def default_dumper(azr: AuthorizationRequest) -&gt; str:\n\"\"\"Provide a default dumper implementation.\n\n        Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes\n        as base64url.\n\n        Args:\n            azr: the `AuthorizationRequest` to serialize\n\n        Returns:\n            the serialized value\n        \"\"\"\n        return BinaPy.serialize_to(\"json\", azr.as_dict()).to(\"deflate\").to(\"b64u\").ascii()\n\n    def default_loader(\n        self, serialized: str, azr_class: Type[AuthorizationRequest] = AuthorizationRequest\n    ) -&gt; AuthorizationRequest:\n\"\"\"Provide a default deserializer implementation.\n\n        This does the opposite operations than `default_dumper`.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            an AuthorizationRequest\n        \"\"\"\n        args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n        return azr_class(**args)\n\n    def dumps(self, azr: AuthorizationRequest) -&gt; str:\n\"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n        Args:\n            azr: an AuthorizationRequest to serialize\n\n        Returns:\n            the serialized AuthorizationRequest, as a str\n        \"\"\"\n        return self.dumper(azr)\n\n    def loads(self, serialized: str) -&gt; AuthorizationRequest:\n\"\"\"Deserialize a serialized AuthorizationRequest.\n\n        Args:\n            serialized: the serialized AuthorizationRequest\n\n        Returns:\n            the deserialized AuthorizationRequest\n        \"\"\"\n        return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_dumper","title":"<code>default_dumper(azr)</code>  <code>staticmethod</code>","text":"<p>Provide a default dumper implementation.</p> <p>Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes as base64url.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>the <code>AuthorizationRequest</code> to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized value</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>@staticmethod\ndef default_dumper(azr: AuthorizationRequest) -&gt; str:\n\"\"\"Provide a default dumper implementation.\n\n    Serialize an AuthorizationRequest as JSON, then compress with deflate, then encodes\n    as base64url.\n\n    Args:\n        azr: the `AuthorizationRequest` to serialize\n\n    Returns:\n        the serialized value\n    \"\"\"\n    return BinaPy.serialize_to(\"json\", azr.as_dict()).to(\"deflate\").to(\"b64u\").ascii()\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.default_loader","title":"<code>default_loader(serialized, azr_class=AuthorizationRequest)</code>","text":"<p>Provide a default deserializer implementation.</p> <p>This does the opposite operations than <code>default_dumper</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>an AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def default_loader(\n    self, serialized: str, azr_class: Type[AuthorizationRequest] = AuthorizationRequest\n) -&gt; AuthorizationRequest:\n\"\"\"Provide a default deserializer implementation.\n\n    This does the opposite operations than `default_dumper`.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        an AuthorizationRequest\n    \"\"\"\n    args = BinaPy(serialized).decode_from(\"b64u\").decode_from(\"deflate\").parse_from(\"json\")\n    return azr_class(**args)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.dumps","title":"<code>dumps(azr)</code>","text":"<p>Serialize and compress a given AuthorizationRequest for easier storage.</p> <p>Parameters:</p> Name Type Description Default <code>azr</code> <code>AuthorizationRequest</code> <p>an AuthorizationRequest to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>the serialized AuthorizationRequest, as a str</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def dumps(self, azr: AuthorizationRequest) -&gt; str:\n\"\"\"Serialize and compress a given AuthorizationRequest for easier storage.\n\n    Args:\n        azr: an AuthorizationRequest to serialize\n\n    Returns:\n        the serialized AuthorizationRequest, as a str\n    \"\"\"\n    return self.dumper(azr)\n</code></pre>"},{"location":"api/#requests_oauth2client.authorization_request.AuthorizationRequestSerializer.loads","title":"<code>loads(serialized)</code>","text":"<p>Deserialize a serialized AuthorizationRequest.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>str</code> <p>the serialized AuthorizationRequest</p> required <p>Returns:</p> Type Description <code>AuthorizationRequest</code> <p>the deserialized AuthorizationRequest</p> Source code in <code>requests_oauth2client/authorization_request.py</code> <pre><code>def loads(self, serialized: str) -&gt; AuthorizationRequest:\n\"\"\"Deserialize a serialized AuthorizationRequest.\n\n    Args:\n        serialized: the serialized AuthorizationRequest\n\n    Returns:\n        the deserialized AuthorizationRequest\n    \"\"\"\n    return self.loader(serialized)\n</code></pre>"},{"location":"api/#requests_oauth2client.flask","title":"<code>flask</code>","text":"<p>This modules contains helper classes for the Flask Framework.</p> <p>See Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.auth","title":"<code>auth</code>","text":"<p>Helper classes for the Flask framework.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin","title":"<code>FlaskSessionAuthMixin</code>","text":"<p>A Mixin for auth handlers to store their tokens in Flask session.</p> <p>Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens will be persisted between multiple requests to the front-end Flask app.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>the key that will be used to store the access token in session.</p> required <code>serializer</code> <code>Optional[BearerTokenSerializer]</code> <p>the serializer that will be used to store the access token in session.</p> <code>None</code> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskSessionAuthMixin:\n\"\"\"A Mixin for auth handlers to store their tokens in Flask session.\n\n    Storing tokens in Flask session does ensure that each user of a Flask application has a different access token, and that tokens will be persisted between multiple requests to the front-end Flask app.\n\n    Args:\n        session_key: the key that will be used to store the access token in session.\n        serializer: the serializer that will be used to store the access token in session.\n    \"\"\"\n\n    def __init__(self, session_key: str, serializer: Optional[BearerTokenSerializer] = None):\n        self.serializer = serializer or BearerTokenSerializer()\n        self.session_key = session_key\n\n    @property\n    def token(self) -&gt; Optional[BearerToken]:\n\"\"\"Return the Access Token stored in session.\n\n        Returns:\n            The current BearerToken for this session, if any.\n        \"\"\"\n        serialized_token = session.get(self.session_key)\n        if serialized_token is None:\n            return None\n        return self.serializer.loads(serialized_token)\n\n    @token.setter\n    def token(self, token: Optional[BearerToken]) -&gt; None:\n\"\"\"Store an Access Token in session.\n\n        Args:\n            token: the token to store\n        \"\"\"\n        if token:\n            serialized_token = self.serializer.dumps(token)\n            session[self.session_key] = serialized_token\n        else:\n            session.pop(self.session_key, None)\n</code></pre>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskSessionAuthMixin.token","title":"<code>token: Optional[BearerToken]</code>  <code>writable</code> <code>property</code>","text":"<p>Return the Access Token stored in session.</p> <p>Returns:</p> Type Description <code>Optional[BearerToken]</code> <p>The current BearerToken for this session, if any.</p>"},{"location":"api/#requests_oauth2client.flask.auth.FlaskOAuth2ClientCredentialsAuth","title":"<code>FlaskOAuth2ClientCredentialsAuth</code>","text":"<p>         Bases: <code>FlaskSessionAuthMixin</code>, <code>OAuth2ClientCredentialsAuth</code></p> <p>A <code>requests</code> Auth handler for CC that stores its token in Flask session.</p> <p>It will automatically gets access tokens from an OAuth 2.x Token Endpoint with the Client Credentials grant (and can get a new one once it is expired), and stores the retrieved token in Flask <code>session</code>, so that each user has a different access token.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OAuth2Client</code> <p>an OAuth2Client that will be used to retrieve tokens.</p> required <code>session_key</code> <code>str</code> <p>the key that will be used to store the access token in Flask session</p> required <code>serializer</code> <code>Optional[BearerTokenSerializer]</code> <p>a serializer that will be used to serialize the access token in Flask session</p> <code>None</code> <code>**token_kwargs</code> <code>Any</code> <p>additional kwargs for the Token Request</p> <code>{}</code> Source code in <code>requests_oauth2client/flask/auth.py</code> <pre><code>class FlaskOAuth2ClientCredentialsAuth(FlaskSessionAuthMixin, OAuth2ClientCredentialsAuth):\n\"\"\"A `requests` Auth handler for CC that stores its token in Flask session.\n\n    It will automatically gets access tokens from an OAuth 2.x Token Endpoint\n    with the Client Credentials grant (and can get a new one once it is expired),\n    and stores the retrieved token in Flask `session`, so that each user has a different access token.\n\n    Args:\n        client: an OAuth2Client that will be used to retrieve tokens.\n        session_key: the key that will be used to store the access token in Flask session\n        serializer: a serializer that will be used to serialize the access token in Flask session\n        **token_kwargs: additional kwargs for the Token Request\n    \"\"\"\n\n    def __init__(\n        self,\n        client: OAuth2Client,\n        session_key: str,\n        serializer: Optional[BearerTokenSerializer] = None,\n        **token_kwargs: Any,\n    ) -&gt; None:\n        super().__init__(session_key, serializer)\n        self.client = client\n        self.token_kwargs = token_kwargs\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific","title":"<code>vendor_specific</code>","text":"<p>Vendor-specific utilities.</p> <p>This module contains vendor-specific subclasses of [requests_oauth2client] classes, that make it easier to work with specific OAuth 2.x providers and/or fix compatibility issues.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.ping","title":"<code>ping</code>","text":"<p>PingID specific client.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.ping.PingClient","title":"<code>PingClient</code>","text":"<p>         Bases: <code>OAuth2Client</code></p> <p>A client for PingID Authorization Server.</p> <p>This will initialize all endpoints with the PingID specific urls, without using the metadata. Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using <code>OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")</code></p> Source code in <code>requests_oauth2client/vendor_specific/ping.py</code> <pre><code>class PingClient(OAuth2Client):\n\"\"\"A client for PingID Authorization Server.\n\n    This will initialize all endpoints with the PingID specific urls, without using the metadata.\n    Excepted for avoiding a round-trip to get the metadata url, this does not provide any advantage over using\n    `OAuth2Client.from_discovery_endpoint(issuer=\"https://myissuer.domain.tld\")`\n    \"\"\"\n\n    def __init__(\n        self,\n        issuer: str,\n        auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[str] = None,\n        session: Optional[requests.Session] = None,\n    ):\n        if not issuer.startswith(\"https://\"):\n            if issuer.__contains__(\"://\"):\n                raise ValueError(\"Invalid issuer, must be an https:// url or a domain name\")\n            issuer = f\"https://{issuer}\"\n        if \".\" not in issuer:\n            raise ValueError(\n                \"Invalid issuer. It must contain at least a dot in the domain name\"\n            )\n\n        super().__init__(\n            authorization_endpoint=f\"{issuer}/as/authorization.oauth2\",\n            token_endpoint=f\"{issuer}/as/token.oauth2\",\n            revocation_endpoint=f\"{issuer}/as/revoke_token.oauth2\",\n            userinfo_endpoint=f\"{issuer}/idp/userinfo.openid\",\n            introspection_endpoint=f\"{issuer}/as/introspect.oauth2\",\n            jwks_uri=f\"{issuer}/pf/JWKS\",\n            registration_endpoint=f\"{issuer}/as/clients.oauth2\",\n            ping_revoked_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/revokedSris\",\n            ping_session_management_sris_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/sessions\",\n            ping_session_management_users_endpoint=f\"{issuer}/pf-ws/rest/sessionMgmt/users\",\n            ping_end_session_endpoint=f\"{issuer}/idp/startSLO.ping\",\n            device_authorization_endpoint=f\"{issuer}/as/device_authz.oauth2\",\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0","title":"<code>auth0</code>","text":"<p>Implements subclasses for Auth0.</p>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0Client","title":"<code>Auth0Client</code>","text":"<p>         Bases: <code>OAuth2Client</code></p> <p>An OAuth2Client for an Auth0 tenant.</p> <p>Instead of providing each endpoint URL separately, you only have to provide a tenant name and all endpoints will be initialized to work with your tenant.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name or FQDN. If it doesn't contain a <code>.</code> or it ends with <code>.eu</code>, <code>.us</code>, or <code>.au</code>, then <code>.auth0.com</code> will automatically be suffixed to the provided tenant name.</p> required <code>auth</code> <code>Union[requests.auth.AuthBase, Tuple[str, str], str, None]</code> <p>the client credentials, same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Optional[requests.Session]</code> <p>the session to use, same definition as for OAuth2Client</p> <code>None</code> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0Client(OAuth2Client):\n\"\"\"An OAuth2Client for an Auth0 tenant.\n\n    Instead of providing each endpoint URL separately, you only have to provide a\n    tenant name and all endpoints will be initialized to work with your tenant.\n\n    Args:\n        tenant: the tenant name or FQDN. If it doesn't contain a `.` or it ends with `.eu`, `.us`, or `.au`,\n            then `.auth0.com` will automatically be suffixed to the provided tenant name.\n        auth: the client credentials, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: the session to use, same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n    \"\"\"\n\n    def __init__(\n        self,\n        tenant: str,\n        auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[str] = None,\n        session: Optional[requests.Session] = None,\n    ):\n        if (\n            \".\" not in tenant\n            or tenant.endswith(\".eu\")\n            or tenant.endswith(\".us\")\n            or tenant.endswith(\".au\")\n            or tenant.endswith(\".jp\")\n        ):\n            tenant = f\"{tenant}.auth0.com\"\n        if \"://\" in tenant and not tenant.startswith(\"https://\"):\n            raise ValueError(\n                \"Invalid tenant name. It must be a tenant name like 'mytenant.myregion' or a full issuer like 'https://mytenant.myregion.auth0.com'.\"\n            )\n        self.tenant = tenant\n        token_endpoint = f\"https://{tenant}/oauth/token\"\n        revocation_endpoint = f\"https://{tenant}/oauth/revoke\"\n        userinfo_endpoint = f\"https://{tenant}/userinfo\"\n        jwks_uri = f\"https://{tenant}/.well-known/jwks.json\"\n        super().__init__(\n            token_endpoint=token_endpoint,\n            revocation_endpoint=revocation_endpoint,\n            userinfo_endpoint=userinfo_endpoint,\n            jwks_uri=jwks_uri,\n            auth=auth,\n            client_id=client_id,\n            client_secret=client_secret,\n            session=session,\n        )\n</code></pre>"},{"location":"api/#requests_oauth2client.vendor_specific.auth0.Auth0ManagementApiClient","title":"<code>Auth0ManagementApiClient</code>","text":"<p>         Bases: <code>ApiClient</code></p> <p>A wrapper around the Auth0 Management API.</p> <p>See Auth0 Management API v2. You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>str</code> <p>the tenant name. Same definition as for Auth0Client</p> required <code>auth</code> <code>Union[requests.auth.AuthBase, Tuple[str, str], str, None]</code> <p>client credentials. Same definition as for OAuth2Client</p> <code>None</code> <code>session</code> <code>Optional[requests.Session]</code> <p>requests session. Same definition as for OAuth2Client</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>additional kwargs to pass to the ApiClient base class</p> <code>{}</code> Usage <pre><code>a0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (client_id, client_secret))\nusers = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n</code></pre> Source code in <code>requests_oauth2client/vendor_specific/auth0.py</code> <pre><code>class Auth0ManagementApiClient(ApiClient):\n\"\"\"A wrapper around the Auth0 Management API.\n\n    See [Auth0 Management API v2](https://auth0.com/docs/api/management/v2).\n    You must provide the target tenant name and the credentials for a client that is allowed access to the Management API.\n\n    Args:\n        tenant: the tenant name. Same definition as for [Auth0Client][requests_oauth2client.vendor_specific.auth0.Auth0Client]\n        auth: client credentials. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        session: requests session. Same definition as for [OAuth2Client][requests_oauth2client.client.OAuth2Client]\n        **kwargs: additional kwargs to pass to the ApiClient base class\n\n    Usage:\n        ```python\n        a0mgmt = Auth0ManagementApiClient(\"mytenant.eu\", (client_id, client_secret))\n        users = a0mgmt.get(\"users\", params={\"page\": 0, \"per_page\": 100})\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        tenant: str,\n        auth: Union[requests.auth.AuthBase, Tuple[str, str], str, None] = None,\n        client_id: Optional[str] = None,\n        client_secret: Optional[str] = None,\n        session: Optional[requests.Session] = None,\n        **kwargs: Any,\n    ):\n        client = Auth0Client(\n            tenant, auth=auth, client_id=client_id, client_secret=client_secret, session=session\n        )\n        audience = f\"https://{client.tenant}/api/v2/\"\n        api_auth = OAuth2ClientCredentialsAuth(client, audience=audience)\n        super().__init__(\n            base_url=audience,\n            auth=api_auth,\n            session=session,\n            **kwargs,\n        )\n</code></pre>"},{"location":"authors/","title":"Authors","text":""},{"location":"authors/#credits","title":"Credits","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>Guillaume Pujol guill.p.linux@gmail.com</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>None yet. Why not be the first?</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Detailed steps to reproduce the bug.</li> <li>Full error message whenever there is one</li> <li>Your Python version, operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>requests_oauth2client</code> could always use more documentation, whether as part of the official requests_oauth2client docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/guillp/requests_oauth2client/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>requests_oauth2client</code> for local development.</p> <ol> <li>Fork the <code>requests_oauth2client</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>$ git clone git@github.com:your_name_here/requests_oauth2client.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>$ tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check    https://github.com/guillp/requests_oauth2client/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ pytest tests.test_client_credentials\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Travis will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"Changelog","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#12","title":"1.2","text":"<ul> <li><code>OAuth2AuthorizationCodeAuth</code> now accepts an AuthorizationResponse</li> <li><code>AuthorizationRequest</code> now handles <code>nonce</code> and <code>acr_values</code></li> <li><code>OAuth2Client</code> accepts <code>authorization_endpoint</code> and <code>redirect_uri</code> at init time, and has a <code>authorization_request()</code> method to generate AuthorizationRequests</li> <li><code>BearerToken</code> has a <code>validate_id_token()</code> method to handle ID Token validation has specified in OIDC</li> <li>Added <code>PingClient</code> for PingFederate by PingID</li> </ul>"},{"location":"history/#11","title":"1.1","text":"<ul> <li>ApiClient now has <code>allow_redirects=False</code> by default</li> <li>OAuth2Client now has <code>extra_metadata</code></li> <li>bugfixes, optimizations, introduce methods for easier subclassing</li> </ul>"},{"location":"history/#100","title":"1.0.0","text":"<ul> <li>First properly documented version.</li> <li>Migrated from pipenv to poetry</li> <li>Added pre-commit checks</li> <li><code>requests</code> is now automatically imported with <code>from requests_oauth2client import *</code></li> <li>ApiClient is now a wrapper around <code>requests.Session</code> instead of a subclass</li> <li><code>ApiClient.__init__()</code> now accepts extra kwargs which will be used to configure the <code>Session</code>.</li> <li>Add <code>__getitem__</code> and <code>__getattr_</code> to ApiClient</li> <li><code>AuthorizationRequest.validate_callback()</code> now returns an <code>AuthorizationResponse</code> which contains all returned   response attributes instead of just a code. To access the authorization code, get the <code>code</code> attribute from that response.</li> <li><code>OAuth2Client.authorization_code()</code> now accepts an <code>AuthorizationResponse</code> as parameter, and will   use it to include all necessary parameters for the Authorization Code Grant.</li> <li>removed <code>OAuth2Client.authorization_code_pkce()</code></li> <li>Renamed <code>ClientSecretJWT</code> and <code>PrivateKeyJWT</code> to <code>ClientSecretJwt</code> and <code>PrivateKeyJwt</code>, for consistency with <code>jwskate</code>.</li> <li>Methods from <code>requests_oauth2client.utils</code> are no longer exposed in top-level module.</li> <li>Renamed base class <code>ClientAuthenticationMethod</code> to <code>BaseClientAuthenticationMethod</code>.</li> <li>Introduced a default timeout in <code>ApiClient</code></li> <li>Splitted <code>jwskate</code> into its own independant module</li> <li>Use <code>BinaPy</code> for binary data manipulation</li> <li>Add support for Pushed Authorization Requests</li> </ul>"},{"location":"history/#-018","title":"\\&lt;= 0.18","text":"<ul> <li>Draft versions</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install requests_oauth2client, run this command in your terminal:</p> <pre><code>$ pip install requests_oauth2client\n</code></pre> <p>This is the preferred method to install requests_oauth2client, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for requests_oauth2client can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/requests_oauth2client\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/requests_oauth2client/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use requests_oauth2client in a project</p> <pre><code>from requests_oauth2client import *\n</code></pre>"}]}